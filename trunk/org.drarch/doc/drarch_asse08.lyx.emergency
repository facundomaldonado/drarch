#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass llncs
\language english
\inputencoding auto
\font_roman ae
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 2
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\end_header

\begin_body

\begin_layout Title
Recovery of Architecture Method
\end_layout

\begin_layout Author
Facundo Maldonado, Nicolas Frontini, Alvaro Soria*
\newline

\family typewriter
{frontini, maldonado, asoria}@exa.unicen.edu.ar
\end_layout

\begin_layout Institute
ISISTAN Research Institute, Faculty of Sciences, UNICEN University 
\newline
Campus
 Universitario, (B7001BBO) Tandil, Bs.
 As., Argentina 
\newline
*Also CONICET
\end_layout

\begin_layout Abstract
A key aspect for the success of architecture-centric development is the
 traceability of design documentation.
 This means that the developers should always be aware of the relationships
 between the architectural model as documented and the derived implementation.
 However, these two artifacts are likely to diverge from each other, due
 to new requirements or maintenance tasks.
 In the case of complex systems, the provision of tool support to deal with
 these matters becomes really necessary.
 Along this line, we present a tool approach called 
\emph on
DRArch
\emph default
 that can assist the developers to recovery the architecture of a system.
 The output of the approach are Components and Use Case Maps diagramas.
 The main advantage of 
\emph on
DRArch
\emph default
 is that ...
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Architecture-centric development is being widely adopted as a software engineeri
ng practice.
 More and more, researchers and practitioners recognize that software architectu
res are very convenient models to do software design 
\begin_inset LatexCommand cite
key "SAIP"

\end_inset

, because these models allow developers manage the bridge between requirements
 and implementation at a high level of abstraction.
 The value of having an architecture model resides on that it documents
 the principal design concerns early in the development process, embodies
 the overall structure of the system being built, and therefore, impacts
 the final quality of the products.
 
\begin_inset Note Note
status open

\begin_layout Standard
Along this line, developers usually depart from an architectural description
 of the system and progressively refine this description until deriving
 a concrete implementation.
 During this activity, they also specify the relationships between the architect
ural model 
\emph on
as documented
\emph default
 and the architectural model 
\emph on
as implemented
\emph default
 
\begin_inset LatexCommand cite
key "SAIP,CLEMENTS02"

\end_inset

, in order to ensure some degree of consistency between the models.
 Several notations and profiles are nowadays available for this purpose
 
\begin_inset LatexCommand cite
key "CLEMENTS02"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unfortunately, due to the natural evolution of the system, the architecture
 and implementation are likely to lose consistency.
 Once the architectural design is ready, all the efforts typically focus
 on the implementation, and this progressively makes design documentation
 to get out-of-date.
 For instance, new requirements may cause a re-design of the architecture,
 with consequent changes in some parts of the implementation; and conversely,
 maintenance tasks may produce changes in the code that should be accommodated
 by the architecture.
 In these cases, the relationships of components (at the architectural level)
 with classes and methods (at the implementation level) no longer hold,
 and the developers have to manually restore consistency.
 This phenomenon is known as 
\emph on
architecture-implementation drift
\emph default
 
\begin_inset LatexCommand cite
key "PERRY92"

\end_inset

, and if not properly managed, it may actually spoils the benefits of architectu
re-centric development.
 So far, the topic has been tackled through some approaches based on reverse
 engineering, with uneven results.
 The lack of more suitable tool support to relate architectural specifications
 with code is still a problem for many software projects.
\end_layout

\begin_layout Standard
In this work, we propose a tool approach called 
\emph on
DRArch
\emph default
 to aid developers to recovery the architecture....This documentation only covers
 the behavior of components and some system structure.
 The 
\emph on
DRArch
\emph default
 approach has been developed in the context of the 
\emph on
FLABot
\emph default
 project
\begin_inset Foot
status open

\begin_layout Standard
\begin_inset LatexCommand htmlurl
name "FLABot Homepage"
target "http://www.exa.unicen.edu.ar/isistan/flabot/"

\end_inset


\end_layout

\end_inset

.
 In particular, we assume that architectural documentation doesn't exists....The
 architectural models are represented with Use-case Maps (UCMs), a practical
 notation to specify both components and flows of responsibilities.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
These responsibilities are materialized by specific classes and methods
 in the code.
 When something changes in the code and breaks what is prescribed by the
 architecture, 
\emph on
ArchSynch
\emph default
 is able to trace these changes back to the architectural specification.
 To do so, we have to instrument the application code and log information
 about its execution.
 For its analysis, 
\emph on
ArchSynch
\emph default
 compares these logs with the architectural specification, using number
 of 
\begin_inset Quotes eld
\end_inset

re-construction filters
\begin_inset Quotes erd
\end_inset

, and then detects which UCMs are inconsistent with the code.
 Moreover, 
\emph on
ArchSynch
\emph default
 can provide a list of possible repairs for the UCMs, so that the developer
 can execute them to update the architecture if necessary.
 This way, the developer is always aware of the 
\begin_inset Quotes eld
\end_inset

state of the traceability
\begin_inset Quotes erd
\end_inset

 between the architectural specification and the code.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The rest of the article is organized into 4 sections.
 Section 2 provides some core concepts regarding architectural documentation
 and use-case maps, and also explains the goals of the 
\emph on
FLABot
\emph default
 project.
 Section 3 presents the details of the 
\emph on
DRArch
\emph default
 approach through a motivating example, and describes the implementation
 of the tool.
 Section 4 discusses some related work.
 Finally, section 5 summarizes the conclusions of this work and comments
 on future lines of research.
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
A software architecture can be seen as a model of software organization,
 which serves to capture the most relevant design decisions regarding quality-at
tribute issues.
 Examples of architectural decisions include: the selection of a publisher-subsc
riber style, the allocation of responsibilities to a virtual-machine style,
 the choice of security checkpoints in a three-tier style, or the refactoring
 of some services accessed by many modules into a single module with an
 abstract interface, among others.
 Given the importance of these decisions for both stakeholders and developers,
 the documentation of software architectures is a central concern
\begin_inset LatexCommand cite
key "CLEMENTS02"

\end_inset

.
 An architectural description gives basically a high-level decomposition
 of the system in terms of: design elements, coarse-grained pieces of functional
ity, plus interactions and constraints among them.
 
\end_layout

\begin_layout Standard
In practice, architectural models are described with box-and-line notations
 through a number of different views 
\begin_inset LatexCommand cite
key "CLEMENTS02"

\end_inset

, such as modules, logic, processes, deployment, etc.
 In order to understand how the system works, these views should cover two
 aspects of the architecture: structure and behavior.
 On one side, the structure tells us from which components and connectors
 the systems are built, which patterns guide their composition in larger
 fragments, and what kind of constraints they should follow.
 On the other side, the behavior serves us to establish the correspondence
 between the system requirements and the responsibilities assigned to the
 different design elements.
 In particular, a useful view for specifying structure and behavior are
 
\emph on
Use-case Maps (UCMs)
\emph default
 
\begin_inset LatexCommand cite
key "BUHR95"

\end_inset

, which is the main architectural notation used by our approach.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Poner algo de los diagramas de componentes y aclarar que los diagramas son
 los que se reconstruyen.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Aca deberia ir algo de Programacion Logica y no tanto de UCM!!!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basic concept behind UCMs is to model functional scenarios by means
 of causal paths that cut across organizational structures.
 The core of UCMs has four elements, namely: responsibilities, paths, components
, and couplings among paths.
 The 
\emph on
responsibilities
\emph default
 express the functions each component is responsible for.
 The 
\emph on
paths
\emph default
 trace the progression of causes and effects among responsibilities.
 The 
\emph on
components
\emph default
 act as containers for responsibilities.
 The 
\emph on
couplings
\emph default
 serve to connect paths together and form larger patterns (e.g., fork and
 join nodes, preconditions, stubs, etc.).
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "cap:A-Use-Case-Map"

\end_inset

 shows an example of UCMs, where we have a simple 
\emph on

\begin_inset Quotes eld
\end_inset

set user name
\begin_inset Quotes erd
\end_inset

 scenario
\emph default
 for a user account management system.
 The system is organized around a Model-View-Controller style 
\begin_inset LatexCommand cite
key "BUSCHMANN96"

\end_inset

, in which the 
\emph on
Model
\emph default
 component and its 
\emph on
View
\emph default
 components are decoupled by means of a 
\emph on
Controller
\emph default
 component.
 The responsibility 
\emph on
receiveWidgetEvent
\emph default
 in 
\emph on
Controller
\emph default
 translates the event produced by a 
\emph on
View
\emph default
 to the responsibility 
\emph on
setUserName
\emph default
 in 
\emph on
Model
\emph default
, which then activates the responsibility 
\emph on
notifyModelObservers
\emph default
 also in 
\emph on
Model
\emph default
.
 When a change notification is sent from 
\emph on
Model
\emph default
 to 
\emph on
Controller
\emph default
, this causes the activation of the responsibility 
\emph on
handleModelChangeEvent
\emph default
, which finally triggers the update of 
\emph on
View
\emph default
 by executing the responsibility 
\emph on
updateView
\emph default
.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ucm-mvc.eps
	scale 65

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:A-Use-Case-Map"

\end_inset

A Use Case Map that shows a typical MVC application's control flow
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The FLABot project
\end_layout

\begin_layout Standard
Our interest in UCMs comes actually from a joint research project with Intel
 Corp., called 
\emph on
FLABot
\emph default

\begin_inset LatexCommand cite
key "SORIA04"

\end_inset

, about tool support for fault-localization and debugging.
 As part of this project, we have developed a tool approach that is able
 to recovery the architectural model of an application and....
 Here, we decided to use Components and UCMs for the specification of architectu
ral models, because the notation fits well with the idea of recovery any
 architecture.
\end_layout

\begin_layout Standard
Besides, the issue of architectural drift is also relevant to the project.
 In order to do an effective fault localization, 
\emph on
FLABot
\emph default
 requires the input application to be implemented according to its architectural
 design.
 This is accomplished by linking each responsibility of the architectural
 UCMs with a collection of Java classes and methods.
 Although we can initially ensure that the UCMs are somehow in agreement
 with the implementation, maintaining traceability between the architecture
 and the code is not straightforward.
 In fact, when testing the fault-localization tool with different applications,
 we faced various architectural documentation situations.
 Specifically, as the faults detected by the tool were repaired by the programme
rs, they hardly updated the architecture to reflect their modifications.
 Many times, these programmers had little knowledge of the global design,
 so they could not rearrange the UCMs and their mappings to fixed code.
\end_layout

\begin_layout Standard
Motivated by these experiences, we started to develop a complementary tool
 able to help developers to recover architectural UCMs and Java code in-sync
 while using 
\emph on
FLABot
\emph default
.
 A more general view of this issue led to the 
\emph on
DRArch
\emph default
 approach, which is the topic of the following section.
\end_layout

\begin_layout Section
DRArch Approach
\end_layout

\begin_layout Standard
The objective of 
\emph on
ArchSync
\emph default
 is to find differences between a UCM description and a piece of source
 code given as input, trying to generate a new version of the UCM where
 these differences are resolved as output.
 To achieve this functionality, we take advantage of a version control system
 and some execution logs of the application.
 The version control system provides information about those regions of
 the code that have been changed since the last update of the UCM.
 A general view of 
\emph on
ArchSync
\emph default
 is presented in Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "cap:Internal-view-of-ArchSync"

\end_inset

.
 Here, the 
\emph on

\begin_inset Quotes eld
\end_inset

source code 
\begin_inset Formula $\Delta$
\end_inset


\begin_inset Quotes erd
\end_inset


\emph default
 refers to the changes in the code, the 
\emph on

\begin_inset Quotes eld
\end_inset

UCM 
\begin_inset Formula $\Phi$
\end_inset


\begin_inset Quotes erd
\end_inset


\emph default
 is the original architectural description, and the 
\emph on

\begin_inset Quotes eld
\end_inset

UCM 
\begin_inset Formula $\Phi+\Delta$
\end_inset


\begin_inset Quotes erd
\end_inset


\emph default
 is the architectural description generated after synchronization.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align right
\begin_inset Graphics
	filename img/synchronizationUCMDetailed.eps
	lyxscale 70
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Internal-view-of-ArchSync"

\end_inset

Internal view of ArchSync
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Internally, 
\emph on
ArchSynch
\emph default
 is equipped with a network of filters that implement different types of
 processing.
 The operation of some of these filters requires user intervention.
 As mentioned in the previous section, the 
\emph on
UCM 
\begin_inset Formula $\Phi$
\end_inset


\emph default
 comes already with a set of mappings to code, but many of mappings might
 be out-of-date in the 
\emph on
source code
\emph default
 
\emph on

\begin_inset Formula $\Delta$
\end_inset


\emph default
.
 Based on this information, the filter 
\emph on
DiffMapper
\emph default
 is in charge of detecting all the potential UCM paths that might have been
 affected by changes in the source code.
 Once these paths are identified, the developer is responsible of exercising
 the system on the modified portions of code, to gather data about its execution.
 Assuming that the code is somehow instrumented, the filter 
\emph on
ExecutionLogger
\emph default
 constructs a number of execution logs, which give traces of the actual
 system behavior with respect to the potentially-changed paths.
 The instrumentation involves capturing a variety of low-level events such
 as: method calls, object creation, threads and exceptions, etc.
\end_layout

\begin_layout Standard
The mappings of 
\emph on
UCM 
\begin_inset Formula $\Phi$
\end_inset


\emph default
 are taken by the filter 
\emph on
LogAnalyzer
\emph default
, so as to translate the low-level events of the logs into a sequence of
 responsibility activations.
 Each sequence of responsibilities is matched against the corresponding
 outdated path by the filter 
\emph on
PathLogMatcher
\emph default
, which then exposes the mismatches between the 
\emph on
UCM 
\begin_inset Formula $\Phi$
\end_inset


\emph default
 and the 
\emph on
source code 
\begin_inset Formula $\Delta$
\end_inset


\emph default
 by creating a collection of 
\emph on
update scripts
\emph default
.
 At this point, the filter 
\emph on
Synchronizer
\emph default
 may apply the user-selected 
\emph on
update script
\emph default
 on the 
\emph on
UCM 
\begin_inset Formula $\Phi$
\end_inset


\emph default
 to produce finally the 
\emph on
UCM 
\begin_inset Formula $\Phi+\Delta$
\end_inset


\emph default
.
 This way, UCMs can be put in agreement with the changes in the source code.
\end_layout

\begin_layout Standard
The 
\emph on
PathLogMatcher
\emph default
 filter takes as input a potentially changed path and a responsibility activatio
n log (i.e., architectural-level execution trace).
 The algorithm in Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Path-Log-Matcher-Algorithm"

\end_inset

 correlates both inputs, performing the necessary changes over the out-of-date
 path to conciliate it with the log.
 The algorithm works around a set of 
\emph on
cursors
\emph default
, which keep the last points in the analyzed path that were successfully
 correlated and corrected.
 Every cursor points to some responsibility in the path, which is not yet
 correlated with some input in the log; this implies that all previous responsib
ilities in the causal sequence were correlated or corrected.
\end_layout

\begin_layout Standard
The set of update scripts begins empty, while the set of cursors starts
 with only a single element that points to the first responsibility of the
 path.
 After initialization, log entries are taken one by one.
 On each step, the algorithm selects a cursor to match against the current
 log entry.
 If the matching fails, that is, some unanticipated responsibility was activated
, the path is changed to match the log correctly at that point.
 After that, the cursor is advanced to the next responsibility in the path
 and the algorithm processes the next log entry, until the entire log is
 consumed.
\end_layout

\begin_layout Standard
In principle, note that there are many ways to represent the same system
 behavior with UCMs.
 Because of that, the 
\emph on
PathLogMatcher
\emph default
 produces a set of alternative scripts rather than a single one.
 An update script is a sequence of atomic actions, such as the ones listed
 in Table\InsetSpace ~

\begin_inset LatexCommand ref
reference "cap:TableOfUCMScriptOperations"

\end_inset

, that allow us to transform UCMs.
 These scripts are ranked by the amount of changes on the old UCM that each
 script carries on, as the smallest scripts will more likely resemble the
 architect's style of specification.
 Then, the developer is free to select the script that (s)he finds most
 appropriate for the specific case of architectural design, and ask the
 
\emph on
Synchronizer
\emph default
 to apply the script automatically.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="2in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Script action
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size footnotesize
remove(targetNode)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
It removes 
\emph on
targetNode
\emph default
 from the path
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size footnotesize
insertBetween(node1, node2, newNode)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
It inserts 
\emph on
newNode
\emph default
 between 
\emph on
node1
\emph default
 and 
\emph on
node2
\emph default
 
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size footnotesize
insertAfter(targetNode, newNode)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
It inserts 
\emph on
newNode
\emph default
 after 
\emph on
targetNode
\emph default
 in the path
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size footnotesize
transform(targetNode, newType)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
It transforms 
\emph on
targetNode
\emph default
's type to 
\emph on
newType
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:TableOfUCMScriptOperations"

\end_inset

UCM script operations
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard

\series bold
path-log-match
\series default
(path: Path, log: Log)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
cursors := { path.initialNode }
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
script := 
\begin_inset Formula $\textrm{Ø}$
\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
while
\series default
 log 
\begin_inset Formula $\neq$
\end_inset

 
\begin_inset Formula $\textrm{Ø}$
\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
cursor := 
\series bold
\emph on
selectCursor
\series default
\emph default
(cursors)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
logEntry := log.first
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
if
\series default
 cursor.responsibility 
\begin_inset Formula $\notin$
\end_inset

 logEntry.responsibilities
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
correctiveAction := 
\series bold
\emph on
selectAction
\series default
\emph default
(path, cursor, logEntry)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
script := script + correctiveAction
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
path := 
\series bold
correctPath
\series default
(path, correctiveAction)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
cursors := 
\series bold
correctCursors
\series default
(path, cursors, correctiveAction)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
else
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
cursors := 
\series bold
\emph on
advanceCursor
\series default
\emph default
(cursor, cursors)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
log := 
\series bold
removeFirst
\series default
(log)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end if
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
end while
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
if
\series default
 cursors 
\begin_inset Formula $\neq$
\end_inset

 
\begin_inset Formula $\textrm{Ø}$
\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
script := script + 
\series bold
removeAllFrom
\series default
(cursors)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
end if
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
return
\series default
 script
\end_layout

\begin_layout Standard

\series bold
end path-log-match
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Path-Log-Matcher-Algorithm"

\end_inset

Path-Log Matcher Algorithm (non-deterministic points in 
\series bold
\emph on
italic
\series default
\emph default
)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
A Sample Example
\end_layout

\begin_layout Standard
Let's go back to the UCM of Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "cap:A-Use-Case-Map"

\end_inset

, assuming that it has been correctly designed and implemented.
 In a later development stage (e.g.
 during maintenance), a new requirement arrives, and now all the operations
 performed by the users must be shown in a log view.
 Let's consider that a developer that is not aware of the architectural
 design is assigned to the requirement, and (s)he inadvertently implements
 a call to the log view inside the user model.
 Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "cap:Souce-code-level-MVC-violation"

\end_inset

 gives a possible Java implementation of the requirement.
 This clearly breaks the rules of the MVC style, but unless there is a strict
 code review, the change (and similar ones) would remain unnoticed to the
 rest of the developers.
 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard

\family typewriter
public class User {
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
...
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
public void setName(String newName) {
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
this.name = newName;
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
// begin change
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
logView.appendLogEntry(`User name modified');
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
// end change
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
notifyModelObservers(...);
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
}
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
...
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Souce-code-level-MVC-violation"

\end_inset

Souce code-level MVC violation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For dealing with this case of design documentation out-of-date, the 
\emph on
ArchSync
\emph default
 tool works as follows.
 First, the tool is notified of a change in the file 
\emph on
User.java
\emph default
, which is further analyzed to detect that the method 
\emph on
setName()
\emph default
 was actually modified by some programmer.
 Since this method had a mapping to the responsibility 
\emph on
setUserName
\emph default
, 
\emph on
DiffMapper
\emph default
 marks the path presented in Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "cap:A-Use-Case-Map"

\end_inset

 as potentially changed.
 The developer runs the test-case on the current implementation of the system,
 which produces an execution log.
 This execution log is, in turn, processed by 
\emph on
LogAnalyzer
\emph default
 to generate a sequence of responsibility activations like the one shown
 in Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "cap:Responsibility-execution-sequence"

\end_inset

.
 As a result of the comparison of this sequence with the original UCM, the
 
\emph on
PathLogMatcher
\emph default
 suggests a list of update scripts.
 Some update scripts applicable to the outdated UCM are shown in Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "cap:UCM-update-alternatives"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\paragraph_spacing single

\family typewriter
1.
 UserView.receiveWidgetEvent
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
2.
 UserController.handleWidgetEvent
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
3.
 UserModel.setUserName
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
4.
 LogView.addLogEntry
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
5.
 UserModel.notifyModelObservers
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
6.
 UserController.handleModelChangedEvent
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
7.
 UserView.updateView
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Responsibility-execution-sequence"

\end_inset

Responsibility execution sequence
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="1">
<features>
<column alignment="center" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Update script A:
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
insertBetween
\series default
(setUserName, 
\backslash

\backslash

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
 notifyModelObserver, addLogEntry)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\downarrow$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Graphics
	filename img/mvc-alt1.png
	scale 35

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Update script B:
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
transform
\series default
(setUserName, andFork)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
insertAfter
\series default
(setUserName, addLogEntry)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\downarrow$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Graphics
	filename img/mvc-alt2.png
	scale 35

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:UCM-update-alternatives"

\end_inset

UCM update alternatives
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
At this point, we should remark that the two UCM solutions proposed by 
\emph on
ArchSynch
\emph default
 match correctly with the implementation.
 In general, the variations in the solutions are due to the fact that UCMs
 are a quite abstract notation, and thus, it gives a palette of options
 for implementing the same conceptual use-case.
 Likewise, as causal paths do not imply a strict flow of execution, a single
 execution trace might correspond to many different paths.
 This is why, even when all the solutions generated by 
\emph on
ArchSync
\emph default
 are considered correct, the architect is responsible for choosing the solution
 that is most appropriate for the actual design context.
 A related remark is that the solutions often suggest changes on the UCMs
 that compromise the integrity of the architectural model.
 For instance, the update scripts shown in Figure 
\begin_inset LatexCommand ref
reference "cap:UCM-update-alternatives"

\end_inset

 reveal a style of implementation that violates the MVC architectural pattern.
 In these cases, the architect's criterion plays again a fundamental role.
 The architect can either proceed to apply the solution on his/her own,
 or decide that the requirement that originated the inconsistency must be
 re-implemented so as to conform the architecture.
\end_layout

\begin_layout Subsection
Implementation Issues
\end_layout

\begin_layout Standard
The 
\emph on
ArchSync
\emph default
 prototype has been implemented as an Eclipse plugin, allowing the tool
 to be integrated within the development process.
 At its current state, the 
\emph on
source code 
\begin_inset Formula $\Delta$
\end_inset


\emph default
 is built by using the Eclipse platform's local history infrastructure,
 but integration with Concurrent Versioning System (CVS) and other configuration
 management technologies is underway.
 Additionally, the UCM editor and the instrumentation mechanisms have been
 actually borrowed from some of the FLABot project's subsystems.
 The 
\emph on
PathLogMatcher
\emph default
 component was implemented in Prolog using JavaLog 
\begin_inset LatexCommand cite
key "JAVALOG"

\end_inset

 to take advantage of its Java-Prolog integration features.
\end_layout

\begin_layout Standard
The tool has been exercised with examples containing small source code changes
 between synchronizations, and also with examples with broader changes between
 synchronizations.
 As a result of evaluating the first group of examples, we found that the
 update scripts proposed by the tool were correct and generated new UCMs
 consistent with both the actual example implementation and the architect's
 specification style.
 Nonetheless, the update scripts proposed by tool for the second group of
 examples were considerably complex.
 That is, the amount of different alternatives for updating the UCMs made
 the problem impractical for being handled by the architect.
 Such a complexity was somehow expected and understandable for us, and it
 is because of this kind of situations that we imposed some restrictions
 for the approach.
 These restrictions are the following: (a) the initial UCM must be correct
 and (b) the updates must be performed regularly.
 This way, the gap that the tool must conciliate is likely to be of a manageable
 size.
 
\end_layout

\begin_layout Section
Related Work
\begin_inset LatexCommand label
name "sub:Related-Work"

\end_inset


\end_layout

\begin_layout Standard
The problem of 
\emph on
architecture-implementation drift
\emph default
 has been tackled in different ways.
 Basically, we can recognize two groups of approaches: one focused on the
 recovery of the architecture through reverse engineering techniques 
\begin_inset LatexCommand cite
key "RICHNER99,SANGAL05,SEFIKA96,BOWMAN99,GALL95"

\end_inset

 
\begin_inset LatexCommand cite
key "MEDVIDOVIC03,DISCOTECT"

\end_inset

, and another one using architectural description languages (ADLs) as support
 
\begin_inset LatexCommand cite
key "ALDRICH05,MEDVIDOVIC99"

\end_inset

.
\end_layout

\begin_layout Standard
In the approaches presented in 
\begin_inset LatexCommand cite
key "RICHNER99,SANGAL05,SEFIKA96"

\end_inset

, there are rules that specify the architect's intent, defining the permitted
 and forbidden relationships among the software components.
 These rules can then be used at any time to perform static and/or dynamic
 analysis over the source code to detect places where the architectural
 prescriptions are not followed.
 For example, Sangal et.al.
 
\begin_inset LatexCommand cite
key "SANGAL05"

\end_inset

 use a fixed matrix of components and relationships based on Java packages
 and their dependencies.
 Richner 
\begin_inset LatexCommand cite
key "RICHNER99"

\end_inset

 and Sefika et.al.
 
\begin_inset LatexCommand cite
key "SEFIKA96"

\end_inset

 provide more flexibility in that respect, by letting the user define both
 the clustering policy for components and the analysis strategies for different
 kinds of relationships via Prolog rules.
 As the main drawback, we see that these rules are not always intuitive
 to write or understand for common developers.
\end_layout

\begin_layout Standard
Other approaches to architectural recovery such as 
\begin_inset LatexCommand cite
key "BOWMAN99,GALL95,MEDVIDOVIC03"

\end_inset

 attempt to extract the system architecture directly from its source code.
 Perhaps the most complete approach is the one discussed by Medvidovic et.al.
 
\begin_inset LatexCommand cite
key "MEDVIDOVIC03"

\end_inset

, where the extraction activities are not only based on source code but
 rather complemented with requirements and architectural styles.
 More recently, Yan et.al.
 
\begin_inset LatexCommand cite
key "DISCOTECT"

\end_inset

 have developed a tool called DiscoTect that maps low-level system events
 to abstract architectural operations, which are interpreted by a special
 engine to build the runtime structure of the analyzed system.
 This idea of monitoring a running application is close to the analysis
 of execution logs performed by 
\emph on
ArchSync
\emph default
.
 The authors of 
\emph on
DiscoTect
\emph default
 have reported two successful case-studies for legacy systems, recovering
 a pipe-and-filter and a client-server style.
 The tool still needs to be evaluated with more complex architectural styles,
 where the mappings to code are not necessarily direct.
 Besides, none of these approaches have considered the extraction of paths
 of functionality, such as UCMs.
 Finally, Egyed 
\begin_inset LatexCommand cite
key "EGYED03"

\end_inset

 presents an automated approach to generate and validate trace dependencies
 between diverse software development artifacts.
 Such artifacts must be mapped to the source code of the implemented system.
 This approach also requires the designer to supply a set of test scenarios
 for the software system described, and a few hypothesized traces that link
 development artifacts.
 Test scenarios are executed on the running system to observe the lines
 of code they use.
 Execution traces are then combined to identify overlaps between them and
 interpreted to detect and analyze trace dependencies.
 This approach can generate new traces between model elements and scenarios,
 but the tool does not define the semantic meaning of those traces.
 This is not the case of ArchSync, where traces must be interpreted in the
 context UCMs that express causal order between significative responsibilities.
 The approach also depends on the systematic manual updating of the test
 cases to detect new dependencies on software changes.
\end_layout

\begin_layout Standard
On the other hand, Abi-Antoun et.al.
 
\begin_inset LatexCommand cite
key "ALDRICH05"

\end_inset

 proposes an approach where an architectural specification in the Acme ADL
 
\begin_inset LatexCommand cite
key "ACME"

\end_inset

 is kept in-sync with an implementation counterpart in ArchJava
\begin_inset LatexCommand cite
key "ALDRICH02"

\end_inset

, by taking advantage of the fact that both Acme and ArchJava are languages
 where components and connectors are first-class entities.
 Both views, i.e.
 the architectural specification and the implementation, are transformed
 into instances of a common tree structure, which is then compared to detect
 changes such as node insertions, deletions and renames.
 Unfortunately, this synchronization does not address neither architecture
 dynamism nor behavioral conformance between architecture and implementation.
 Besides, it should be noted that although ArchJava is very similar to Java,
 it is not strictly an object-oriented programming language.
\end_layout

\begin_layout Standard
An early work of Medvidovic et.
 al.
 
\begin_inset LatexCommand cite
key "MEDVIDOVIC99"

\end_inset

 describes a component-based environment targeted to the C2 style that enables
 architecture modeling, analysis and evolution based on an ADL that was
 specifically designed for these tasks.
 The environment assists the developer in the generation of an implementation
 for an evolutionary change that was performed on the architectural model.
 This is basically a top-down approach, well-suited for the ideal case where
 all changes are first applied to the architecture.
 Unfortunately, the common scenario is usually the opposite: the focus gears
 towards the implementation, and documentation is left out-of-date.
\end_layout

\begin_layout Standard
Regarding software configuration management (SCM) oriented approaches, we
 can find some approaches like 
\begin_inset LatexCommand cite
key "SCM05,TOSEM04"

\end_inset

 that provide tool support for versioning the architecture-implementation
 relationships throughout design, implementation and deployment.
 For example, the tool presented by Nistor et.al.
 
\begin_inset LatexCommand cite
key "SCM05"

\end_inset

 imposes a systematic editing process for source code and architecture in
 order to guarantee that both models are kept in-sync.
 However, the propagation of changes from one model to the other is always
 performed manually by the developer.
 On the contrary, 
\emph on
ArchSynch
\emph default
 implements a more flexible model of edition, which allows the developer
 to have the control of when and how to synchronize the UCMs with the implementa
tion.
\end_layout

\begin_layout Section
Conclusions and Future Work
\end_layout

\begin_layout Standard
In this paper, we have introduced a tool approach to deal with the inconsistenci
es between architectural documentation and implementation.
 The contributions of 
\emph on
ArchSync
\emph default
 to prevent the architecture-implementation drift are two-fold.
 It can reveal violations to behavioral rules imposed by the architectural
 model.
 Moreover, this analysis can be used by the architect either to update the
 architectural UCMs with respect to the implementation, or to re-codify
 some parts of the implementation according to the base architectural model.
 
\end_layout

\begin_layout Standard
Currently, the 
\emph on
ArchSync
\emph default
 tool is still at the level of prototype, which has been mainly used within
 the 
\emph on
FLABot
\emph default
 project.
 Thus, there are some assumptions and limitations.
 First, when a change in the source code occurs, we assume that it is possible
 to know the previous mappings between the UCMs and implementation.
 This means that the old implementation is consistent with the scenarios
 of the UCMs.
 These mappings should be specified when the architect designs the UCMs
 for the first time and then proceeds to implement them.
 Second, we rely on that the synchronization between UCMs and implementation
 is carried out frequently on small increments (e.g., daily), so that the
 delta among source code versions presents only small variations.
 If not, the recognition of activation of responsibilities based on the
 events of the execution logs may become computationally unmanageable.
 
\end_layout

\begin_layout Standard
The main drawback of the approach is the gap between a given UCM and the
 many possible implementations for the paths of responsibilities.
 So far, the tool tries to reconstruct the paths of responsibilities using
 a bi-directional analysis, which combines reverse information coming from
 the execution logs with forward information coming from the existent UCM
 mappings.
 Even though, this processing is far from being automatic, because it requires
 considerable semantic knowledge that is actually supplied by the architect.
 The architect interacts with the tool at two points: to provide the right
 execution logs and to select the update scripts if necessary.
 Besides, we cannot identify yet new responsibilities introduced from the
 code or changes in the grouping of components.
 We are planning to incorporate here more intelligent strategies, based
 for example on machine learning and case-based reasoning techniques.
\end_layout

\begin_layout Standard
There are other interesting lines of work that can improve the performance
 of 
\emph on
ArchSync
\emph default
.
 It is possible to integrate 
\emph on
ArchSync
\emph default
 with techniques for the synchronization of structural aspects to support
 more drastic evolutionary changes, such as refactorings.
 It is also possible to provide a suite of test-cases as a complement of
 the execution logs.
 Besides, the low-level information contained in the traces could be further
 analyzed to prune some operations in the generation of all the possible
 update scripts, and moreover, to detect source code changes that have been
 missed by the test cases.
 Finally, we believe the practical perspective taken in the design of 
\emph on
ArchSync
\emph default
 enables us to apply this tool as support for traceability in architectural
 design methods.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "plain"
bibfiles "bibliography"

\end_inset


\end_layout

\end_body
\end_document
