#LyX 1.5.6 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\language spanish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\float_placement H
\paperfontsize default
\spacing single
\papersize a4paper
\use_geometry true
\use_amsmath 2
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1.7in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language swedish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
frontmatter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \include{cover.lyx}
preview false

\end_inset


\end_layout

\begin_layout Chapter*
Resumen
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
addcontentsline{toc}{chapter}{Resumen}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las arquitecturas de software son modelos de sistemas que, al poseer un
 alto nivel de abs\SpecialChar \-
trac\SpecialChar \-
ción, facilitan la gestión de las relaciones y problemas
 entre re\SpecialChar \-
que\SpecialChar \-
ri\SpecialChar \-
mien\SpecialChar \-
tos e implementación.
 La adopción cada vez mayor del desarrollo centrado en la arquitectura se
 debe a que ésta expone las principales decisiones de diseño y sus consecuencias
 en una etapa temprana del desarrollo de software, y al hacerlo permite
 un mejor entendimiento del sistema.
 En consecuencia, un buen diseño arquitectónico tiene un impacto positivo
 en la calidad final de los sistemas.
\end_layout

\begin_layout Standard
Todo sistema de software posee una arquitectura de software subyacente.
 Sin embargo, no necesariamente existe en la práctica una documentación
 acertada de esta arquitectura.
 Muchas veces, los expertos que di\SpecialChar \-
seña\SpecialChar \-
ron el sistema se han ido de la organizaci
ón, la documentación existente es escasa o está desactualizada y solo se
 cuenta es con el código fuente.
 Adicionalmente, los sistemas legados suelen no poseer documentación alguna
 y es común que nuevos sistemas de software tengan que integrarse con éstos.
\end_layout

\begin_layout Standard
El problema de la falta de documentación arquitectónica ha sido tratado
 por medio de enfoques basados en ingeniería reversa, con resultados dispares.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] CUales enfoques??? cuales problemas tienen esos enfoques...
 (solo consideran estructura...
 )Hacer énfasis en considerar informacion dinámica del sistema a reconstruir...
 
\end_layout

\end_inset

La Reconstrucción de Arquitecturas de Software es una técnica para generar
 representaciones arquitectónicas de un sistema que puede ser usada para
 re-documentar la arquitectura de un sistema.
 Sin embargo, no hay una herramienta que resuelva todos los problemas, y
 la reconstrucción de las arquitecturas sigue siendo un problema para muchos
 proyectos de software.
 En particular, las herramientas existentes para reconstrucción de arquitecturas
 presentan dificultades tales como no considerar aspectos comportamentales
 del sistema ni basar su análisis en información dinámica.
\end_layout

\begin_layout Standard
En este trabajo, proponemos un enfoque semi-automatizado para asistir a
 los desarrolladores en tareas de reconstrucción de arquitecturas de software.
 El enfoque es acopañado por una herramienta de soporte llamada 
\emph on
DRArch
\emph default
 e implementada en Java y Prolog.
 El objetivo principal de 
\emph on
DRArch
\emph default
 es realizar un análisis de la información relevante que se pueda recolectar
 de un sistema, generando como salida una representación arquitectónica
 por medio de diagramas de componentes y de 
\emph on
Use-Case Maps
\emph default
 (UCMs).
 La información relevante proviene del código fuente (información estática),
 del log de ejecución del sistema (información dinámica) y del conocimiento
 de las personas que desarrollaron el sistema.
 Los UCMs son una notación práctica para especificar tanto componentes como
 flujos de responsabilidades.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Esta notación no solo el comportamiento sino que ademas la estructura
 del sistema..
\end_layout

\end_inset

Esto permite describir el sistema mediante un conjunto de vistas de alto
 nivel que abarcan tanto aspectos estructurales como de comportamiento.
\end_layout

\begin_layout Standard
Con la ayuda de la herramienta 
\emph on
DRArch
\emph default
, el arquitecto encargado de la reconstrucción sigue un proceso iterativo
 de refinamiento de la información recolectada.
 Durante el proceso, el arquitecto interactúa con la herramienta 
\emph on
DRArch
\emph default
 tomando ciertas decisiones sobre alternativas de reconstrucción y en cada
 paso 
\emph on
DRArch
\emph default
 genera diagramas de componentes y UCMs del sistema.
 El proceso termina cuando los diagramas obtenidos satisfacen los objetivos
 planteados por el arquitecto.
 Internamente, 
\emph on
DRArch
\emph default
 representa el modelo arquitectónico mediante un lenguaje de programación
 lógico, el cuál le brinda flexibilidad para realizar consultas complejas
 cuando elabora sugerencias para el arquitecto.
\end_layout

\begin_layout Standard
A fin de validar el enfoque de 
\emph on
DRArch
\emph default
, se realizaron experimentos con distintos casos de estudio.
 Estos casos de estudio mostraron resultados positivos en cuanto a la cantidad
 de artefactos arquitectónicos que pudieron ser reconstruidos, teniendo
 en cuenta la documentación original de cada caso.
 A su vez, se probó de reconstruir los mismos casos de estudio utilizando
 una herramienta existente (Structure 101), esto permitió realizar comparaciones
 y analizar los beneficios y limitaciones del enfoque 
\emph on
DRArch.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres]
\end_layout

\begin_layout Standard
agregar una linea con informacion resumida de: - Uds realizaron experimentos
 de reconstruccion que mostraron resultados positivos en cuanto a ....
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]Agregar parte del resultado de las experiencias ..
 es decir, que en base a experiencias a demostrado su ...
\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Agradecimientos
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
addcontentsline{toc}{chapter}{Agradecimientos}
\end_layout

\end_inset

A nuestros padres y demás familiares que nos brindaron su afecto y colaboración
 durante estos años de estudio.
\end_layout

\begin_layout Standard
Un especial agradecimiento a nuestro director Álvaro Soria y a nuestro co-direct
or Andrés Díaz Pace, por su colaboración, disposición y confianza brindados
 durante el desarrollo de este trabajo.
\end_layout

\begin_layout Standard
A nuestros amigos y compañeros, los cuales supieron estar a nuestro lado
 en forma incondicional durante todo este tiempo, y de los cuales nos sentimos
 muy contentos y orgullosos.
\end_layout

\begin_layout Standard
¡Gracias!
\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
mainmatter
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introducción
\begin_inset Note Note
status open

\begin_layout Standard
revisar todo el cap.
 y las notas que puso andres en el doc
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Aca poner algo como..
 la tendencia actual en el proceso de desarrollo software es focalizar las
 actividades de este proceso en la arquitectura del sistema.
 A este enfoque se lo conoce como desarrollo centrado en la arquitectura
 (refs)..
 Sin embargo, en la mayoria de los sistemas la documentacion es escasa o
 inexistente..
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La arquitectura de software es una disciplina que cumple un rol central
 en la toma de decisiones de diseño 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Agregar una linea tipo "Por ejemplo, ...." [ejemplo de decisiones]
\end_layout

\end_inset

 y en la comunicación entre todos los participantes del desarrollo de un
 producto de software.
 Por ejemplo, algunas decisiones de diseño que involucra esta disciplina
 son: asignación de recursos, definición de restricciones entre la comunicación
 de los distintos elementos, declaración de responsabilidades, etc.
 Como vehículo de comunicación, la do\SpecialChar \-
cu\SpecialChar \-
men\SpecialChar \-
ta\SpecialChar \-
ción de la arquitectura es fundament
al
\end_layout

\begin_layout Standard
Una tendencia actual en el proceso de desarrollo software es la de focalizar
 las actividades de este proceso en la arquitectura del sistema.
 A este enfoque se lo conoce como desarrollo centrado en la arquitectura
 
\begin_inset LatexCommand cite
key "SAIP"

\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] (refs)..
\end_layout

\end_inset

 Sin embargo, en la mayoría de los sistemas la documentación arquitectónica
 es escasa o inexistente.
 La arquitectura de software captura las principales decisiones de diseño
 del sistema.
 Es muy difícil que estas primeras decisiones puedan cambiarse más adelante,
 por ejemplo, durante el proceso de desarrollo.
 En general, una arquitectura abarca aspectos estructurales y de comportamiento
 así como también de 
\emph on
deployment
\emph default
, 
\emph on
allocation of work
\emph default
, etc.
 Los aspectos estructurales se refieren a vistas estáticas del sistema,
 mientras que los aspectos de comportamiento se refieren a vistas dinámicas
 del sistema.
 Por ejemplo, los diagramas de componentes sirven para representar aspectos
 estructurales, mientras que los 
\emph on
Use Case Maps
\emph default
 
\begin_inset LatexCommand cite
key "UCMBOOK"

\end_inset

 proveen un modelo para aspectos de comportamiento.
 Aún con la ayuda de las arquitecturas, entender cómo funciona un sistema
 complejo y comunicárselo a los stakeholders es un problema para muchas
 organizaciones.
 
\end_layout

\begin_layout Standard
Todo sistema de software posee una arquitectura de software subyacente.
 Sin embargo, no necesariamente existe en la práctica una documentación
 acertada de esta arquitectura.
 El hecho de lidiar con sistemas que no poseen documentación es un escenario
 que ocurre con frecuencia dentro de las organizaciones.
 Muchas veces, los expertos que diseñaron el sistema se han ido de la organizaci
ón, la documentación existente es escasa o esta desactualizada, no se dispone
 de todo el código fuente y lo único con que se cuenta es con el código
 ejecutable binario.
 También existen casos en donde la documentación disponible es inválida,
 es decir, el sistema no fue implementado siguiendo las restricciones y
 decisiones de diseño que la documentación describe.
 Adicionalmente, los sistemas legados suelen no poseer documentación alguna
 y es muy común que nuevos sistemas de software tengan que integrarse con
 estos.
 
\end_layout

\begin_layout Standard
En estas situaciones, dado que una arquitectura existe independientemente
 de su especificación, es que cobran importancia los enfoques de reconstrucción
 de arquitecturas 
\begin_inset LatexCommand cite
key "SAIP"

\end_inset

.
 Una de las principales contribuciones de estos enfoques es la generación
 de representaciones que sirven para comenzar (o contribuir a) la documentación
 explícita de la arquitectura de software.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Necesidad-de-Documentación-Arquitectónica"

\end_inset

Necesidad de Documentación Arquitectónica 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Hay un poco de confusion (al menos en el texto) entre lo que
 es "documentacion arquitectonica" y "reconstruccion de arquitecturas",
 y me gustaria que esto este bien claro para el lector "medio".
\end_layout

\begin_layout Standard
Obvio que en algun momento la necesidad de documentar lleva a reconstruccion,
 pero en general son 2 cosas separadas.
 Uno puede (re-)documentar sin reconstruir, y puede reconstruir sin estar
 interesado en la documentacion ...
\end_layout

\begin_layout Standard
Otro comentario es que Reconstruccion es una forma de chequear Architecture
 Conformance, pero no es la unica forma ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La documentación de una arquitectura es fundamental para el desarrollo de
 software ya que ésta actúa como vehículo comunicacional entre los diferentes
 stakeholders que participan en las diferentes etapas del desarrollo.
 La documentación permite que el sistema se diseñe, implemente, pruebe,
 instale y mantenga de acuerdo a las prescripciones arquitectónicas.
 A continuación, se discuten los principales factores que motivan la reconstrucc
ion de arquitecturas para documentar o re-documentar la arquitectura de
 un sistema.
\end_layout

\begin_layout Itemize
Inexistencia de documentación
\end_layout

\begin_deeper
\begin_layout Standard
Como se mencionó previamente, existen varias razones por las cuáles un sistema
 puede no disponer de documentación que describa la arquitectura de software.
 También es muy común que no se cuente con los expertos que originalmente
 diseñaron el sistema.
 En sistemas de estas características,es necesario conocer su arquitectura
 para poder comprender y mantener el sistema.
 Por ejemplo, en un sistema donde los componentes se comunican mediante
 un mecanismo de invocación implícita, es muy difícil darse cuenta cuáles
 son los componentes que se relacionan sin tener descripciones arquitectónicas
 de alto nivel que lo reflejen.
 No contar con la documentación arquitectónica aumenta considerablemente
 el riesgo de fracasos.
\end_layout

\end_deeper
\begin_layout Itemize
Erosión arquitectónica
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Esta frase es criptica.
 Explicarla mejor pleaes (por ejemplo, se ve que para poder entender lo
 del analisis a nivel arquitectonico, necesitan explicar en alguno lugar
 un poco mas de atributos de calidad, ya que los analisis son en general
 de atributos de calidad)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Asegurarse de que un sistema sea construido en conformidad con su diseño
 arquitectónico durante su desarrollo, evolución y mantenimiento es importante,
 ya que divergencias significativas entre arquitectura e implementación
 pueden comprometer la estructura y calidad del sistema 
\begin_inset LatexCommand cite
key "ABIANTOUN05b"

\end_inset

.
 Durante el desarrollo, es normal que se produzcan cambios en la documentación
 arquitectónica que luego no son reflejados en el código, o cambios en el
 código que no son apropiadamente documentados.
 A medida que el desfasaje entre documentación e implementación de una arquitect
ura se agrava, será cada vez más difícil de remediarlo por sus desarrolladores,
 con el consiguiente deterioro en la calidad del producto.
 Por ejemplo, una arquitectura de pipes and filters 
\begin_inset Note Note
status open

\begin_layout Standard
[REF]
\end_layout

\end_inset

 permite ciertos análisis de performance para predecir la latencia del sistema,
 pero una implementación equivocada de la estructura de pipes y filters
 puede invalidar dicho análisis, y conducir a problemas con la latencia
 final del sistema.
 
\end_layout

\begin_layout Standard
La arquitectura y la implementación pueden también perder consistencia debido
 a la evolución natural del sistema.
 Una vez que el diseño arquitectónico está listo, los esfuerzos se focalizan
 generalmente en la implementación, y esto hace que la documentación se
 desactualice progresivamente.
 Por ejemplo, nuevos requerimientos pueden causar un rediseño de la arquitectura
, con cambios consecuentes en algunas partes de la implementación; y por
 otro lado, algunas tareas de mantenimiento pueden producir cambios en el
 código que deberían ser reflejados mediante modificaciones de la arquitectura.
 Si bien es aceptable que exista temporalmente cierto desfasaje, el problema
 surge cuando los desarrolladores trabajan en la implementación sin mantener
 la documentación arquitectónica.
\end_layout

\begin_layout Standard
En otros casos, los desarrolladores suelen introducir pequeñas diferencias
 estructurales que invalidan reglas clave de la arquitectura.
 Por ejemplo, en un sistema estructurado en capas, es posible que un programador
 inadvertidamente genere dependencias no deseadas al saltear la capa inmediatame
nte inferior.
 Análogamente, en el desarrollo de sistemas web multibanda, es común el
 error de invocar directamente a la base de datos desde la banda de presentación.
 Como resultado, los análisis a nivel arquitectónico se ven afectados por
 información incompleta e incorrecto debido a defectos en la documentación
 
\begin_inset LatexCommand cite
key "ALDRICH05"

\end_inset

.
 En estos casos, las relaciones de los componentes (en el nivel arquitectónico)
 con clases y métodos (en el nivel de implementación) ya no se mantienen,
 y los desarrolladores deben restablecer la consistencia manualmente.
 
\end_layout

\begin_layout Standard
Éste fenómeno se conoce como corrimiento arquitectura-implementación\InsetSpace ~

\begin_inset LatexCommand cite
key "PERRY92"

\end_inset

 o erosión arquitectónica.
 Si no se maneja correctamente, estos desfasajes atentan contra los beneficios
 del desarrollo centrado en la arquitectura, ya que se pierde la trazabilidad
 entre requerimientos, decisiones de diseño y artefactos de implementación.
 
\end_layout

\end_deeper
\begin_layout Section
Reconstrucción de arquitecturas
\end_layout

\begin_layout Standard
La Reconstrucción de Arquitecturas de Software se define como una técnica
 para generar representaciones arquitectónicas de un sistema.
 En el contexto de éste trabajo, el principal uso de esta representación
 es el de documentar la arquitectura existente de un sistema.
 Sin embargo, la representación puede también ser utilizada con otros propósitos
: como base para la re-documentación de la arquitectura, como punto de comienzo
 para realizar re-ingeniería sobre el sistema y crear una nueva arquitectura,
 como forma de identificar componentes reusables, o para establecer una
 arquitectura base dentro de una línea de productos de software 
\begin_inset LatexCommand cite
key "Rick2003"

\end_inset

.
\end_layout

\begin_layout Standard
Existen diferentes técnicas y enfoques para recuperar representaciones de
 la arquitectura de un sistema.
 Básicamente, la mayoría de los enfoques estructuran un proceso de reconstrucció
n en un ciclo basado en extraer, abstraer y visualizar la información, como
 se muestra en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Enfoque-Extraer-Abstraer-Presentar"

\end_inset

.
 En todos los casos, este proceso es asistido por herramientas, las cuáles
 extraen información del sistema (ej.
 código fuente) y permiten ir tratándola a distintos niveles de abstracción.
 El principal actor es un experto en ingenieria reversa que utiliza una
 o más herramientas durante el proceso.
 La entrada del proceso no es solamente codigo fuente, sino que tambien
 abarca información textual, información dinámica, información sobre la
 organización física, histórica y humana como asi tambien la experiencia
 de lo las personas involucradas 
\begin_inset LatexCommand cite
key "Verjus2007"

\end_inset

.
 El resultado final es generalmente un conjunto de diagramas que representan
 la arquitectura del sistema.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ExtraerAbstraerPresentar.png
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Enfoque-Extraer-Abstraer-Presentar"

\end_inset

Enfoque Extraer-Abstraer-Presentar (Adaptado de 
\begin_inset Note Note
status open

\begin_layout Standard
REF
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una definición genérica de la Reconstrucción de Arquitecturas de Software
 es la que proponen Bass et.al.
 en 
\begin_inset LatexCommand cite
key "SAIP"

\end_inset

.
 La reconstruccion es definida como un proceso interpretativo, interactivo
 e iterativo que involucra varias actividades.La reconstruccion no es un
 proceso totalmente automático, sino que requiere de la capacidad y de la
 atención del experto en ingeniería reversa y del arquitecto (o alguien
 con conocimientos sobre la arquitectura del sistema).
\end_layout

\begin_layout Standard
La ingeniería de reversa 
\begin_inset Note Note
status open

\begin_layout Standard
Ingenieria reversa de la arquitectura lo usan como sinonimo de reconstruccion?
 Si es asi, aclarar porque aca confunde un poco ...
\end_layout

\end_inset

de una arquitectura consiste en todas las actividades que hacen que una
 arquitectura de software sea explícita.
 Generalmente, el análisis comienza en el nivel de implementación, y se
 va moviendo hacia niveles mas altos de abstracción, hasta llegar al nivel
 arquitectónico.
 El objetivo de este proceso es extraer modelos arquitectónicos del sistema
 desde la implementación.
 
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Motivación"

\end_inset

El problema de recuperar la documentación arquitectónica
\begin_inset Note Note
status collapsed

\begin_layout Standard
[andres] que los parrafos que siguen hablen del problema especifico
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es comúnmente aceptado que una arquitectura de software puede ser utilizada
 como vehículo de comunicación entre los stakeholders (personas con diferentes
 necesidades de un sistema).
 Sin embargo puede verse la falta de documentación arquitectónica en la
 mayoría de los proyectos de desarrollo actuales, especialmente en empresas
 de software pequeñas.
 Esta es una de las situaciones donde surge la necesidad de reconstruir
 la arquitectura de un sistema.
 La Reconstrucción de Arquitecturas es una técnica para generar representaciones
 arquitectónicas del sistema.
 Generalmente, esta técnica consiste en realizar las siguientes actividades
 de forma iterativa: 
\end_layout

\begin_layout Itemize
Extracción de información: El propósito de esta actividad es extraer información
 de distintas fuentes.
\end_layout

\begin_layout Itemize
Unificación de la información: Es necesario que la información recolectada
 este representada en una estructura de datos común.
\end_layout

\begin_layout Itemize
Análisis de información: En esta actividad es donde se realiza el mayor
 trabajo de la reconstrucción ya que se construyen abstracciones y varias
 representaciones de la información recolectada.
\end_layout

\begin_layout Itemize
Generación de vistas: Se crean vistas que representen y describan la arquitectur
a del sistema.
\end_layout

\begin_layout Standard
Supongamos que se tiene un sistema en el que existen varios componentes
 que envían y reciben eventos, con mucha flexibilidad a la hora de programar,
 y uno quisiera saber qué componentes trabajan con qué eventos, y ver el
 estilo de eventos general para realizar modificaciones.
 En esta situación, una representación de la arquitectura podría brindarnos
 la información necesaria.
\end_layout

\begin_layout Standard
Debido a la importancia de la arquitectura de software en la toma de decisión
 en diferentes etapas del proceso de desarrollo, contar con una buena documentac
ión es indispensable.
 Y en particular, si las prescripciones arquitectónicas se reflejan en el
 diseño detallado e implementación, mucho mejor, porque esto ayuda a que
 los razonamientos realizados a nivel arquitectónico se cumplan efectivamente
 en la implementación.
 A diferencia de las clases y paquetes, las abstracciones arquitectónicas
 no son cosas que sean directamente mapeables a código o que puedan ejecutarse.
\end_layout

\begin_layout Standard
En algunas soluciones a la Reconstrucción de Arquitecturas que se han propuesto
 la arquitectura del sistema se extrae principalmente por medio del análisis
 del código fuente.
 En otras , se utilizan enfoques que reconstruyen patrones de diseño porque
 esto asegura que la reconstrucción se más precisa pero restringe el análisis
 a sistemas implementados utilizando patrones de diseño.
 Muchos de los enfoques mencionados sólo muestran aspectos estructurales
 como diagramas de componentes o de clases y muy pocos muestran resultados
 que permitan visualizar el comportamiento del sistema de forma simple.
 Es decir, en el que se puedan visualizar procesos de más alto nivel que
 la de una simple secuencia de ejecución como lo son los diagramas de secuencia.
\end_layout

\begin_layout Standard
Estos enfoques presentan el resultado de la reconstrucción en un solo paso
 y el arquitecto no ve el progreso del proceso de reconstrucción.
 Esto hace que el proceso no se pueda “guiar” a medida que se reconstruye
 la arquitectura.
 Es decir, no se tiene control sobre qué y cómo se recupera la información,
 ni se puede intervenir si lo considera necesario.
 Además, no es posible manipular la información de forma interactiva, perdiendo
 así la posibilidad de contar con la experiencia del arquitecto y su conocimient
o en el dominio.
\end_layout

\begin_layout Standard
En resumen, la mayoría de los enfoques se basan en el paradigma "extraer-abstrae
r-presentar" que necesariamente requiere de varios pasos y de la experiencia
 del desarrollador para saber qué extraer, cómo abstraerlo y cómo visualizarlo.
 Por otro lado, ninguno de estos enfoques mantiene la información recuperada
 de tal forma que sea flexible su manipulación.
 
\end_layout

\begin_layout Section
Objetivos
\end_layout

\begin_layout Standard
Como objetivo principal del trabajo se propone definir un enfoque flexible
 para reconstruir arquitecturas de sistemas de software.
 Para ello, se asume un proceso de reconstrucción semi-automático que consiste
 en recolectar información de distintas fuentes (código fuente, logs de
 ejecución, experiencia de los expertos del sistema, etc.) y consolidarla
 en una representación común, a fin de permitir al usuario-desarrollador
 relacionar distintas piezas de información de forma sencilla
\begin_inset Note Note
status open

\begin_layout Standard
Trataria de ser un poco mas especifico sobre la “forma”, ya que si ponen
 “simple y sencilla” es algo muy generico y que no aporta mucho al enfoque
 ...
\end_layout

\end_inset

.
 Para esta representación se utiliza programación lógica.
 La idea es que una herramienta de asistencia pueda analizar la información
 disponible, y por medio de un mecanismo, pueda generar sugerencias al usuario-d
esarrollador sobre posibles vistas del modelo arquitectónico a reconstruir.
 Este proceso se repite, con el fin de ir refinando el modelo arquitectónico
 de manera incremental.
 El modelo que se va construyendo se transforma diagramas (vistas arquitectónica
s) que representan aspectos estructurales y comportamentales del sistema.
 Este enfoque, que denominamos 
\emph on
DRArch
\emph default
, se esquematiza en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Enfoque-de-asistencia-DRArch"

\end_inset

.
 Esencialmente, este trabajo no pretende desarrollar una nueva herramienta
 de reconstrucción de arquitecturas, sino desarrollar un asistente que facilite
 (y haga mas productivas) las interacciones entre el usuario y distintas
 herramientas de reconstrucción existentes.
 
\end_layout

\begin_layout Standard
Un aspecto a destacar de 
\emph on
DRArch
\emph default
 es que permite recolectar y procesar información comportamental del sistema,
 que es recolectada de logs del sistema.
 Si bien es posible reconstruir aspectos comportamentales basando el análisis
 en el código fuente 
\begin_inset LatexCommand cite
key "AMYOT-SAM02"

\end_inset

, hay casos en los que resulta casi imposible determinar el comportamiento
 real de la aplicación.
 Se puede mencionar por ejemplo casos en los que se explota el polimorfismo
 de la orientación a objetos y las instanciaciónes se dan en tiempo de ejecución.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/EnfoqueDrarch.PNG
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
actualizar la imágen
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Enfoque-de-asistencia-DRArch"

\end_inset

Enfoque de asistencia 
\emph on
DRArch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A fin de hacer el enfoque 
\emph on
DRArch
\emph default
 tratable computacionalmente, se impusieron dos restricciones adicionales
 para el proceso de reconstrucción de arquitecturas:
\end_layout

\begin_layout Itemize
Los sistemas de los cuales se pretende reconstruir su arquitectura deben
 ser implementados de acuerdo al paradigma de programación orientada a objetos.
 
\end_layout

\begin_layout Itemize
El usuario debe planificar cuál va a ser la estrategia de reconstrucción
 en base a un estudio de la información existente (entrevistas con desarrollador
es, documentos, etc.), y seleccionar como los conceptos relevantes del diseño
 del sistema se van a mapear a tipos específicos de artefactos arquitectónicos.
 Es decir, el usuario debe definir cuáles son los conceptos arquitectónicos
 que se desean reconstruir y a que granularidad (por ej., subsistema, componentes
, módulos o clases, etc.).
 Por ejemplo, en determinados sistemas el usuario puede estar interesado
 en reconstruir componentes que representen eventos, mientras que en otros
 sistemas, el usuario puede decidir que las fuentes de eventos se modelen
 como tareas (y no como componentes).
\end_layout

\begin_layout Standard
La herramienta 
\emph on
DRArch
\emph default
 que da soporte a nuestro enfoque fue diseñada como un framework Java que
 
\begin_inset Note Note
status open

\begin_layout Standard
bla,bla, bla...
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Organización del informe
\end_layout

\begin_layout Standard
El resto de este trabajo se encuentra organizado de la siguiente manera.
 En el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Contexto"

\end_inset

 se presentan los conceptos de arquitecturas de software, se describe su
 importancia, y se tratan los conceptos de estilos arquitectónicos y atributos
 de calidad.
 Luego, se introducen las nociones básicas de descripciones de arquitecturas,
 y se detallan los diagramas de componentes, el modelo de vistas “4 + 1”
 y los Use Case Maps.
\end_layout

\begin_layout Standard
Una vez introducido el contexto, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Trabajos-relacionados"

\end_inset

 se analizan y comparan trabajos relacionados sobre reconstrucción de arquitectu
ras que, de diferentes maneras, proporcionan soluciones al problema de la
 falta o inexistencia de documentación arquitectónica.
 Luego de este análisis, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:El-enfoque-DRArch"

\end_inset

 se explica el enfoque 
\emph on
DRArch
\emph default
, detallando los pasos que propone para la reconstrucción de arquitecturas.
 
\begin_inset Note Note
status open

\begin_layout Standard
Esto comentarlo arriba, en el ultimo parrafo de seccion 1.4 (sobre el Framework)
 java
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Implementación"

\end_inset

 se presentan el diseño de la herramienta 
\emph on
DRArch
\emph default
 y los aspectos más importantes de su implementación.
 A su vez, se realiza un recorrido por la herramienta, mostrando interfaces
 de usuario y representaciones de los datos.
\end_layout

\begin_layout Standard
En el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Casos-de-Estudio"

\end_inset

, se describen dos casos de estudio sobre los cuales se ejercitó la herramienta
 implementada.
 El primer caso de estudio es el sistema G2, que es una aplicación comercial
 desarrollada en un proyecto de transferencia con la empresa Delsat, S.A.
 El segundo caso de estudio, llamado Market, es un proyecto de prueba construido
 sobre un 
\emph on
framework
\emph default
 de invocación implícita via eventos (nota: el proyecto G2 se basa en el
 mismo 
\emph on
framework
\emph default
).
 A su ves, ambos casos de estudio se reconstruyeron con la herramienta Structure
 101 para poder compar los resutados obtenidos.
 Luego, se presenta el análisis de los resultados de estos casos de estudio.
\end_layout

\begin_layout Standard
Finalmente, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Conclusiones-y-Trabajos"

\end_inset

 se presentan las conclusiones del trabajo, y algunas propuestas para posibles
 trabajos futuros.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
***
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Esto esta todo amontonado.
 Separar las ideas y comentarios de cada capitulo en sus respectivos párrafos.
 
\end_layout

\end_inset

El resto de este trabajo se encuentra organizado de la siguiente manera.
 En el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Contexto"

\end_inset

 se presentan los conceptos de Arquitecturas de Software donde se describe
 su importancia, los estilos arquitectónicos y los atributos de calidad.
 Luego se introducen las Descripciones de Arquitecturas y se detallan los
 Diagramas de Componentes, el Modelo de Vistas 4 + 1 y los Use Case Maps.
\end_layout

\begin_layout Standard
Una vez introducido el contexto, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Trabajos-relacionados"

\end_inset

 se analizan y comparan algunos trabajos relacionados que de diferentes
 maneras apuntan a solucionar el problema de falta o inexistencia de documentaci
ón arquitectónica a través de la reconstrucción de arquitecturas.
 
\end_layout

\begin_layout Standard
Luego de este análisis, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:El-enfoque-DRArch"

\end_inset

 se explica el enfoque 
\emph on
DRArch
\emph default
, detallando cada uno de los pasos que propone para la reconstrucción de
 arquitecturas.
 Para aplicar el enfoque se desarrollo un prototipo de soporte.
 
\end_layout

\begin_layout Standard
En el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Implementación"

\end_inset

 se presentan su diseño y los aspectos más importantes de su implementación.
 A su vez, se realiza un recorrido por la herramienta 
\emph on
DRArch
\emph default
 mostrando interfaces de usuario, representaciones de los datos, etc.
\end_layout

\begin_layout Standard
Más adelante, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Casos-de-Estudio"

\end_inset

, a modo de casos de estudio se ejercitó la herramienta implementada con
 el sistema G2 – una aplicación comercial desarrollada en un proyecto de
 transferencia con la empresa Delsat, S.A.
 – y de 
\emph on
Market
\emph default
 – un proyecto de prueba construido sobre un framework de invocación (nota:
 el proyecto G2 se basa en el mismo framework).
 Luego, se presentan los resultados de estos casos de estudio.
\end_layout

\begin_layout Standard
Finalmente, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Conclusiones-y-Trabajos"

\end_inset

 se presentan las conclusiones del trabajo, junto con algunas propuestas
 para posibles trabajos futuros.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Contexto"

\end_inset

Contexto
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres]
\end_layout

\begin_layout Standard
a) La introducción a arquitecturas de software del capitulo 2 es un poco
 corta, con pocos ejemplos, y asume sin mas consideraciones que la "mejor"
 forma de documentar una arquitectura es a través de UCMs.
 No estoy diciendo que UCMs esta mal, pero todos sabes que documentar un
 diseño con UCMs no es tan simple ni efectivo ...
 
\end_layout

\end_inset

En este capítulo se ofrecerá una introducción a los conceptos centrales
 sobre los que se ha realizado este trabajo.
 En primer lugar se define la noción de 
\emph on
Arquitectura de Software
\emph default
 en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Arquitectura-de-Software"

\end_inset

, enfatizando la importancia de su documentación dentro de la organización
 y en particular para el equipo de desarrollo.
 También se realiza un análisis de por qué se elijen los UCMs para representar
 arquitecturas.
 En la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Use-Case-Maps"

\end_inset

 se presentan los 
\emph on
Use-Case Maps
\emph default
, una notación simple y efectiva para la documentación de comportamiento
 a nivel arquitectónico.
 Luego, en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Necesidad-de-Documentación-Arquitectónica"

\end_inset

 se introduce un problema relacionado con la falta de documentación arquitectóni
ca, explicando las condiciones donde ocurre y las graves consecuencias que
 presenta para el desarrollo de software.
 Por último, en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Conclusión"

\end_inset

 y a modo de resumen, se resaltan los conceptos clave detallados en este
 capítulo.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Arquitectura-de-Software"

\end_inset

Arquitecturas de software
\end_layout

\begin_layout Standard
Si bien no existe una única definición de arquitectura de software universalment
e aceptada, generalmente todas lo hacen en función de conceptos comunes.
 En todas se encuentra la noción de descomposición de un sistema en diferentes
 partes, de relaciones existentes entre estas partes, de abstracción de
 las propiedades que no sean externamente visibles ni relevantes para la
 interacción de sus elementos.
 Adicionalmente, se sabe que existen diferentes perspectivas desde las que
 se puede observar un sistema según las propiedades de interés y que ninguna
 de estas vistas conforma la arquitectura en si.
 En su libro 
\emph on
Software Architecture in Practice
\emph default
\InsetSpace ~

\emph on

\begin_inset LatexCommand cite
key "SAIP"

\end_inset


\emph default
, Bass et.al.
 proponen una definición que abarca gran parte de las características antes
 mencionadas:
\end_layout

\begin_layout Quote

\emph on
La arquitectura de software de un programa o sistema de computación es la
 estructura o estructuras del sistema, las cuales abarcan los elementos
 de software, las propiedades externamente visibles de esos elementos, y
 las relaciones entre ellos.
\end_layout

\begin_layout Standard
Como se desprende de esta definición, una arquitectura de software puede
 abarcar
\emph on
 
\emph default
más de una estructura o vista.
 Un ejemplo que puede ilustrar esta propiedad es observar la estructura
 que presentan normalmente los proyectos de desarrollo.
 Generalmente éstos son particionados en módulos con una cierta cantidad
 de responsabilidades, que luego son asignadas a diferentes equipos para
 su de\SpecialChar \-
sa\SpecialChar \-
rro\SpecialChar \-
llo.
 Cada uno de estos módulos contiene programas y datos accesibles desde otros
 elementos, además de otros atributos que son privados.
 Éste tipo de estructura se emplea a menudo para describir un sistema y
 define principalmente cómo se divide y asigna su funcionalidad, por esta
 razón, representa una perspectiva estática.
 Por otro lado, existen estructuras que centran su atención en cómo los
 elementos interactúan en tiempo de ejecución para alcanzar la funcionalidad
 propuesta.
 Aquí el foco se pone sobre la manera en que los diferentes módulos interactúan
 para ejecutarse en diferentes procesos y como se comunican y sincronizan
 entre ellos.
 A pesar de que ambas vistas aportan información sobre la arquitectura,
 ninguna de ellas la describe en su totalidad.
 Por ejemplo, en una vista de 
\emph on
deployment
\emph default
, el sistema se describe en términos de cómo es el 
\emph on
deploy
\emph default
 sobre las distintas plataformas y cómo éstas se comunican unas con otras.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] What about vistas de deployment?
\end_layout

\begin_layout Standard
In this view, the software is described in terms of how it is deployed across
 various platforms, and how these parts communicate with each other.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La definición precedente también caracteriza a las vistas del sistema por
 estar compuestas de elementos de software, de propiedades externamente
 visibles y de relaciones entre ellos.
 Justamente por ser una abstracción de un sistema complejo, la arquitectura
 de software oculta los detalles que no afectan la manera en que los diferentes
 elementos usan, son usados por, se relacionan con o interactúan con otros
 elementos.
\end_layout

\begin_layout Standard
Una de las implicancias de la definición de arquitectura, es su omnipresencia
 en cualquier sistema de software, aunque ésta no se encuentre documentada.
 Cualquier sistema posee elementos distinguibles con propiedades y relaciones
 asociadas, sin embargo no siempre existe alguien que conozca esta arquitectura,
 de aquí que resulte muy importante su documentación.
\end_layout

\begin_layout Standard
Finalmente, de la definición se deduce que el comportamiento de los elementos
 de software también forma parte de la arquitectura.
 Lo mismo ocurre con las propiedades internas de los elementos de software,
 en donde el comportamiento relevante en este nivel es aquel que afecte
 a la forma en cómo los demás elementos tienen que ser escritos y de qué
 manera deben comunicarse con él.
\end_layout

\begin_layout Standard
Las arquitecturas de software representan las primeras decisiones de diseño
 de un sistema.
 Estas decisiones son las más difíciles de corregir durante el proceso de
 desarrollo ya que tienen un gran impacto sobre el sistema.
 A su vez, las decisiones definen restricciones de implementación en donde
 se aplica el concepto de 
\emph on
separation of concerns
\emph default
.
 Por ejemplo, si una de las decisiones es que exista una separación entre
 la presentación y modelo de un sistema, dos estructuras bien definidas
 se dividen y cada implementación puede evolucionar independientemente de
 la otra.
 Un método que usualmente se utiliza para dividir el esfuerzo es el de asignar
 diferentes grupos de desarrolladores a diferentes porciones del sistema.
\end_layout

\begin_layout Standard
Existen muchos factores que influencian la arquitectura de un sistema.
 Uno de los mas importantes son los denominados 
\emph on
stakeholders
\emph default
.
 Los 
\emph on
stakeholders
\emph default
 son las personas y organizaciones que están interesadas en la construcción
 del sistema: el cliente, usuario final, los desarrolladores, el líder del
 proyecto, etc.
 Éstos colaboran con diferentes requerimientos de los cuales algunos se
 pueden contradecir.
 Los requerimientos no sólo son funcionales ya que construir un sistema
 aceptable incluye aspectos como 
\emph on
performance
\emph default
, disponibilidad, flexi\SpecialChar \-
bi\SpecialChar \-
li\SpecialChar \-
dad, escalabilidad, seguridad, etc.
 en donde cada 
\emph on
stakeholders
\emph default
 pueden estar interesados en algunos de estos requerimientos no funcionales
 (también llamados atributos de calidad).
\end_layout

\begin_layout Standard
Los atributos de calidad y los requerimientos son ortogonales.
 Si esto no fuera así, la incorporación de una nueva funcionalidad del sistema
 podría establecer el nivel de seguridad o el de disponibilidad o el de
 
\emph on
performance
\emph default
.
 Generalmente, estilos y modelos arquitectónicos son utilizados ya que la
 mayoría de éstos se basa en los atributos de calidad.
\end_layout

\begin_layout Standard
A continuación, se presentan los estilos y modelos arquitectónicos que nos
 ayudan a des\SpecialChar \-
cri\SpecialChar \-
bir los distintos tipos de componentes y su tipología.
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Estilos-y-Modelos"

\end_inset

Estilos\InsetSpace ~
y\InsetSpace ~
Modelos\InsetSpace ~
Arquitectónicos
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Esta definición esta incompleta.
 La parte mas importante de un estilo es que es un "paquete de decisiones
 de diseño" que prescribe los tipos y topología de componentes en una solución
 de software.
 Como resultado,un estilo favorece ciertos atributos de calidad y desfavorece
 otros.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los estilos arquitectónicos son descripciones de los distintos tipos de
 componentes y su topología.
 También incluye una descripción del patrón de datos y la interacción de
 control.
 Los estilos arquitectónicos son artefactos de ingeniería muy importantes
 porque definen soluciones de diseños que pueden ser aplicados a problemas
 recurrentes.
 Los estilos ofrecen modelos que se basan en la experiencia y en cómo fueron
 utilizados anteriormente.
 Es decir, un estilo es un "paquete de decisiones de diseño" que prescribe
 los tipos y topologías de componentes en una solución de software.
 Como resultado, un estilo favorece ciertos atributos de calidad y desfavorece
 otros.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Insertar un ejemplo de un estilo arquitectonico (para clarificar)
 y como seria la cosa entonces ....
 Esta piola utilizar un estilo que despues pueda aparecer en el Bubble,
 o en alguno de los casos de estudio, asi la cosa queda mas "cohesiva"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Garlan and Shaw [1993], Garlan et al.
 [1994], y Shaw and Clements [1997] proponen la siguiente definición de
 estilos arquitectónicos en términos de patrones de interacciones entre
 tipos de componentes:
\end_layout

\begin_layout Quote

\emph on
Un estilo arquitectónico determina el vocabulario de componentes y conectores
 que pueden ser usados en instancias de ese estilo, junto con un conjunto
 de restricciones de cómo pueden ser combinadas.
 De esta forma, se definen familias de estilos que comparten propiedades
 arquitectónicas comunes.
\end_layout

\begin_layout Standard
Por ejemplo, el estilo cliente-servidor es uno de los más comunes.
 El cliente y servidor son dos tipos de elementos, y su coordinación es
 descripta en términos de un protocolo que el servidor utiliza para comunicarse
 con cada uno de los clientes.
 El uso del término cliente-servidor implica que múltiples clientes existen,
 es decir, no es identificado el cliente por si solo.
 En la siguiente sección, se describe un estilo arquitectónico basado en
 eventos:
\end_layout

\begin_layout Description
Estilo\InsetSpace ~
Invocación\InsetSpace ~
Implícita\InsetSpace ~
(Basada\InsetSpace ~
en\InsetSpace ~
Eventos)
\end_layout

\begin_layout Standard
La idea principal del estilo de Invocación Implícita es que en vez de invocar
 directamente a una tarea, un componente puede producir uno o más eventos.
 Otros componentes en el sistema pueden registrar un evento asociando una
 tarea con un evento.
 Cuando se lanza un evento, el sistema invoca a todos las tareas que estén
 registradas a ese evento.
 Es por esto que la invocación se realiza de forma implícita.
 Para poder comprender este concepto, en la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Invocación-Implícita-vs."

\end_inset

 se muestra como funciona la invocación explícita y la implícita.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/InvocacionImplicita-Explicita.PNG
	width 70text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Invocación-Implícita-vs."

\end_inset

Invocación Implícita vs.
 Explícita
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Descripción
\end_layout

\begin_deeper
\begin_layout Itemize
En lugar de invocaciones de procedimientos explícitas o directas, un componente
 anuncia uno o más eventos y otros componentes registran el interés en un
 evento asociando un procedimiento a dicho evento.
\end_layout

\begin_deeper
\begin_layout Itemize
La ocurrencia de un evento causa la invocación “implícita”de procedimientos
 en otros módulos.
\end_layout

\begin_layout Itemize
Los componentes son los módulos cuyas interfaces ofrecen un conjunto de
 procedimientos y de eventos.
\end_layout

\begin_layout Itemize
Los conectores incluyen llamadas a procedimientos tradicionales, así como
 la ligadura de eventos con llamadas a procedimientos.
\end_layout

\end_deeper
\begin_layout Itemize
Restricciones:
\end_layout

\begin_deeper
\begin_layout Itemize
Quien anuncia el evento no conoce a qué componentes afecta éste.
\end_layout

\begin_layout Itemize
No se pueden hacer asunciones acerca del orden de procesamiento.
\end_layout

\end_deeper
\begin_layout Itemize
Ventajas
\end_layout

\begin_deeper
\begin_layout Itemize
Provee un robusto soporte para la reutilización.
\end_layout

\begin_layout Itemize
Facilita la evolución del sistema.
\end_layout

\end_deeper
\begin_layout Itemize
Desventajas
\end_layout

\begin_deeper
\begin_layout Itemize
Pérdida de control en el comportamiento del sistema.
\end_layout

\begin_layout Itemize
Problemas en el intercambio de datos.
\end_layout

\begin_layout Itemize
Es difícil asegurar la corrección global del sistema.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Uno de los aspectos más importantes de los estilos es el hecho de que éstos
 se basan en los atributos de calidad para definir sus componentes y su
 tipología.
 Ésta es la razón de por qué el arquitecto selecciona un determinado estilo
 arquitectónico.
 Algunos estilos representan soluciones para determinados problemas, otros
 sirven para sistemas de alta seguridad, otros siguen siendo usados exitosamente
 para sistemas de alta disponibilidad.
 Elegir un estilo arquitectónico es una de las primeras y más importantes
 decisiones del arquitecto.
\end_layout

\begin_layout Standard
Los estilos también pueden incluir una descripción informal en donde se
 detalla la relación costo-beneficio de aplicar el estilo relacionado con
 los atributos de calidad.
 Por ejemplo, una descripción podría ser: "Utilizar el estilo arquitectónico
 
\emph on
Pipes and Filters
\emph default
 cuando se requiera el reuso de los componentes mientras que la 
\emph on
performance
\emph default
 no es de alta prioridad".
\end_layout

\begin_layout Standard
Los modelos arquitectónicos se definen como una división de la funcionalidad
 con flujos de dato entre los distintos elementos.
 Es una descomposición estándar de un problema conocido en partes que cooperativ
amente resuelven el problema.
 Basados en la experiencia, los modelos son una característica de los dominios
 que poseen un alto grado de madurez.
 Por ejemplo, son bien conocidos los elementos estándar de un compilador:
 analizador léxico, analizador sintáctico, analizador semántico y generador
 de código intermedio, a su vez, también es conocido cómo es que estos elementos
 interactúan para realizar el objetivo que poseen en común.
\end_layout

\begin_layout Standard
Los estilos y modelos arquitectónicos no son arquitecturas.
 Son conceptos útiles para capturar elementos de una arquitectura.
 Sin embargo, sigue siendo conveniente mostrar una imagen del sistema con
 el estilo arquitectónico como parte de alguna vista.
\end_layout

\begin_layout Subsection
Importancia de las arquitecturas de software
\end_layout

\begin_layout Standard
Desde el punto de vista técnico, las arquitecturas de software toman un
 gran valor.
 Algunas de las razones de la importancia de las arquitecturas de software
 son:
\end_layout

\begin_layout Enumerate
Comunicación entre los 
\emph on
stakeholders
\emph default
: La arquitectura de software representa una abs\SpecialChar \-
trac\SpecialChar \-
ción común de un sistema
 y la mayoría de los 
\emph on
stakeholders
\emph default
 pueden utilizarla como medio de negociación, comprensión, consenso y comunicaci
ón.
 Por ejemplo, los usuarios están interesados el sistema esté disponible
 cuando se necesite, en cambio, los clientes están interesados en que la
 arquitectura se implemente en tiempo y forma y con el presupuesto disponible,
 por otro lado, los 
\emph on
managers
\emph default
 se interesan en si la arquitectura permite trabajar en equipo y de forma
 controlada.
 Y finalmente el arquitecto esta interesado en realizar todos estos objetivos.
\newline
La
 arquitectura provee un lenguaje común en el cuál diferentes intereses puede
 ser expresados, negociados y resueltos.
 Sin este lenguaje, es difícil entender un sistema lo suficiente como para
 poder tomar las primeras decisiones que influencien la funcionalidad y
 calidad del sistema.
\end_layout

\begin_layout Enumerate
Primeras decisiones de diseño: Las arquitecturas de software son responsables
 de las primeras decisiones de diseño sobre el sistema.
 Una implementación de un sistema res\SpecialChar \-
pe\SpecialChar \-
ta una arquitectura si es que cumplió
 con la estructura de las decisiones de diseño que se describieron en la
 arquitectura.
 Esto quiere decir que la implementación debe poder dividirse en los elementos
 prescriptos, los elementos deben poder interactuar entre ellos y cada elemento
 debe cumplir con las responsabilidades tal como se describió en la arquitectura.
\newline

La arquitectura no solo prescribe la estructura del sistema si no que también
 la estructura del proyecto y en algunas ocasiones, la estructura de toda
 la organización.
 Por ejemplo, si la arquitectura esta basada en un estilo de capas, se podría
 asignar una capa por desarrollador o grupo de desarrolladores.
\newline
Otra de las
 decisiones que se plantean en la arquitectura son los requerimientos no
 funcionales.
 De esta forma, la arquitectura determina los atributos de calidad del sistema.
 El la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Atributos-de-Calidad"

\end_inset

 se explica en detalle los atributos de calidad.
\end_layout

\begin_layout Enumerate
Abstracción transferible de un sistema: Una arquitectura de software constituye
 un modelo en donde se describe cómo un sistema es estructurado y cómo sus
 elementos funcionan juntos.
 Este modelo, se transfiere a lo largo de todo el sistema.
 Si el re-uso de artefactos ser realiza en una etapa temprana, mayor será
 el beneficio.
 Es decir, si re-usar código es un beneficio, re-usar componentes al nivel
 arquitectónico provee enormes beneficios.
 No sólo es el código se re-usa, también la experiencia en construir arquitectur
as con componentes que se re-usan de otras.
 Cuando las decisiones arquitectónicas son re-utilizadas a través de distintos
 sistemas, todas las consecuencias de las primeras decisiones descriptas
 en el punto anterior también son transferidas.
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Atributos-de-calidad"

\end_inset

Atributos de calidad
\end_layout

\begin_layout Standard
Usualmente, los requerimientos que se definen para un sistema no sólo son
 funcionales, sino que también se definen requerimientos no funcionales
 que se denominan Atributos de Calidad.
 Por ejemplo, un cliente podría especificar un requerimiento que defina
 que cuando se inicie una transacción, el sistema no debe demorar más de
 dos segundo en procesarla.
 Éste escenario es un requerimiento no funcional que pertenece al categoría
 
\emph on
performance
\emph default
 de los atributos de calidad.
 Los requerimientos funcionales y los atributos de calidad son ortogonales.
 Si esto no fuera así, la incorporación de una nueva funcionalidad del sistema
 podría establecer el nivel de seguridad o el de disponibilidad o el de
 
\emph on
performance
\emph default
.
 Es importante que los atributos de calidad tengan participación durante
 el diseño del sistema.
 Éstos deberían poder diseñarse y evaluarse a nivel arquitectónico.
 Si bien la arquitectura del sistema provee las bases para que los atributos
 de calidad se cumplan, esto no es suficiente ya que existen otras dependencias.
 Por ejemplo, la 
\emph on
performance
\emph default
 incluye aspectos arquitectónicos como qué responsabilidad debe ser asignada
 a cada componente y no arquitectónicos como la elección de algoritmos para
 implementar determinada responsabilidad.
 Los estilos y modelos arquitectónicos se basan principalmente en los atributos
 de calidad.
\end_layout

\begin_layout Standard
A continuación se describen algunos atributos de calidad:
\end_layout

\begin_layout Itemize

\emph on
Performance
\emph default
: Este atributo de calidad tiene que ver con los tiempos.
 Los eventos o\SpecialChar \-
cu\SpecialChar \-
rren (interrupciones, mensajes, peticiones de los usuarios
 o el paso del tiempo) y el sistema debe responder a éstos.
 Es decir, la 
\emph on
performance
\emph default
 es responsable en cuánto tiempo tarda al sistema en responder a los eventos
 que ocurren.
\end_layout

\begin_layout Itemize
Modificabilidad: El atributo de calidad modificabilidad se enfoca en el
 costo que implica realizar un cambio en alguna parte del sistema.
 Por lo tanto, es necesario identificar qué partes del sistema son las que
 pueden cambiar y en qué momento (en tiempo de desarrollo, de compilación,
 de configuración o de ejecución).
\end_layout

\begin_layout Itemize
Disponibilidad: Este atributo de calidad esta asociado a las fallas del
 sistema y las consecuencias que acarrean.
 Una falla del sistema ocurre cuando el sistema no provee consistentemente
 un servicio según lo especificado.
 Por ejemplo, una vez que el sistema falla, es importante saber cuánto tiempo
 requiere reparar el error.
\end_layout

\begin_layout Itemize
Seguridad: La seguridad es una medida del sistema que permite restringir
 el uso no autorizado de determinados servicios del sistema a los usuarios.
 Un ataque al sistema es cuando se intenta romper la seguridad de este.
 Por ejemplo, un usuario no autorizado a editar datos intenta modificarlos.
\end_layout

\begin_layout Itemize
Usabilidad: La usabilidad se enfoca en medir que tan fácil es para un usuario
 realizar una tarea en el sistema.
 Por ejemplo, si un usuario desea cancelar un pedido, esta actividad no
 debería pasar por más de dos pantallas.
\end_layout

\begin_layout Standard
Los escenarios de los atributos de calidad son un requerimiento específico
 y consisten en seis partes:
\end_layout

\begin_layout Enumerate
Fuente del estimulo: Alguna entidad que genere el estimulo, por ejemplo,
 un usuario, un sistema o algún otro actor.
\end_layout

\begin_layout Enumerate
Estímulo: Es la condición que necesita ser considerada.
\end_layout

\begin_layout Enumerate
Ambiente: El estimulo ocurre bajo determinadas condiciones.
 Por ejemplo, bajo condiciones normales.
\end_layout

\begin_layout Enumerate
Artefacto: El artefacto que es estimulado.
 Podría ser todo el sistema o alguna parte de este.
\end_layout

\begin_layout Enumerate
Respuesta: La respuesta es la actividad que se debe tomar luego de que se
 produzca el estimulo.
\end_layout

\begin_layout Enumerate
Medición de la respuesta: Cuando la respuesta ocurre, esta debe ser medida
 para que el requerimiento pueda ser testeado.
\end_layout

\begin_layout Standard
La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Atributos-de-Calidad"

\end_inset

 muestra las seis partes de los escenarios de los atributos calidad.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/AtributosDeCalidad.PNG
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Atributos-de-Calidad"

\end_inset

Partes de los escenarios de los atributos calidad
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un escenario para el atributo de calidad modificabilidad podría ser el siguiente
:
\end_layout

\begin_layout Standard
"Un desarrollador (Fuente del estimulo) desea realizar un cambio el la interfaz
 de usuario para modificar el color de la pantalla (Estimulo).
 Este cambio debería realizarse en el código (Artefacto) en tiempo de diseño
 (Ambiente).
 Debería llevar menos de 3 horas (Medición de la respuesta) para realizar
 el cambio y ninguna otra funcionalidad del sistema debería modificarse
 (Respuesta)."
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Descriptiones_Arquitectónicas"

\end_inset

Descripciones arquitectónicas
\end_layout

\begin_layout Standard
La documentación de una arquitectura es una etapa crucial para el desarrollo
 de software.
 Incluso con una arquitectura excelente, si ésta no es bien entendida y
 bien comunicada --en otras palabras, bien documentada-- es muy probable
 que el proyecto falle
\begin_inset LatexCommand cite
key "CLEMENTS02"

\end_inset

.
 Si uno se toma el trabajo de crear una arquitectura robusta, 
\emph on
debe
\emph default
 describirla con suficiente detalle, sin ambigüedad y organizada de manera
 tal que los demás puedan encontrar la información que necesitan.
 Si no se logra esto, todo el esfuerzo habrá sido en vano ya que la arquitectura
 no podrá ser usada.
\end_layout

\begin_layout Standard
Como se mencionó anteriormente, uno de los principales propósitos las arquitectu
ras de software es que sirven como medio de comunicación entre los distintos
 
\emph on
stakeholders.
 
\emph default
Su documentación facilita esta comunicación.
 Por ejemplo, los desarrolladores utilizan la documentación para capturar
 restricciones (o algunas libertades) durante la implementación del sistema.
 Por otro lado, 
\emph on
managers
\emph default
 utilizan esta misma documentación para crear equipos de trabajo y asignarlos
 a los diferentes módulos que describe la arquitectura.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Me parece que esta explicacion es confusa y de muy alto nivel.Explic
ar mas concreto please ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quizás el concepto más importante asociado con la documentación de arquitecturas
 de software es el de 
\emph on
vista
\emph default
, por ejemplo, el estilo arquitectónico de Invocación Implícita descripto
 en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sub:Estilos-y-Modelos"

\end_inset

 es mostrado con la vista de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Invocación-Implícita-vs."

\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Si es que no se puso una figura para el ejemplo de estilo de
 la seccion anterior, mostrarlo aca para ejemplificar lo de vista (y obvio,
 decir este es el estilo X mostrado con la vista Y)
\end_layout

\end_inset

.
 Recordando la definición de la arquitectura definida anteriormente, vemos
 a la esta como 
\begin_inset Quotes eld
\end_inset

la estructura o estructuras del sistema, que abarcan los e\SpecialChar \-
le\SpecialChar \-
men\SpecialChar \-
tos, sus
 propiedades externamente visibles, y las relaciones entre ellos
\begin_inset Quotes erd
\end_inset

.
 Una vista es una 
\emph on
representación
\emph default
 coherente de esos los elementos importantes que constituyen un sistema,
 tal como lo son el software o el hardware, respecto a la forma en que los
 involucrados la leen y escriben.
 La vista provee el principio básico de la documentación de una arquitectura
 de software:
\end_layout

\begin_layout Quote
Documentar una arquitectura significa documentar las vistas relevantes y
 luego agregar la documentación que se aplica a más de una vista.
\end_layout

\begin_layout Standard
Éste principio es útil porque separa el problema de la documentación en
 las siguientes partes 
\begin_inset LatexCommand cite
key "CLEMENTS02"

\end_inset

:
\end_layout

\begin_layout Description
Elección\InsetSpace ~
de\InsetSpace ~
las\InsetSpace ~
vistas\InsetSpace ~
relevantes.
 La elección depende de los usos que se le espera dar a la documentación.
 A través de estas vistas se deben expresar al menos tres aspectos del sistema:
 (a) cómo está estructurado el conjunto de unidades de implementación, (b)
 cómo está estructurado el conjunto de elementos que tienen 
\emph on
comportamiento
\emph default
 e in\SpecialChar \-
teraccio\SpecialChar \-
nes en tiempo de ejecución y (c) cómo se relaciona con elementos
 de su ambiente que no son software.
\end_layout

\begin_layout Description
Documentación\InsetSpace ~
de\InsetSpace ~
una\InsetSpace ~
vista.
 Si bien no existe un 
\emph on
template
\emph default
 estándar de documentación de vistas, es esperable que contenga al menos
 la siguiente información:
\end_layout

\begin_deeper
\begin_layout Enumerate
Presentación primaria: por lo general es un gráfico; presenta los elementos
 principales y sus relaciones.
\end_layout

\begin_layout Enumerate
Catálogo de elementos: detalla los elementos y relaciones presentados en
 la presentación primaria.
\end_layout

\begin_layout Enumerate
Diagrama de contexto: muestra cómo lo reflejado en la vista se relaciona
 con su ambiente usando el vocabulario de la misma.
\end_layout

\begin_layout Enumerate
Guía de variabilidad: explica en detalle los puntos de variación que son
 parte de la arquitectura y están explicados en esta vista.
\end_layout

\begin_layout Enumerate
Razonamiento arquitectónico: explica cómo el diseño reflejado en esta vista
 llegó a ser como es.
\end_layout

\begin_layout Enumerate
Glosario de términos.
\end_layout

\begin_layout Enumerate
Otra información.
\end_layout

\end_deeper
\begin_layout Description
Documentación\InsetSpace ~
de\InsetSpace ~
comportamiento.
 Las vistas convencionales de representación arquitectónica presentan 
\emph on
información estructural
\emph default
 del sistema.
 Sin embargo, ésta información 
\emph on
no es suficiente
\emph default
 para razonar acerca de ciertas propiedades del mismo.
 Es necesario describir aspectos comportamentales mediante vistas específicas.
 Exactamente qué aspectos del comportamiento modelar va a depender del tipo
 de sistema que se está diseñando: en un sistema de tiempo real importan
 las propiedades temporales de los eventos; mientras que en un sistema bancario
 las secuencias de eventos, las transacciones atómicas y los procedimientos
 de 
\emph on
rollback
\emph default
 son lo más importante.
\end_layout

\begin_layout Description
Documentación\InsetSpace ~
de\InsetSpace ~
la\InsetSpace ~
información\InsetSpace ~
que\InsetSpace ~
se\InsetSpace ~
aplica\InsetSpace ~
a\InsetSpace ~
más\InsetSpace ~
de\InsetSpace ~
una\InsetSpace ~
vista.
 Cons\SpecialChar \-
ti\SpecialChar \-
tu\SpecialChar \-
ye el complemento de la documentación de las vistas, es decir la
 información que se aplica a más de una vista o al paquete de documentación
 en sí.
 Consiste de tres aspectos principales, el cómo, el qué y el por qué:
\end_layout

\begin_deeper
\begin_layout Enumerate
Cómo está organizada la documentación, de manera que los interesados en
 la arquitectura pueden encontrar la información que necesitan eficientemente.
\end_layout

\begin_layout Enumerate
Qué es la arquitectura: una descripción general del sistema para orientar
 al lector acerca del propósito del sistema, la forma en que las vistas
 se relacionan entre sí, una lista de elementos y dónde aparecen, y un glosario
 que se aplica a toda la arquitectura.
\end_layout

\begin_layout Enumerate
Por\InsetSpace ~
qué la arquitectura es como es: el contexto del sistema, restricciones
 externas que han sido impuestas para darle forma a la arquitectura de cierta
 manera, y el razonamiento para las decisiones de mayor granularidad y escala.
\end_layout

\end_deeper
\begin_layout Standard
La documentación de la arquitectura libera al arquitecto de tener que contestar
 cientos de preguntas acerca de ella.
 Para crear la documentación, se deben entender a todas las partes interesadas
 y cómo esperan usarla.
 Por lo tanto, todos los interesados deben ser tenidos en cuenta a la hora
 de elegir las vistas relevantes.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Como les marque en otras partes, no se vayan "derechito" a
 los UCMs, sino den algo mas de info de contexto ...
 Por favor insertar referencias, texto y hasta alguna figura de otras notaciones
 para describir arquitecturas, tipo Model 4 + 1 de Krutchen, o algunos diagramas
 de UML2 por ejemplo...
\end_layout

\end_inset

En las siguientes secciones, se describen distintas notaciones para representar
 una arquitectura de software.
 Cada una de estas notaciones muestra un aspecto de la arquitectura.
 Por ejemplo, los diagramas de componentes muestran aspectos estructurales,
 mientras que la notación UCMs se especializa en mostrar el comportamiento
 del sistema.
 
\end_layout

\begin_layout Subsection
Modelo de Vistas 4 + 1
\end_layout

\begin_layout Standard
El modelo de vistas 4 + 1 propone separar el sistema en cuatro vistas esenciales
: la lógica, la de proceso, la física y la de desarrollo.
 Luego, para contribuir con las mediciones, presenta una vista más: la de
 casos de uso que permite describir aspectos funcionales del sistema entero
 
\begin_inset LatexCommand cite
key "Kruchten1995"

\end_inset

.
 
\end_layout

\begin_layout Standard
Cada una de las cinco vistas del modelo 4 + 1 describen distintos aspectos
 del sistema mientras que intencionalmente ocultan otros.
 El propósito principal de este modelo es que define una excelente forma
 en que los 
\emph on
stakeholders
\emph default
 comprendan la arquitectura del sistema.
 Los arquitectos utilizan este modelo para entender y documentar varias
 capas de una aplicación de forma sistemática y estándar.
 Los documentos creados por el modelo son fácilmente utilizados por todos
 los miembros del equipo de desarrollo.
\end_layout

\begin_layout Standard
Las cuatro primeras vistas de modelo representan aspectos lógicos, de procesamie
nto, físicos y de desarrollo de una arquitectura.
 La quinta vista consiste en los casos de uso y los escenarios que podrían
 describir con más detalle el resto de las vistas.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Esquema-4+1"

\end_inset

 muestra un esquema con las cinco vistas del modelo.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Esquema4mas1.gif
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Esquema-4+1"

\end_inset

Esquema Modelo de Vistas 4 + 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A continuación se describen las distintas vistas que propone el modelo de
 vistas 4 + 1.
\end_layout

\begin_layout Subsubsection
Vista Lógica
\end_layout

\begin_layout Standard
La vista lógica del modelo soporta requerimientos de comportamiento y muestra
 cómo el sistema esta distribuido en un conjunto de abstracciones.
 Las clases y los objetos son los elementos mas estudiados por esta vista.
 Se pueden utilizar diagramas de clase, de colaboración y de secuencia,
 entre otros, para mostrar las relaciones entre los elementos.
 Los diagramas de clases muestran clases y sus atributos, métodos y asociaciones
 con otras clases del sistema.
\end_layout

\begin_layout Standard
Los diagramas de clases muestran una "imagen" completa del sistema.
 Por un lado, los diagramas de clase son estáticos, por lo tanto, no dicen
 nada sobre el sistema reacciona a los eventos de los usuarios.
 Por otro lado, estos diagramas son demasiado detallados como para ofrecer
 una idea general de la arquitectura de todo el sistema.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/DiagramaDeColaboracion.png
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-Colaboración"

\end_inset

Diagrama de Colaboración 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/DiagramaDeSecuencia.png
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-Secuencia"

\end_inset

Diagrama de Secuencia 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los diagramas de colaboración (o de comunicación) y de secuencia muestran
 cómo in\SpecialChar \-
te\SpecialChar \-
rac\SpecialChar \-
tú\SpecialChar \-
an los objetos del sistema.
 Un diagrama de colaboración es una forma simple de mostrar los objetos
 del sistema y los mensajes y llamadas que pasan entre ellos.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-Colaboración"

\end_inset

 es un simple diagrama de colaboración en el que cada mensaje esta asociado
 a un número que indica el orden de la secuencia.
 Estos diagramas son muy prácticos para mostrar como los objetos colaboran
 en el sistema.
 Si se desea mostrar más detalles sobre la lógica del sistema, un diagrama
 de secuencias seria ideal (ver figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-Secuencia"

\end_inset

).
 Los diagramas de secuencia proveen mas detalles que los diagramas de colaboraci
ón pero siguen manteniendo la distancia de mostrar la arquitectura general
 de todo el sistema.
 Arquitectos y diseñadores suelen utilizar estos diagramas para refinar
 detalles el diseño.
 Por ejemplo, observando el diagrama de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-Secuencia"

\end_inset

 se podría realizar un cambio en el diseño si se desea que un nuevo objeto
 (
\family typewriter
Notifier
\family default
) responsable de notificar a cada 
\family typewriter
observer
\family default
 y que estas notificaciones corran en un proceso distinto.
\end_layout

\begin_layout Subsubsection
Vista de Desarrollo
\end_layout

\begin_layout Standard
La vista de desarrollo es usada para describir los módulos del sistema.
 Los módulos más bloques más grandes que las clases y los objetos y varían
 de acuerdo al ambiente de desarrollo.
 Los paquetes, sub-sistemas y las bibliotecas son considerados módulos.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-Paquetes"

\end_inset

 muestra como los paquetes de un sistema son anidados.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/DiagramaDePaquetes.png
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-Paquetes"

\end_inset

Diagrama de Paquetes 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
También es posible utilizar las vistas de desarrollo para estudiar la ubicación
 de los archivos del sistema y del ambiente de desarrollo.
 Adicionalmente, es una buena forma de visualizar las capas de un sistema
 si es que éste mantiene un estilo arquitectónico de capas.
 Un típico estilo arquitectónico de capas puede contener una capa para la
 presentación, otra capa de negocios y finalmente una capa de persistencia
 de datos.
\end_layout

\begin_layout Subsubsection
Vista de proceso
\end_layout

\begin_layout Standard
La vista de proceso permite describir y estudiar los procesos del sistema
 y como estos se comunican, si es que estos se comunican unos con otros.
 Una vista abstracta de los procesos y la comunicación de estos puede ayudar
 para advertir sobre errores.
 Esta vista es importante cuando el sistema posee múltiples y simultáneos
 procesos o 
\emph on
threads
\emph default
.
\end_layout

\begin_layout Standard
La vista de proceso puede descripta desde varios niveles de abstracción,
 comenzando desde la ejecución independiente de una red de comunicación
 de sistemas.
 Esta vista tiene en cuenta varios requerimientos no funcionales (atributos
 de calidad) como 
\emph on
performance
\emph default
, disponibilidad, etc.
 
\end_layout

\begin_layout Subsubsection
Vista Física
\end_layout

\begin_layout Standard
La vista física describe cómo la aplicación se instala y cómo se ejecuta
 en el una red de computadoras.
 Esta vista tiene en cuenta requerimientos no funcionales como la disponibilidad
, escalabilidad y 
\emph on
performance
\emph default
.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-Deployment"

\end_inset

 es un diagrama de 
\emph on
deployment
\emph default
 de un sistema web.
 Se tiene un nodo por cada usuario que corre el 
\emph on
browser
\emph default
 en su propia computadora.
 El sistema y la base de datos poseen sus propios nodos.
 Los nodos contienen una o mas computadoras.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/DiagramaDeDeployment.png
	width 20text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-Deployment"

\end_inset

Diagrama de 
\emph on
Deployment
\emph default
 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
La quinta vista
\end_layout

\begin_layout Standard
La quinta vista (+ 1) del modelo de vistas 4 + 1 consiste en los casos de
 uso y escenarios que podían describir con más detalle el resto de las vistas.
 Los casos de uso representan los aspectos funcionales del sistema.
 Sin embargo, en el caso del modelo vista 4 + 1, son utilizados para explicar
 la funcionalidad y las estructuras que describen las otras vistas.
 De esta forma, la vista de casos de uso consiste en diagramas de casos
 de uso y de especificaciones detalladas de las acciones y condiciones dentro
 de cada caso de uso.
\end_layout

\begin_layout Subsection
UML - Diagrama de Componentes
\end_layout

\begin_layout Standard
El principal objetivo de los diagramas de componentes es mostrar las relaciones
 estructurales entre los componentes de un sistema.
 Los componentes son considerados autónomos, encapsulando unidades entre
 un sistema o sub-sistema que provee una o más interfaces.
 La idea es que sea posible mostrar que los componentes se pueden reutilizar
 o remplazar por otros componentes de la arquitectura ya que un componente
 encapsula el comportamiento e implementa interfaces bien definidas.
 Adicionalmente, los diagramas de componentes son los más utilizados como
 medio de comunicación entre los distintos 
\emph on
stakeholders
\emph default
.
 Por ejemplo, los diagramas pueden ser presentados a los clientes ya que
 presentan un entendimiento del sistema completo en las primeras etapas
 de la ejecución de los proyectos.
 A su vez, los desarrolladores utilizan los diagramas de componentes ya
 que proveen la estructura del sistema que construirán en un alto nivel
 de abstracción.
\end_layout

\begin_layout Subsubsection
Notación
\end_layout

\begin_layout Standard
En la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:modelado-visual-componentes"

\end_inset

 se muestra una descripción básica de los diferentes elementos visuales
 que conforman la notación, junto con los conceptos asociados a cada uno
 de ellos.
 En la sección 
\family typewriter
a)
\family default
 de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:modelado-visual-componentes"

\end_inset

 se muestran distintas formas posibles de modelar un componente.
 El a sección 
\family typewriter
b)
\family default
 se muestran como se modelan las interfaces, 
\family typewriter
writeLog
\family default
 y 
\family typewriter
readLog
\family default
 son interfaces que provee el componente mientras que 
\family typewriter
dataSource
\family default
 es una interfaz que requiere.
 Finalmente, en la sección 
\family typewriter
c)
\family default
 se muestra cómo se relacionan los componentes.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/NotacionDiagramaDeComponentesUML.png
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:modelado-visual-componentes"

\end_inset

Modelado visual de los componentes en UML
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El diagrama de componentes es uno de los diagramas más importantes y es
 uno de los primero que se crean.
 Estos diagramas son invaluables porque modelan y documentan la arquitectura
 del sistema.
 Este tipo de diagrama es muy usado por los 
\emph on
stakeholders
\emph default
 para poder comprender el sistema.
 También sirve como entrada para otro tipo de diagramas como son los diagramas
 de 
\emph on
deployment
\emph default
.
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sec:Use-Case-Maps"

\end_inset

Use-Case Maps
\end_layout

\begin_layout Standard
Los 
\emph on
Use-Case Maps
\emph default
 (UCM) son una notación para diseño de alto nivel que ayuda a las personas
 tanto a expresar como a razonar acerca de los patrones de comportamiento
 de alta granularidad de un sistema 
\begin_inset LatexCommand cite
key "BUHR95"

\end_inset

.
 El nombre proviene del hecho de que son una notación visual para casos
 de uso y una extensión de ellos hacia el diseño de alto nivel.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y ...
 hay un NO son un lenguaje formal...] [andres] Esto esta confuso, y no se entiende
 a que apuntan las frases, por ejemplo palabras tipo: apropiado para especificac
ion formal (a mi me parece mas una notacion informal), decisiones deliberadament
e abiertas (cuales son, a que se refiere), y demas...
 Lo que es importante decir (y que el lector quiere sabes) es que "los UCMs
 combinan en una notacion de alto nivel el flujo global de comportamiento
 y la estructura de componentes", o algo similar ...
\end_layout

\begin_layout Standard
(si es que esto vino de alguna traduccion, revisarlo please para hacerlo
 mas entendible)
\end_layout

\end_inset

Sin embargo, el modelo no depende de la definición de casos de uso: provee
 su propia definición en sus propios términos.
\end_layout

\begin_layout Standard
Por sus cualidades, los UCMs son la notación elegida para representar las
 vistas comportamentales de las arquitecturas reconstruidas.
 Éstos combinan, en una notación de alto nivel, el flujo global del comportamien
to y la estructura de componentes del sistema.
 Los UCMs no son un lenguaje apropiado para especificación formal de comportamie
nto, ya que de\SpecialChar \-
li\SpecialChar \-
be\SpecialChar \-
ra\SpecialChar \-
da\SpecialChar \-
men\SpecialChar \-
te dejan algunas decisiones de diseño abiertas
 para ser tomadas durante el diseño detallado.
 Los UCM son solamente una notación para razonar y explicar el comportamiento
 de un sistema.
 Es importante de tener esto presente ya que es fácil caer en la trampa
 de buscar o colocar más información de la que corresponde encontrar en
 ellos.
\end_layout

\begin_layout Subsubsection
Notación básica e interpretación
\end_layout

\begin_layout Standard
A continuación se da una breve descripción de los diferentes elementos visuales
 que conforman la notación, junto con los conceptos asociados a cada uno
 de ellos.
 La idea principal detrás de los UCMs es la de modelar los casos de uso
 mediante secuencias causales (en adelante, 
\emph on
paths
\emph default
) a través de estructuras organizacionales, de esta manera combinando vistas
 estructurales y comportamentales de la arquitectura del sistema.
 Los UCMs tienen cuatro elementos principales: responsabilidades, paths,
 componentes y acoplamientos entre paths.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/responsibility.png
	scale 50

\end_inset

\InsetSpace ~
Responsabilidades.
 Expresan las funciones de las que cada componente es responsable.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/path.png
	scale 50

\end_inset

\InsetSpace ~
Paths.
 Trazan la progresión de causas y efectos entre responsabilidades.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/component.png
	scale 50

\end_inset

\InsetSpace ~
Componentes.
 Actúan como contenedores de responsabilidades.
\end_layout

\begin_layout Description
Acoplamientos.
 Sirven para conectar paths y así lograr patrones de mayor granularidad.
\end_layout

\begin_deeper
\begin_layout Description
\begin_inset Graphics
	filename img/andFork.png
	scale 50

\end_inset

\InsetSpace ~

\emph on
And\InsetSpace ~
Forks
\emph default
.
 Indican la bifurcación en dos 
\emph on
paths
\emph default
 concurrentes.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/andJoin.png
	scale 50

\end_inset

\InsetSpace ~

\emph on
And\InsetSpace ~
Joins
\emph default
.
 Indican la unión de dos 
\emph on
paths
\emph default
 concurrentes.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/orFork.png
	scale 50

\end_inset

\InsetSpace ~

\emph on
Or\InsetSpace ~
Forks
\emph default
.
 Indican el fin de un segmento causal común entre dos 
\emph on
paths
\emph default
.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/orJoin.png
	scale 50

\end_inset

\InsetSpace ~

\emph on
Or\InsetSpace ~
Joins
\emph default
.
 Indican el comienzo de un segmento causal común entre dos 
\emph on
paths
\emph default
.
\end_layout

\end_deeper
\begin_layout Subsubsection
\begin_inset LatexCommand label
name "sub:Ejemplo-UCM"

\end_inset

Ejemplo
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableSample.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-de-UCM"

\end_inset

Ejemplo de UCM
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Ejemplo-de-UCM"

\end_inset

 muestra un ejemplo de UCMs, donde hay un simple escenario donde una modificació
n en el modelo requiere de la notificación a la interfase de usuario y a
 un 
\emph on
logger
\emph default
.
 El sistema está organizado alrededor de un patrón de diseño 
\emph on
Observer-Observable
\emph default
 
\begin_inset LatexCommand cite
key "gamma93design"

\end_inset

, en el cual el componente 
\emph on
Observable 
\emph default
y los componentes 
\emph on
Observers
\emph default
 están desacoplados.
 El ejemplo instancia el patrón de la siguiente forma: el componente 
\emph on
UserModelObservable
\emph default
 representa el rol del 
\emph on
Observable
\emph default
 mientras que los componentes 
\emph on
UserInterfaceViewObserver
\emph default
 y de 
\emph on
UserLoggerObserver
\emph default
 son los 
\emph on
Observers
\emph default
.
 El componente 
\emph on
Main
\emph default
 es responsable de realizar los cambios al modelo.
 
\end_layout

\begin_layout Standard
La primer responsabilidad que se activa es 
\emph on
changeDataModel
\emph default
 y efectúa un cambio en el modelo.
 Luego la responsabilidad 
\emph on
notifyObservers
\emph default
 en el componente 
\emph on
UserModelObservable
\emph default
 es activada y envía una notificación de cambio a todos los 
\emph on
Observers
\emph default
.
 Ésto causa la activación de la respons
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Hacer referencia a cada parte de la notacion(es decir, nombre de los roles
 y porque son asi ..
 como userModel, userInterfaceView...etc...)..
 el amarillo es un poco fuerte..
 para el resto de los colores..
 por ahi ponerlos sin color de fondo a los comentarios 
\end_layout

\begin_layout Standard
El ejemplo parece demasiado simple..falta algun componente que efectue el
 inicio del cambio..
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] LAs figuras tiene que aparece lo mas cerca de la ref en el texto cuando
 generen el pdf..
 vi que hay bastante diferencia entre el parrafo que la referencia y donde
 aparece la figura...
\end_layout

\end_inset

abilidad 
\emph on
update
\emph default
 de los componentes 
\emph on
UserInterfaceViewObserver
\emph default
 y de 
\emph on
UserLoggerObserver
\emph default
 respectivamente.
\end_layout

\begin_layout Standard
Entre las múltiples representaciones gráficas posibles, una de las descripciones
 arquitectónicas elegidas para representar la arquitectura reconstruida
 de un sistema es la de UCMs, en especial, para representar el comportamiento
 
\begin_inset LatexCommand cite
key "BUHR95"

\end_inset

.
 A diferencia de otras descripciones arquitectónicas (basadas principalmente
 en mostrar la estructura de sistemas), este tipo de notaciones ayuda a
 las personas a razonar acerca del comportamiento del sistema.
 Otra de las razones principales de la elección de esta notación se basa
 en que permite la especificación conjunta de los principales aspectos arquitect
ónicos independientemente de la tecnología en la cual el sistema fue implementad
o.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Conclusión"

\end_inset

Resumen y discusión 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Este parrafo podria ir a la intro..
 esta bien escrito...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En este capítulo se introdujo el concepto de arquitectura de software, una
 disciplina que cumple un rol central en la toma de decisiones de diseño
 y en la comunicación entre todos los participantes del desarrollo de un
 producto de software.
 Como vehículo de comunicación, su documentación es fundamental, pues la
 falta de ella, o peor aún, el descuido al producirla y mantenerla, anulan
 o revierten todos los beneficios que el desarrollo centrado en la arquitectura
 puede aportar.
\end_layout

\begin_layout Standard
Posteriormente se presentaron distintas notaciones que usualmente se utilizan
 para re\SpecialChar \-
pre\SpecialChar \-
sen\SpecialChar \-
tar arquitecturas de software: El modelo 4 + 1, los diagramas
 de componentes de UML y la notación Use Case Maps (UCMs).
 La notación de UCMs, un modelo para la descripción de patrones de comportamient
o y algunos aspectos estructurales en un alto nivel de abs\SpecialChar \-
trac\SpecialChar \-
ción y granularida
d.
 Esta notación es especialmente útil para la documentación de comportamiento
 a nivel arquitectónico, ya que permite expresar, analizar y comunicar las
 trazas causa-efecto que proyectan los casos de uso sobre el sistema.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]Este parrafo, y en especial la ultima parte, es un poco criptico/confuso,
 mejorar lo de "contextualmente irrelevantes"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En último lugar se ofreció una breve descripción al problema de la escasa
 documentación arquitectónica evidenciando su necesidad.
 Muchos sistemas de software carecen de documentación arquitectónica.
 En otros casos, debido a la evolución natural de un sistema de software,
 es muy probable que la arquitectura documentada y su implementación pierdan
 consistencia, lo que puede perjudicar todos los beneficios del desarrollo
 centrado en la arquitectura.
 Éste problema ha motivado la creación de herramientas que, mediante diversos
 enfoques, intentan reconstruir representaciones arquitectónicas útiles
 para documentar la arquitectura.
 El capítulo siguiente se centra precisamente en estas herramientas.
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Trabajos-relacionados"

\end_inset

Trabajos relacionados
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Esto podria ir en el contexto..o juntar ambas secciones..
\end_layout

\end_inset

El problema de la falta de documentación arquitectónica o incluso su desactualiz
ación, como así también la re-ingeniería y la falta de sincronización entre
 arquitectura e implementación constituyen los principales motivadores de
 este trabajo.
\begin_inset Note Note
status collapsed

\begin_layout Standard
Y concluir el contexto con los trabajos relaciones que fueron la base de
 la motivación de este trabajo..
 porque las limitaciones encontrdas en los enfoques actuales proveniente
 del analisis de los trabajos relacionados tambien es parte de la motivación
 de este trabajo..
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En este capítulo se brinda una visión mas amplia sobre los distintos aportes
 existentes relacionados con la reconstrucción de arquitecturas, destacando
 los rasgos principales de cada enfoque.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
X Muchos enfoques de reconstrucción de arquitecturas y herramientas para
 apoyar dichos enfoques han sido cubiertos en la literatura.
 !!! no se entiende!!
\end_layout

\end_inset

La mayoría de los enfoques y herramientas para reconstrucción de arquitecturas
 están basados en un ciclo "extraer-abstraer-presentar", en el cuál el sistema
 es analizado con el propósito de popular un repositorio, que luego es consultad
o para poder construir representaciones abstractas del sistema que son presentad
as en forma interactiva y adecuada al ingeniero de software.
 Tilley et.
 al 
\begin_inset LatexCommand cite
key "Tilley1996"

\end_inset

 describe el enfoque extraer-abstraer-presentar con ma\SpecialChar \-
yor detalle, refiriéndose
 a los pasos de recolección de información, inferencia de conocimiento,
 y presentación de la información.
\end_layout

\begin_layout Standard
En la siguiente sección se resumirán aquellos trabajos que tratan la reconstrucc
ión de arquitecturas de software y se discutirán los enfoques tomados por
 ellos.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Aportes-científicos-relacionados"

\end_inset

Aportes relacionados
\end_layout

\begin_layout Standard
La problemática de descubrir el modelo arquitectónico de un sistema completament
e implementado ha sido abordado de diversas maneras.
 Entre ellos se encuentran enfoques de reconstrucción manuales apoyados
 con herramientas de visualización o de extracción de información, aquellos
 que implementan lenguajes de consultas para escribir pautas para cons\SpecialChar \-
tru\SpecialChar \-
ir
 
\emph on
clusters
\emph default
 o agregaciones automáticamente, y tambien aquellos que implementan técnicas
 diversas como mineria de datos ("
\emph on
data mining
\emph default
"), lenguajes de descripción arquitectónica (ADLs), redes de Petri o matrices
 de dependencias (DSM).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
X Esta clasificación es de ustedes o la sacaron de algún lado.??
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Utilización de otras técnicaCUales?? en que categoria caen..
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Standard
Estan clasificando desde el inicio entre estructura y comportamiento y ahora
 las clasifican de otra manera...
\end_layout

\begin_layout Standard
por lo menos una distincion deberia ir a ca..
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
For each tool/approach:
\end_layout

\begin_layout Standard
* what it does input language(s) (e.g., is it source code only or does it
 include things like makefiles?) 
\end_layout

\begin_layout Standard
* output 
\end_layout

\begin_layout Standard
** what views does it (help) build; code/module views or runtime/C&C views?
 
\end_layout

\begin_layout Standard
** what are the elements and relationships of these views 
\end_layout

\begin_layout Standard
** can the output be externalized (other than screen shots)? any flexibility/cus
tomizability in format? 
\end_layout

\begin_layout Standard
* does it support abstraction (i.e., the developer can define architectural
 concepts and their mapping to code constructs)? 
\end_layout

\begin_layout Standard
* use examples
\end_layout

\begin_layout Standard
**published case studies 
\end_layout

\begin_layout Standard
**anything that hints at scope capabilities or usability 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph

\emph on
Portable Bookshelf
\emph default
 (PBS)
\end_layout

\begin_layout Standard

\emph on
Portable Bookshelf 
\emph default
(PBS) es una herramienta usada para generar una biblioteca de software (
\emph on
bookshelf
\emph default
) 
\begin_inset LatexCommand cite
key "Finnigan97"

\end_inset

.
 La información contenida en la biblioteca incluye código fuente como también
 así cualquier otra documentación sobre el sistema como pueden ser casos
 de test, análisis de 
\emph on
performance
\emph default
, planes futuros, diagramas arquitectónicos e información sobre la historia
 del proyecto.
 
\end_layout

\begin_layout Standard
El Software Bookshelf se accede por medio de un conjunto de páginas Web.
 Hay una página para cada uno de los subsistemas que componen el sistema
 evaluado.
 Cada una de estas páginas son a veces llamadas estantes (
\emph on
shelves
\emph default
).
 Las mismas están organizadas de manera jerárquica, lo que refleja la descomposi
ción del sistema en subsistemas.
 A su vez cada página esta vinculada a las páginas de los subsistemas y
 muestran un diagrama de arquitectura llamado "paisaje" de su subsistema,
 y que esta vinculado al código fuente y a la documentación de los subsistemas.
 La figura 
\begin_inset LatexCommand ref
reference "fig:PBS-Example."

\end_inset

 muestra un "paisaje" de un sistema ejemplo 
\begin_inset LatexCommand cite
key "PBS_web"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/PBS_Example.png
	width 70text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:PBS-Example."

\end_inset

Ejemplo de PBS analizando el compilador c488.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
PBS esta compuesto por una serie de herramientas que ayudan en la construcción
 de 
\emph on
"Bookshelves"
\emph default
:
\end_layout

\begin_layout Standard
Extractores: Los extractores parsean el código fuente y generan lo hechos
 co\SpecialChar \-
rres\SpecialChar \-
pon\SpecialChar \-
dien\SpecialChar \-
tes.
 Los hechos facilitan la construcción del grafo de dependencias.
 Existen extractores para algunos lenguajes como c y pascal.
\end_layout

\begin_layout Standard
Manipuladores de hechos: Los hechos producidos por los extractores (o por
 alguna otra fuente, incluida la preparación manual) son efectivamente una
 base de datos, la cual puede ser manipulada.
 Una herramienta llamada Grok opera sobre hechos escritos en RSF y es usado
 para leer los hechos y crear los hechos (sub grafos) para cada subsistema.
 
\end_layout

\begin_layout Standard
Diseñador de diagramas: Los grafos tienen atributos que determinan el "
\emph on
layout
\emph default
" del mismo.
 Estos dan la posición, tamaño y colores de los grafos para poder dibujarlos
 como diagramas.
 La herramienta llamada Layouter lee los hechos que representan el grafo
 y les agrega atributos de layout.
\end_layout

\begin_layout Standard
Visualizador de diagramas: Hay una herramienta llamada LS (Landscape) Viewer
 que lee grafos con sus atributos de layout y lo muestra como un diagrama
 en la pantalla.
\end_layout

\begin_layout Standard
Cada vez que el sistema es compilado (
\emph on
build
\emph default
), hechos relevantes (como llamadas a pro\SpecialChar \-
ce\SpecialChar \-
di\SpecialChar \-
mien\SpecialChar \-
tos y referencias a datos)
 son extraídas de éste.
 Mediante la comparación con los hechos anteriores con los nuevos, se detectan
 nuevos archivos, llamados "huerfanos".
 Un algoritmo los asigna automáticamente a un subsistema y también provee
 de información de layout para la actualización de los diagramas.
\end_layout

\begin_layout Paragraph
Rigi
\end_layout

\begin_layout Standard
Rigi es una herramienta visual e interactiva diseñada para ayudarle a comprender
 mejor y re-documentar un sistema de software
\begin_inset LatexCommand cite
key "RIGI2002"

\end_inset

.
 En Rigi, los artefactos están almacenados en un repositorio subyacente
 y manipulados a través de de una herramienta llamada 
\emph on
rigiedit
\emph default
, que provee la edición, la manipulación y capacidades de exploración.
 Rigi también incluye parsers que extraen los artefactos del sistema de
 software.
 Un modelo de dominio especifica los tipos de entidad y las relaciones de
 interés.
 El flujo de entrada alimenta 
\emph on
rigiedit
\emph default
 el cual representa visualmente el gráfico inicial.
 
\end_layout

\begin_layout Standard
Para gestionar la complejidad del, 
\emph on
rigiedit
\emph default
 permite seleccionar, filtrar, diseñar y modificar el gráfico para identificar
 los subsistemas pertinentes (automática o manualmente colapsando artefactos
 relacionados en subsistemas).
 Estos subsistemas suelen representar conceptos tales como tipos de datos
 abstractos
\end_layout

\begin_layout Standard
El nuevo gráfico creado es más simple, está organizado jerárquicamente,
 se puede navegar, analizar y presentar utilizando diversos layouts de forma
 automática o guiada por el usuario.
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-Rigi"

\end_inset

 muestra la secuencia de pasos desde que el grafo inicial es armado hasta
 la vista final, con subsistemas colapsados y diagramados jerárquicamente.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/RIGI_sample.png
	width 70text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-Rigi"

\end_inset

Ejemplo Rigi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El principal aporte de esta herramienta son los 
\emph on
parsers
\emph default
 para extraer la información de varios lenguajes en un formato propio, Rigi
 Standard Format (RSF) los cuales han sido usados extensamente por otras
 herramientas de reconstrucción como Dali y SHriMP.
\end_layout

\begin_layout Paragraph
SHriMP
\end_layout

\begin_layout Standard
SHriMP (Simple Hierarchical Multi-Perspective) es un sistema de visualización
 y navegación de la información 
\begin_inset LatexCommand cite
key "Storey2001,Shrimp2002"

\end_inset

.
 SHriMP utiliza grafos anidados para presentar la información que está jerárquic
amente organizada.
 Introduce el concepto de vistas "anidadas-intercambiables" permitiendo
 a los usuarios a explorar múltiples perspectivas de la información en diferente
s niveles de abstracción.
 
\end_layout

\begin_layout Standard
Este enfoque presta especial atencion a la "metáfora" visual utilizada para
 explorar e investigar el código, por ejemplo, utilizando distintos tipos
 de vistas jerárquicas y distintos tipos de zoom (normal, semántico, fish_eye).
 Cuando es usado para reconstrucción, la he\SpecialChar \-
rra\SpecialChar \-
mient\SpecialChar \-
a puede asistir al usuario
 en generar vistas arquitectónicas de alto nivel agrupando manualmente elementos
 en un grafo.
 La herramienta toma como entrada archivos RSF (Rigi Standard Format).
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-SHriMP"

\end_inset

 muestra la herramienta en acción.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/SHriMP_sample.png
	width 70text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-SHriMP"

\end_inset

Ejemplo SHriMP.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Mitre
\end_layout

\begin_layout Standard
ManSart (MITRE Software Architecture Recovery Tool.
 ManSART reconoce ca\SpecialChar \-
rac\SpecialChar \-
te\SpecialChar \-
rís\SpecialChar \-
ti\SpecialChar \-
cas arquitectónicas en el código fuente mediante
 el uso de una librería de "reconocedores".
 Características arquitectónicas se consideran aquellas partes que constituyen
 los estilos arquitectónicos que a su vez definen los principios organizacionale
s que guían a los programadores en el desarrollo de código.
 Ejemplos de estilos arquitectónicos son "
\emph on
task
\emph default
 
\emph on
spawning
\emph default
", pipe 
\emph on
and
\emph default
 
\emph on
filter
\emph default
, tipos abstractos de datos y repositorios.
 (re escribir) ManSART esta construido en base a mecanismos de análisis
 de código fuente.
 El proceso de reconstrucción pasa secuencialmente por tres etapas: reconocimien
to, manipulación y presentación.
 Al comenzar el análisis se genera un conjunto de vistas iniciales del sistema.
 Después de parsear el código llevándolo a una representación árbol de análisis
 sintáctico (AST), los "reconocedores" detectan las características arquitectóni
cas llevándolas a vistas que corresponden a varios estilos arquitectónicos.
 Estos reconocedores usan tres niveles de representación: AST, reconocimiento
 de características y reconocimiento de estilos arquitectónicos.
 El primero se usa como base de los demás.
 El segundo, se basa en un conjunto de patrones que emplean modelos específicos
 del lenguaje y del sistema operativo para reconocer porciones de código
 que forman partes de implementaciones de estilos arquitectónicos.
 Este nivel de reconocimiento se hace sobre AST y abstracciones de los flujos
 de datos y de control.
 Por ultimo, el nivel de reconocimiento de estilos arquitectónicos agrupa
 aquellas características reconocidas en el nivel anterior para reconocer
 un estilo arquitectónico.
 La herramienta tiene una poderosa interfaz gráfica que permite la edición
 y manipulación manual de las vistas generadas.
\end_layout

\begin_layout Paragraph
ARM (
\emph on
Architecture Reconstruction Method
\emph default
) - Dali 
\end_layout

\begin_layout Standard
ARM es un método de re\SpecialChar \-
cons\SpecialChar \-
truc\SpecialChar \-
ción de arquitecturas semi-automático el cual
 puede ser usado para asistir en la recuperación de arquitecturas para sistemas
 que son diseñados e implementados usando patrones 
\begin_inset LatexCommand cite
key "GUO99"

\end_inset

.
 ARM consiste de cuatro fases principales: 
\end_layout

\begin_layout Enumerate
Desarrollo de un plan para reconocer patrones concretos, 
\end_layout

\begin_layout Enumerate
extracción de un modelo a partir del código fuente, 
\end_layout

\begin_layout Enumerate
detección y evaluación de instancias de patrones y 
\end_layout

\begin_layout Enumerate
reconstrucción y análisis de la arquitectura.
 
\end_layout

\begin_layout Standard
El mecanismo es simple, reglas que definen patrones son transformadas en
 consultas que serán aplicadas automáticamente para detectar instancias
 de dichos patrones en el modelo.
 Refinando dichas consultas de patrones se puede mejorar la precisión en
 la detección de patrones.
\end_layout

\begin_layout Standard
Dali es la herramienta desarrollada para ejercitar el método descripto anteriorm
ente.
 Es una colección de he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
tas en la forma de workbench.
 Entre estas he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
tas se destacan Rigi y PostgreSQL como repositorio
 de la aplicación.
 Rigi provee la manipulación y vi\SpecialChar \-
sua\SpecialChar \-
li\SpecialChar \-
za\SpecialChar \-
ción de las vistas generadas y la
 extensión que aporta Dali a Rigi provee la habilidad de definir y aplicar
 patrones de consultas sobre los datos para generar vistas arquitectónicas
 del sistema.
 La información es extraída del código fuente utilizando una he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
ta
 de análisis y luego cargadas en Dali.
 Esta información es almacenada en la base de datos PostgreSQL y visualizada
 en Rigi.
 Las consultas son escritas en combinación de SQL y Perl con el propósito
 de generar abstracciones de la información.
 
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Arquitectura Dali"

\end_inset

 muestra como es la arquitectura de Dali.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/dali workbech.PNG
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Arquitectura Dali"

\end_inset

Arquitectura Dali
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Riva 
\end_layout

\begin_layout Standard
Claudio Riva y Yang Yaojin desarrollaron un proceso de reconstrucción de
 arquitecturas y apoyado por varias herramientas y lenguajes (Rigi, scripts
 Perl, Prolog).
 El proceso consta de cuatro pasos, que se aplican iterativamente con el
 fin de extraer vistas cada vez más centradas en la arquitectura de un sistema.
 Los cuatro pasos son: 
\end_layout

\begin_layout Standard
1.
 Definición de conceptos importantes de arquitectura basándose en la documentaci
ón y en el conocimiento de los desarrolladores.
 
\end_layout

\begin_layout Standard
2.
 Recopilación de datos, en la que un modelo del sistema es construido en
 términos de los conceptos definidos en el paso 1.
 
\end_layout

\begin_layout Standard
3.
 Abstracción, en la que el modelo es enriquecido con abstracciones (especificas
 del dominio) que conducen a una vista de mas alto nivel del sistema.
\end_layout

\begin_layout Standard
4.
 Presentación de la arquitectura reconstruida en varios formatos, como gráficos,
 diagramas UML, y gráficos de secuencia de mensajes, teniendo en cuenta
 la vista arquitectónica necesaria (lógica, de procesos, física, de desarrollo).
 La extracción del modelo desde el código fuente es apoyado por analizadores
 de código fuente.
 Las abstracciones se calculan utilizando reglas Prolog.
 La presentación de los resultados se realiza a través de Rigi 
\begin_inset LatexCommand cite
key "Riva2000"

\end_inset

.
\end_layout

\begin_layout Paragraph
\begin_inset LatexCommand label
name "par:DiscoTect"

\end_inset

DiscoTect
\end_layout

\begin_layout Standard
Este enfoque se basa en el mapeo de eventos de bajo nivel del sistema a
 operaciones arquitectónicas abstractas; interpretadas luego por un motor
 especial que ﬁnalmente construye la estructura arquitectónica del sistema
 en tiempo de ejecución como una descripción ACME 
\begin_inset LatexCommand cite
key "ACME"

\end_inset

.
 La idea principal de este trabajo es traducir estilos de implementación
 a estilos arquitectónicos.
 La traducción se deﬁne conceptualmente como una red de Petri coloreada
 
\begin_inset LatexCommand cite
key "JENSON94"

\end_inset

, empleada durante la ejecución para interpretar los eventos de bajo nivel
 y traducirlos cuando corresponda a eventos arquitectónicos, como por ejemplo:
 creación de componentes, establecimiento de conexiones entre ellos, etc.
 Los eventos de bajo nivel son instrucciones Java ejecutadas sobre una máquina
 virtual y se obtienen instrumentando el programa mediante AspectJ 
\begin_inset LatexCommand cite
key "AOP01"

\end_inset

.
 La arquitectura de la herramienta DiscoTect puede observarse en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Arquitectura-DiscoTect"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/discotectArch.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Arquitectura-DiscoTect"

\end_inset

Arquitectura de la herramienta DiscoTect
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La red de Petri coloreada se obtiene como resultado de la compilación de
 una especiﬁcación escrita en un lenguaje especial llamado DiscoStep.
 DiscoStep fue diseñado para traducir la ejecución de instrucciones Java
 a eventos arquitectonicamente signiﬁcativos, considerando que la aridad
 de esta relación entre ambos tipos es n-m y que normalmente los eventos
 de alto nivel pueden ocurrir simultáneamente cuando el sistema bajo análisis
 posee varios procesos o hilos de ejecución concurrentes.
 Para que esta especiﬁcación sea efectiva, el programador debe seguir estrictame
nte los estilos de implementación que permitirán construir correctamente
 la red de Petri coloreada.
 Por ejemplo, si el sistema respeta el estilo arquitectónico cliente-servidor
 
\begin_inset LatexCommand cite
key "BUSCHMANN96"

\end_inset

, el programador deberá codiﬁcar las clases Java signiﬁcativas para este
 estilo como “cliente”, “servidor” y “conexión cliente-servidor” con alguna
 convención que ayude a la red de Petri a detectar estos eventos.
 Si la especiﬁcación DiscoStep espera que el servidor sea representado por
 un 
\emph on
socket
\emph default
 TCP con el suﬁjo “ServerSocket”, el programador deberá seguir este estándar
 para que el mecanismo sea efectivo.
 Los autores de esta herramienta aseguran bajo la condición de que las implement
aciones respeten siempre los mismos estilos, que DiscoTect puede monitorear
 diferentes sistemas sin que sea necesario modiﬁcar la especiﬁcación del
 mapeo entre eventos de bajo nivel y eventos de alto nivel, es decir, sin
 cambiar el código DiscoStep.
 Aunque este enfoque es interesante para visualizar la evolución de una
 arquitectura durante la ejecución de su implementación, es importante hacer
 notar que esta evolución se representa en términos estructurales de la
 arquitectura, en otras palabras, como los componentes y sus conectores
 se reconﬁguran entre si de acuerdo a las distintas situaciones que pueden
 ocurrir en el sistema.
 Los autores de DiscoTect han reportado dos casos de estudio de sistemas
 legados, en los que recuperaron tanto un estilo 
\emph on
pipe-and-ﬁlter
\emph default
 como uno cliente-servidor.
 La herramienta todavía necesita ser evaluada con estilos arquitectónicos
 más complejos, donde los mapeos a código no son necesariamente directos.
 
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-DiscoTect"

\end_inset

 muestra un ejemplo de arquitectura recuperada con DiscoTect.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/discotectExample.PNG
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-DiscoTect"

\end_inset

Ejemplo DiscoTect
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Focus
\end_layout

\begin_layout Standard
Focus 
\begin_inset LatexCommand cite
key "MEDVIDOVIC06"

\end_inset

 propone un enfoque en el cual su objetivo es extraer una descripción estructura
l de la arquitectura en función de la información provista por su implementación
 y el desarrollador.
 El código fuente de una aplicación es analizado estáticamente para obtener
 un diagrama de clases UML y luego las clases interrelacionadas son agrupadas
 en componentes.
 Los mapeos deﬁnen a los componentes como un grupo de clases relacionadas.
 El proceso de 
\emph on
clustering
\emph default
 para determinar los componentes utiliza di\SpecialChar \-
fe\SpecialChar \-
ren\SpecialChar \-
tes políticas, principalmente
 basadas en las relaciones de dependencia entre clases Java.
 Los casos de uso son especiﬁcados por el arquitecto y luego chequeados
 parcialmente en base a la inspección de código fuente.
 Como desventajas, se puede mencionar la escasa automatización (por ejemplo,
 las abstracciones deben ser realizadas por el usuario) y nuevamente, la
 falta de soporte para aspectos comportamentales de la arquitectura como
 es el caso de las representaciones UCM.
\end_layout

\begin_layout Standard
Focus
\begin_inset LatexCommand cite
key "MEDVIDOVIC06"

\end_inset

 es el fruto de un enfoque basado en ingeniería reversa.
 Su objetivo es extraer una descripción estructural de la arquitectura en
 función de la información provista por su implementación y el desarrollador.
 El código fuente de una aplicación es analizado estáticamente para obtener
 un diagrama de clases UML y luego las clases interrelacionadas son agrupadas
 en componentes.
 Este enfoque mantiene los mapeos entre arquitectura e implementación durante
 la evolución aplicando el proceso de descubrimiento incrementalmente sobre
 las porciones de código fuente modiﬁcadas.
 Los mapeos deﬁnen a los componentes como un grupo de clases relacionadas.
 El proceso de 
\emph on
clustering
\emph default
 para determinar los componentes utiliza di\SpecialChar \-
fe\SpecialChar \-
ren\SpecialChar \-
tes políticas, principalmente
 basadas en las relaciones de dependencia entre clases Java.
 Los casos de uso son especiﬁcados por el arquitecto y luego chequeados
 parcialmente en base a la inspección de código fuente.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Ejemplofocus"

\end_inset

 ilustra las principales actividades ordenadas parcialmente realizadas por
 Focus para recuperar una arquitectura.
 El enfoque es interesante para propagar cambios desde la implementación
 hacia la arquitectura.
 La virtud principal radica en reﬁnar progresivamente la vista arquitectónica
 en función de los cambios sucesivos del código, en lugar de intentar recuperarl
a íntegramente con un único análisis exhaustivo.
 Como desventajas, se puede mencionar la escasa automatización (por ejemplo,
 las abstracciones deben ser realizadas por el usuario) y nuevamente, la
 falta de soporte para aspectos comportamentales de la arquitectura como
 es el caso de las representaciones UCM.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ejemplo_Focus.png
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplofocus"

\end_inset

Actividades principales del proceso de recuperación de arquitecturas de
 Focus
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
KLOCwork’s Architecture Excavation method (KAE)
\end_layout

\begin_layout Standard
KAE es un enfoque que aborda la especiﬁcación UCM y emplea mecanismos de
 ingeniería reversa (Amyot et.
 al.
 
\begin_inset LatexCommand cite
key "AMYOT-SAM02"

\end_inset

), extrae escenarios UCM a partir del análisis estático de código C++.
 Su ﬁnalidad es ayudar al nuevo desarrollador a comprender la arquitectura
 “escondida” detrás de una implementación preexistente.
 
\end_layout

\begin_layout Standard
KAE utiliza una técnica híbrida basada en entrevistas (
\emph on
interviews
\emph default
) y etiquetado (
\emph on
tagging
\emph default
).
 Las entrevistas permiten obtener escenarios iniciales en base a charlas
 con de\SpecialChar \-
sa\SpecialChar \-
rro\SpecialChar \-
lla\SpecialChar \-
do\SpecialChar \-
res involucrados y también mediante la inspección del código,
 por esta razón, esta técnica es completamente manual.
 El etiquetado, también de carácter manual, es un proceso donde el desarrollador
 asocia etiquetas semánticas a diferentes porciones del código fuente; más
 tarde estas etiquetas representarán responsabilidades de distintos componentes
 de la arquitectura.
 KAE aproxima los casos de uso iniciales, en forma de trayectorias a través
 de las diferentes etiquetas colocadas en el código fuente.
 
\end_layout

\begin_layout Standard
La herramienta ofrece un compilador para generar un modelo estructural rudimenta
rio de la arquitectura.
 Este modelo será transformado i\SpecialChar \-
te\SpecialChar \-
ra\SpecialChar \-
ti\SpecialChar \-
va\SpecialChar \-
men\SpecialChar \-
te para incrementar el nivel
 de abstracción y para eliminar cualquier dependencia intercomponente accidental.
 La estructura estática de la arquitectura es representada por medio de
 diagramas de paquete UML: los paquetes simbolizan componentes y las dependencia
s entre ellos, sus conexiones.
 Las conexiones entre componentes se detectan analizando las dependencias
 entre clases C++ pertenecientes a diferentes paquetes.
 La abs\SpecialChar \-
trac\SpecialChar \-
ción sub\SpecialChar \-
si\SpecialChar \-
guien\SpecialChar \-
te del modelo queda a cargo del usuario, quien
 tiene a su disposición para este propósito, dos operaciones: agregación
 y ajuste.
 La agregación permite seleccionar distintos bloques y agruparlos creando
 un nuevo nivel en la jerarquía.
 
\end_layout

\begin_layout Standard
El ajuste es otra operación visual donde se mueven bloques para eliminar
 dependencias entre paquetes de niveles mas altos que fueron introducidos
 por emplazamientos accidentales de funcionalidad a nivel de archivo.
 Como las etiquetas se aplicaron antes al código fuente y éste ya ha sido
 abstraído en componentes, la herramienta ahora es capaz de generar Use
 Case Maps como trayectorias a través de las distintas etiquetas colocadas
 en distintos puntos dentro de los paquetes (que ahora son vistos como component
es).
 
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-KAE"

\end_inset

 es un ejemplo de un UCM recuperado con KAE.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/KAEScreenshot.PNG
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-KAE"

\end_inset

Ejemplo KAE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aunque éste es uno de los pocos enfoques que apunta a reconstruir aspectos
 de comportamiento, se realizan demasiadas tareas manuales y otras tantas
 aplicando simpliﬁcaciones gruesas, que introducen errores extra, como es
 el caso de suponer que existe una división de componentes que coincide
 perfectamente con la estructura jerárquica de paquetes del proyecto, o
 crear trayectorias UCM en base al análisis estático del código, cuando
 en realidad la especiﬁcación es inherentemente comportamental.
 Además, es el usuario quien determina en todo momento cuáles son las responsabi
lidades y las trayectorias de los distintos escenarios, limitando considerableme
nte la extracción de información.
\end_layout

\begin_layout Subsubsection
Lattix LDM
\end_layout

\begin_layout Standard
Lattix LDM™ ataca los factores de comunicación, visualización, análisis
 y gestión de las arquitecturas mediante una técnica distinta a las descriptas
 anteriormente.
 Lattix afirma que el manejo de las dependencia entre los módulos es crítico
 para la gestión de proyectos de software.
\end_layout

\begin_layout Standard
Lattix aplica técnicas DSM para llevar a cabo su análisis.
 Dependency Structure Matrix (DSM) es un enfoque para manejar la complejidad
 de un sistema haciendo foco en las interdependencias y los flujos de informació
n dentro y entre los diferentes dominios.
 
\end_layout

\begin_layout Standard
DSM permite a los desarrolladores comunicar la arquitectura de productos
 complejos.
 Es también una herramienta que permite a los managers entender el impacto
 de futuras revisiones y evaluar los riesgos asociados con las tareas de
 desarrollo.
 Lattix LDM realiza un análisis de dependencias a partir de la estructura
 de paquetes del sistema en el caso de java, namespaces en .Net y en la estructur
a del sistema de archivos para el caso de C/C++.
\end_layout

\begin_layout Standard
Esta aplicación esta destinada a ser parte del proceso de desarrollo.
 Ataca el problema de la erosión de la arquitectura, permite mantener actualizad
a la información arquitectónica con respecto a la implementación.
 
\end_layout

\begin_layout Standard
La forma de idealización de la arquitectura utilizando DSM tiene beneficios
 en comparación con otras métodos como UML.
 Por ejemplo, la figura 
\begin_inset LatexCommand ref
reference "fig:Comparación-Ant"

\end_inset

 muestra el modelo UML de Ant, una herramienta para hacer builds de aplicaciones.
 En ella se puede ver el primer problema: la escalabilidad.
 Mientras UML es excelente para mostrar las relaciones entre clases, grandes
 proyectos rápidamente rebalsan este tipo de representaciones gráficas al
 querer re\SpecialChar \-
pre\SpecialChar \-
sen\SpecialChar \-
tar todo el sistema.
 Además es muy difícil mantener este modelo actualizado a medida que el
 código cambia.
 Por último, es imposible detectar referencias cruzadas en este tipo de
 modelos.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/antExample.png
	width 70text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Comparación-Ant"

\end_inset

Comparación UML y DSM: Ant.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Structure 101
\end_layout

\begin_layout Standard
Structure101, desarrollado por Headway Software Technologies, es una herramienta
 versátil de análisis estático de código orientada al análisis de estructura
 (diseño, arquitectura y packaging) del código java, C/C++ y Ada.
 Structure 101 evalúa el código desde varias perspectivas.
 Dispone de una perspectiva cualitativa, en la que mejora el entendimiento
 de la estructura del código.
 Tiene una perspectiva gráfica, en la que se pueden construir diagramas
 la organización y las estructuras referenciadas dentro de un bloque de
 código la figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-Structure-101"

\end_inset

 muestra un ejemplo.
 Cuenta asimismo con una perspectiva cuantitativa en la que evalúa puercamente
 la complejidad del código y de esa manera provee métricas.
 Por ultimo, cuenta con una perspectiva histórica, en la que revela cambios
 en la estructura del código.
 Al igual que Lattix utiliza DSM para visualizar las dependencias.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/structure101_sample.png
	width 65text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-Structure-101"

\end_inset

Ejemplo Structure 101
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Resumen de características principales
\end_layout

\begin_layout Standard
A continuación se muestra una tabla con las principales características
 de los distintos enfoques.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="7">
<features islongtable="true">
<column alignment="center" valignment="top" leftline="true" width="12text%">
<column alignment="center" valignment="middle" leftline="true" width="15text%">
<column alignment="center" valignment="middle" leftline="true" width="10text%">
<column alignment="center" valignment="middle" leftline="true" width="15text%">
<column alignment="center" valignment="middle" leftline="true" width="11text%">
<column alignment="center" valignment="middle" leftline="true" rightline="true" width="15text%">
<column alignment="center" valignment="middle" rightline="true" width="13text%">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\align center

\series bold
Nombre
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Y estructura y comportamiento???
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Motivación
\end_layout

\begin_layout Standard
(Re\SpecialChar \-
cons\SpecialChar \-
truc\SpecialChar \-
ción, Conformance, Comunicación)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\align center

\series bold
Tipo de análisis
\end_layout

\begin_layout Standard
(in\SpecialChar \-
cre\SpecialChar \-
men\SpecialChar \-
tal / no incrementa)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\align center

\series bold
Análisis implementación
\end_layout

\begin_layout Standard
(análisis estático: código fuente; dinámico: trazas de ejecución)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Lenguaje arquitectónico 
\series default
(notación de la arquitectura recuperada)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Soporte para varias fuentes de datos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Estructura / Comportamiento
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
PBS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Carga manual de la información que no sea código.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Rigi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No incremental.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático (dinámico, si se carga la información de trazas en formato RSF)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Si, se cargan manualmente en formato RSF.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SHriMP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No incremental.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No hace análisis es una herramienta de visualización.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
"boxes and lines"
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Si, se cargan los datos en formato RSF.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Mitre
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reconstrucción - Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incre\SpecialChar \-
men\SpecialChar \-
tal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
UML
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Dali
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reconstrucción - Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incre\SpecialChar \-
men\SpecialChar \-
tal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No en forma automática.
 Se tendrían que incorporar los datos a Dali en formato RSF.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Riva
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reconstrucción - Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incre\SpecialChar \-
men\SpecialChar \-
tal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No en forma automática.
 Se tendrían que incorporar los datos a en forma de hechos Prolog.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DiscoTect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reconstrucción-Conformance
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incre\SpecialChar \-
men\SpecialChar \-
tal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
dinámico.
\end_layout

\begin_layout Standard
Traducción eventos de implementación, eventos arquitectónicos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ACME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Focus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Re\SpecialChar \-
cons\SpecialChar \-
truc\SpecialChar \-
ción
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incre\SpecialChar \-
men\SpecialChar \-
tal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático.
 Clustering clases, análisis incremental asistido por el usuario
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
UML
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
KAE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Re\SpecialChar \-
cons\SpecialChar \-
truc\SpecialChar \-
ción
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incre\SpecialChar \-
men\SpecialChar \-
tal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático (información de como se comporta el sistema es realizado mediante
 entrevistas - subjetivo)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
UML-UCM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura / Comportamiento
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Lattix LDM™
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Conformance - Re\SpecialChar \-
cons\SpecialChar \-
truc\SpecialChar \-
ción
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DSM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Structure 101
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Conformance - Re\SpecialChar \-
cons\SpecialChar \-
truc\SpecialChar \-
ción
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
De\SpecialChar \-
pen\SpecialChar \-
den\SpecialChar \-
cy Graphs - DSM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Las propiedades de cada enfoque resumidas en esta sección son las siguientes:
\end_layout

\begin_layout Itemize
Motivación: Esta propiedad se refiere al fin que tiene dicha herramienta/enfoque.
 Si apunta a solucionar los problemas de erosión arquitectónica o a la reconstru
cción de la arquitectura y a su comunicación.
\end_layout

\begin_layout Itemize
Tipo de análisis: Tipo de análisis se refiere si el análisis que realiza
 la herramienta es incremental, elevando cada vez mas el nivel de detalle
 o abstracción.
 O es no incremental y el análisis se realiza de una sola vez.
\end_layout

\begin_layout Itemize
Tipo de Análisis de la implementación (Estático/Dinámico): Si se consideran
 para el análisis el código fuente, ya sea código fuente o código compilado,
 el tipo de análisis es estático.
 Si por el contrario se consideran las trazas de ejecución, recolectadas
 con el sistema en ejecución, el análisis es dinámico.
 Como se ve, esta característica está fuertemente relacionada con el tipo
 de entrada que la herramienta/enfoque considera.
\end_layout

\begin_layout Itemize
Lenguaje arquitectónico: Hace referencia al lenguaje arquitectónico de las
 vistas ge\SpecialChar \-
ne\SpecialChar \-
ra\SpecialChar \-
das.
 Ejemplos son UML, UCMs, DSM etc.
\end_layout

\begin_layout Itemize
Soporte para varias fuentes de datos: Indica si es posible incorporar datos
 de otras fuentes como documentación, experiencia de los arquitectos etc.
\end_layout

\begin_layout Itemize
Estructura / Comportamiento: Esta propiedad refleja el aspecto de la arquitectur
a recuperada.
 Si apunta a recuperar aspectos estructurales (estructura de los módulos
 y sus dependencias) o comportamentales (interoperabilidad de los módulos
 bajo ciertos escenarios de ejecución).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
X Análisis de la categorización??
\end_layout

\end_inset


\end_layout

\begin_layout Section
Análisis y Conclusiones 
\end_layout

\begin_layout Standard
En este capítulo se han presentado los trabajos relacionados más importantes
 que tratan la reconstrucción de arquitecturas.
\end_layout

\begin_layout Standard
Como vimos, la mayoría de los enfoques actuales de reconstrucción de arquitectur
as se basan en el análisis del código fuente del sistema.
 Este tipo de técnicas trabajan adecuadamente si la implementación del sistema
 se encuentra organizada en patrones tanto de co\SpecialChar \-
di\SpecialChar \-
fi\SpecialChar \-
ca\SpecialChar \-
ción como de modularizació
n.
 Sin embargo, estas técnicas se ven limitadas cuando las estructuras del
 sistema son conocidas en tiempo de ejecución.
 Es decir, cuando la determinación del componente responsable de un aspecto
 en particular es realizada en tiempo de ejecución (por ejemplo, clases
 cargadas dinámicamente en los sistemas orientados a objetos).
 En efecto, determinar la configuración arquitectónica real de un sistema
 usando análisis estático es, en general, indecidible.
 Por ejemplo suponer que existe una división de componentes que coincide
 perfectamente con la estructura jerárquica de paquetes de proyectos es
 ge\SpecialChar \-
ne\SpecialChar \-
rar una simplificación muy gruesa, que introduce errores extra.
 Lo mismo ocurre al basar el 
\emph on
clustering
\emph default
 en relaciones de dependencia entre clases.
 Si bien son enfoques correctos no son determinantes en la reconstrucción
 total y es necesario refinar y complementar con otras técnicas.
\end_layout

\begin_layout Standard
Además, ninguno de estos enfoques ha considerado las extracciones de 
\emph on
paths
\emph default
 de ejecución para generar diagramas tales como los UCMs, solo KAE genera
 este tipo de diagramas pero con particularidad de hacerlo a partir de un
 análisis estructural cuando la representación es inherentemente comportamental.
 DiscoTech utiliza información dinámica, pero genera vistas estructurales
 de la arquitectura.
 
\end_layout

\begin_layout Standard
Un aspecto débil, ya no de los enfoques sino de las aplicaciones que los
 implementan, es que muy pocas tienen incorporadas las herramientas de extracció
n de información.
 Otro aspecto a destacar que está fuertemente relacionado con el anterior
 es que demasiadas tareas se hacen de forma manual.
 Ya sea el parseo del código fuente, como la instrumentación de dicho código
 son tareas manuales o bien realizadas por otras aplicaciones cuyos resultados
 hay que agregarlos manualmente a la herramienta de análisis.
 Sería deseable que solamente la información que debe ser interpretada por
 el ojo experto sea incorporada manualmente.
\end_layout

\begin_layout Standard
Cabe destacar varias características interesantes de los enfoques analizados
 que determinaron algunos de los objetivos y características deseables al
 plantear el desarrollo del enfoque 
\emph on
DRArch
\emph default
.
 El enfoque Botton-Up y Top-Down propuesto en Mitre es interesante desde
 el punto de vista de la flexibilidad del análisis al poder seguir cualquiera
 de las dos estrategias.
 El uso de programación lógica para realizar las inferencias es mucho mas
 atractivo e intuitivo que utilizar, como lo hace Dali, una combinación
 de SQL y Perl para la inferencia y la generación de nuevos hechos.
 El uso de programación lógica se enfoca en "qué" recuperar y no "cómo"
 hacerlo.
 Utilizar convenciones de nombres es una alternativa interesante siempre
 y cuando no sea "la única alternativa" (DiscoTect).
 Es decir que el análisis no se base en convenciones sino que aproveche
 sus beneficios ya que es una herramienta poderosa que incorpora en la fase
 de extracción, el conocimiento del arquitecto sobre el código implementado.
 Por último el método propuesto por el SEI, ARM es un mecanismo simple que
 sienta las bases del análisis y permite refinar y aumentar la precisión
 de los elementos recuperados.
\end_layout

\begin_layout Standard
Resumiendo, la gran mayoría de los enfoques apuntan a aspectos estructurales
 y el uso de análisis estático para cumplir con este objetivo.
 Cabe destacar la falta del modelado de aspectos comportamentales y el uso
 de notación arquitectónica para describir la arquitectura recuperada.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Falta una vuelta de rosca al ultimo párrafo.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
X Es decir, alguno considera comportamiento??
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:El-enfoque-DRArch"

\end_inset

Enfoque 
\emph on
DRArch
\end_layout

\begin_layout Standard
En este capítulo se presenta el enfoque 
\emph on
DRArch
\emph default
, que propone una he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
ta de soporte para la reconstrucción de arquitecturas
 de software, usando para ello información estática (código fuente) y dinámica
 (
\emph on
logs
\emph default
 de ejecución) para lograr una representación arquitectónica por medio de
 diagramas de componentes y de UCMs.
\end_layout

\begin_layout Standard
El objetivo principal de 
\emph on
DRArch
\emph default
 es asistir al desarrollador realizando un análisis de la información relevante
 que se pueda recolectar de un sistema y generando como salida una representació
n arquitectónica.
 Como bien se detalló en el capítulo anterior, existen varios enfoques basados
 en reconstrucción de arquitecturas para tratar el problema que causa la
 falta de documentación arquitectónica.
 Si bien estos enfoques no se centran en la reconstrucción de arquitecturas
 que muestren aspectos comportamentales del sistema, su análisis permitió
 detectar ciertos aspectos que colaboran con el enfoque 
\emph on
DRArch
\emph default
 con mecanismos para generar diagramas de UCMs.
\end_layout

\begin_layout Standard
Otro aspecto importante es que se tenga en cuenta durante el proceso de
 reconstrucción de la arquitectura la información que aporten aquellas personas
 que tengan conocimientos sobre el sistema.
 Por lo general, esta información es la mas difícil de incorporar ya que
 por lo general depende de la naturaleza de cada sistema.
 Por ejemplo, un desarrollador sabe que existe una convención en donde todas
 las clases que tengan en su nombre el sufijo 
\emph on
Task
\emph default
, representan tareas del sistema, y se desea que ese conocimiento se incorpore
 en el proceso de reconstrucción.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
No es necesario poner un TOC en cada inicio de capitulo, ni en cada seccion
 grande, ...
 porque la lectura se hace pesada y reiterativa ...
 Please, eliminen este tipo de parrafos "indices" en otros lados de la tesis
 tambien ...
 A lo sumo, se puede justificar un parrafo que recapitule lo presentado
 en el informe en el capitulo de Conclusiones.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Análisis"

\end_inset

Modelo Concemptual
\end_layout

\begin_layout Standard
El enfoque permite recuperar arquitecturas de sistemas de software mostrando
 aspectos estructurales y comportamentales.
 Basandose en el esquema de recolectar-abstraer-presentar, el proceso de
 reconstrucción consiste en recolectar información de distintas fuentes.
 Por ejemplo, los principales artefactos que se tienen en cuenta son: código
 fuente, logs de ejecución, experiencia de los expertos del sistema, etc.
 Esta información se consolida en una representación común llamada base
 del conocimiento.
 Luego, por medio de un mecanismo de reglas, se analiza la información disponibl
e para generar sugerencias al usuario sobre el modelo arquitectónico a reconstru
ir.
 Las sugerencias son afirmaciones que el arquitecto debe aceptar o rechazar.
 Si una suegerencia es aceptada, se realiza una transformación en el modelo.
 Así es como el modelo se va construyendo y en cada paso se transforma en
 diagramas de componentes y de UCMs que representan aspectos estructurales
 y comportamentales del sistema en un alto nivel de abstracción.
 Los UCMs pueden mostrar escenarios de comportamiento, es decir, escenarios
 basados en los requerimientos del sistema en donde se describen los resultados
 esperados de cada componente de la arquitectura.
 Este proceso se repite con el fin de ir refinando de forma incremental
 el modelo arquitectónico.
 De esta manera, el proceso de recuperación será una tarea donde el enfoque
 sugerirá un conjunto de transformaciones arquitectónicas y el arquitecto
 del sistema analizará y decidirá cuáles de estas transformaciones es la
 más adecuada.
\end_layout

\begin_layout Standard
La descripción del proceso define seis partes principales del enfoque: el
 análisis estático, análisis dinámico, un modelo de reglas, la identificación
 de estructuras arquitectónicas, el manejo de las alternativas arquitectónicas
 y la generación de vistas.
 La Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Proceso-DRArch"

\end_inset

 muestra como funciona el proceso 
\emph on
DRArch
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Que la terminologia que usen/introduzcan sea consistente con lo que se usa
 en las figuras (ej.
 FIgura 4.1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El enfoque se basa en la utilización de heurísticas para la detección de
 componentes arquitectónicos y patrones de diseño en aplicaciones orientadas
 a objetos.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ProcesoDrarchActivityDiagram.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Proceso-DRArch"

\end_inset

Proceso 
\emph on
DRArch
\emph default
 
\emph on

\begin_inset Note Note
status collapsed

\begin_layout Standard

\emph on
DRArch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las iteraciones están representadas por las fases, las cuales realizan actualiza
ciones al modelo arquitectónico.
 De esta forma, el punto de comienzo de este proceso es la ejecución de
 la fase de recolección de información.
 A partir del código fuente recuperamos la información estática y mediante
 el análisis del sistema en ejecución extraemos la información dinámica
 que complementa el análisis estático.
 Tanto la información estática como la dinámica (recolectadas en las primeras
 fases) son utilizadas por el resto de las fases ya que es considerada como
 información base.
 
\end_layout

\begin_layout Standard
Luego de la fase de recolección de información empiezan las fases de especializa
ción, las cuales van iterativa e incrementalmente modificando el modelo
 arquitectónico elevando en cada fase el nivel de abstracción y detalle.
 En estas fases, la herramienta sugiere un conjunto de modificaciones a
 la descripción del modelo arquitectónico.
 Estas modificaciones representan cambios a diferentes partes de la representaci
ón actual del sistema que pueden involucrar tanto modificaciones de estructura
 como de comportamiento.
 A partir de estas sugerencias, el arquitecto decide cuál de estas modificacione
s representan fielmente los conceptos arquitectónicos que se está intentando
 reconstruir como así también descartar todas las sugerencias porque no
 aportan información relevante al análisis.
 Adicionalmente, el arquitecto puede refinar la especificación representada
 por los diferentes diagramas aumentando el nivel de detalle, incorporando
 modificaciones o elementos que pueden aportar mayor nivel de detalle en
 sucesivas fases que utilizan el modelo transformado por la fase en curso.
\end_layout

\begin_layout Standard
Con el objetivo de poder comprender el enfoque pragmáticamente, en la siguiente
 sub-sección se presenta un ejemplo simple de una pieza de un sistema, en
 donde se utiliza el patrón de diseño 
\emph on
Observer-Observable
\emph default
.
 
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sec:Ejemplo:-Observer-Observable"

\end_inset

Ejemplo: Observer-Observable
\end_layout

\begin_layout Standard
Una vista importante en 
\emph on
DRArch
\emph default
 es la de UCMs que muestra comportamiento.
 Retomando el ejemplo de Sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sub:Ejemplo-UCM"

\end_inset

, se puede observar cómo se comporta la aplicación y cómo se instancia el
 patrón de diseño 
\emph on
Observer-Observable
\emph default
.
\end_layout

\begin_layout Standard
El patrón 
\emph on
Observer-Observable\InsetSpace ~

\emph default

\begin_inset LatexCommand cite
key "gamma93design"

\end_inset

 se aplica en el contexto de aplicaciones interactivas que demandan un alto
 grado de interacción con el usuario.
 El principal objetivo es desacoplar la vista de los datos.
 En el estilo 
\emph on
Observer-Observable
\emph default
 puro, normalmente el 
\emph on
Observable
\emph default
 representa los datos a ser mostrados, y el 
\emph on
Observer
\emph default
 (la vista) es responsable de reflejarlos visualmente al usuario.
\end_layout

\begin_layout Standard
Como primer paso, el arquitecto debe definir qué reglas se van a incluir
 en la fase que se quiere ejecutar.
 Cada fase debería tener un objetivo claro, por ejemplo, una fase podría
 enfocarse en descubrir si existen implementaciones del patrón 
\emph on
Observer-Observable
\emph default
 o de algún otro patrón de diseño.
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Análisis-de-información"

\end_inset

Análisis de información de artefactos de código fuente
\end_layout

\begin_layout Standard
Se debe realizar un análisis de los artefactos relacionados con el código
 fuente para poder capturar los aspectos estructurales del sistema.
 Dicho análisis requiere que el código fuente esté disponible.
 Con el objetivo de poder manipular la información estática, el código fuente
 es representado por medio de un lenguaje de programación lógico al estilo
 
\emph on
Prolog
\emph default
 llamado TyRuBa\InsetSpace ~

\begin_inset LatexCommand cite
key "Volder1998"

\end_inset

.
 TyRuBa es un motor lógico de inferencia que a diferencia del paradigma
 de programación lógica tradicional, éste fue diseñado para representar
 código Java siendo un lenguaje más declarativo.
 El lenguaje de programación 
\emph on
ProLog
\emph default
 está basado en la lógica de predicados.
 Los lenguajes de programación tipo 
\emph on
Prolog
\emph default
 son declarativos (no opracional como programación orientada a objetos),
 permiten hacer inferencias y soportan prototipación de ideas.
 De esta forma, se representan artefactos del código fuente (clases, variables,
 paquetes, etc.) sobre una base de conocimiento.
 Por ejemplo, una la clase 
\family typewriter
UserModel
\family default
 que contiene un método 
\family typewriter
setName
\family default
 se representa con con los siguientes hechos: 
\end_layout

\begin_layout Itemize

\family typewriter
class(UserModel)
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
method(setName).
\end_layout

\begin_layout Itemize

\family typewriter
hasMethod(UserModel, setName).
\end_layout

\begin_layout Standard
Esto nos permite mantener un contexto en el cuál sea posible encontrar informaci
ón relacionada mediante consultas que aprovechan las capacidades de inferencia
 del paradigma de programación lógica.
 Realizar este tipo de consultas sobre la representación original del código
 fuente (AST: 
\emph on
abstract syntax tree
\emph default
) no es tan intuitivo ya que hasta un simple programa ("Hello World!") genera
 un árbol de búsqueda complejo.
 Realizar una consulta que recorra el árbol para relacionar distintos artefactos
 de código fuente puede resultar engorroso.
\end_layout

\begin_layout Standard
Esta transformación de código Java a hechos (o representacion) 
\emph on
Prolog
\emph default
 es realizada al comienzo del proceso de reconstrucción por medio de un
 parser que recorre el AST de cada archivo fuente.
 Una vez que el código fuente esta representado en forma de hechos, es posible
 realizar consultas para obtener información deseada.
 La flexibilidad de este enfoque permite explorar un gran abanico
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
No me den el pantallazo general, prefiero que me cuenten de "un abanico
 (mas chico)" de relaciones especificas y consultas especificas ...
 Y luego digan.
 "los tipos de relaciones y consultas se pueden extender en el futuro" o
 algo asi ...
\end_layout

\end_inset

 de relaciones y consultas diferentes.
 Con la siguiente consulta, se obtienen todos los metodos 
\emph on
getters
\emph default
 del sistema:
\end_layout

\begin_layout Standard
\align center

\family typewriter
class(?C), method(?C,?M), re_name(?M,/^get/), modifier(?M,public).
\end_layout

\begin_layout Standard
Para reducir el espacio de búsqueda y poder organizar el resultado en paquetes,
 la consulta queda de la siguiente forma:
\end_layout

\begin_layout Standard
\align center

\family typewriter
class(?C), method(?C,?M), re_name(?M,/^get/), modifier(?M,public), package(?P),
 child(?P, ?C).
\end_layout

\begin_layout Standard
Los tipos de relaciones y consultas se pueden extender en el futuro para
 combinarlos con la infrmación dinámica del sistema y con la información
 arquitectónica reconstruída.
 Es decir, en vez de relacionar los 
\emph on
getters 
\emph default
con paquetes, es posible relacionarlos con componentes arquitectónicos.
\end_layout

\begin_layout Standard
Por ejemplo, si se considera un escenario en donde un desarrollador quiere
 reutilizar una parte en particular del código de una aplicación porque
 contiene funcionalidad que necesita en otra aplicación que esta desarrollando,
 dicho desarrollador debería realizar una búsqueda por todo el código fuente
 para poder capturar las partes del código que necesita.
 Inspeccionar directamente en el código fuente sería muy tedioso y llevaría
 mucho tiempo, pero si el código fuente esta representado en forma de hechos
 
\emph on
Prolog
\emph default
, sería sencillo realizar algunas consultas para identificar partes del
 código.
 Por otro lado, transformar el código fuente a hechos 
\emph on
Prolog 
\emph default
tiene como contrapartida que cada vez que se modifica el código Java es
 necesario regenerar los hechos.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Comenten tambien la contrapartida de usar Prolog, que son: la consistencia
 de la base de hechos, el que cada vez que toco codigo Java tengo que regenerar
 los hechos, o cualquier otro que se les ocurra ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
El ejemplo esta Ok para aclarar porque el Prolog puede ser ventajoso.
 Sin embargo, el contexto es para "desarrollo con reuso" y no tiene mucho
 que ver con "reconstruccion":-( ...
 Se puede tunear el ejemplo para focalizarlo mas en un caso de reconstruccion???
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Siguiendo con el ejemplo mostrado anteriormente, en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-clases-UML-para-el-ejemplo-Observer-Observable"

\end_inset

 se presenta un diagrama de clases UML en donde una aplicación sencilla
 utiliza el patrón 
\emph on
Observer-Observable
\emph default
 y en Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-componentes"

\end_inset

 se presenta un diagrama con los dos componentes principales de este patrón
 arquitectónico, detallando en cada uno de ellos las responsabilidades asociadas
:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/observerObservableClassDiagram.JPG
	scale 80

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-clases-UML-para-el-ejemplo-Observer-Observable"

\end_inset

Diagrama de clases UML para el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableComponentDiagram.png
	width 90text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-componentes"

\end_inset

Diagrama de componentes para el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description

\emph on
Observable
\emph default
 Representa los datos y la funcionalidad principal de la aplicación.
 Provee un mecanismo para registrar los observadores.
 De este modo, permite la notificación de los cambios sufridos manteniendo
 la independencia del modelo con sus diferentes vistas u otros observers
 (los observers pueden ser parte del modelo, por ejemplo, la notificación
 entre celdas de una planilla de cálculo).
 
\end_layout

\begin_layout Description

\emph on
Observer
\emph default
 Generalmente provee información al usuario de manera visual y obtiene informaci
ón del usuario mediante eventos (por ejemplo, 
\emph on
clicks
\emph default
 o movimientos de 
\emph on
mouse
\emph default
, teclas, etc.).
 Obtiene sus datos del modelo.
\end_layout

\begin_layout Standard
Una instanciación concreta del 
\emph on
Observer-Observable
\emph default
 se muestra en las relaciones entre el componente 
\family typewriter
UserModelObservable
\family default
 y los componentes 
\family typewriter
User\SpecialChar \-
Interface\SpecialChar \-
Observer
\family default
 y 
\family typewriter
User\SpecialChar \-
Logger\SpecialChar \-
Observer
\family default
 en donde denotan que existe un mecanismo de notificación entre estos componente
s.
\end_layout

\begin_layout Standard
Antes de proseguir con el ejemplo 
\emph on
Observer-Observable
\emph default
 es importante introducir el concepto de mapeo entre la documentación arquitectó
nica y su correspondiente implementación.
\end_layout

\begin_layout Standard
Como se explicó en la sección 
\begin_inset LatexCommand ref
reference "sub:Ejemplo-UCM"

\end_inset

, el comportamiento especificado a nivel arquitectónico no muestra los detalles
 de interacción como las llamadas o mensajes entre objetos dentro de un
 componente.
 En el lenguaje UCM, el comportamiento se representa en términos de secuencias
 causa-efecto entre 
\emph on
responsabilidades
\emph default
 de los componentes.
 Las 
\emph on
responsabilidades
\emph default
 pueden ser de mayor gra\SpecialChar \-
nu\SpecialChar \-
la\SpecialChar \-
ri\SpecialChar \-
dad que las llamadas y mensajes para reducir
 el nivel de compromiso con los detalles.
 Por este motivo una 
\emph on
responsabilidad
\emph default
 (función de la que es responsable un componente) puede ser materializada
 por varios métodos e incluso clases de objeto a nivel implementación.
 Por otro lado, una misma clase o un método particular de ésta puede contribuir
 con la materialización de diferentes 
\emph on
responsabilidades
\emph default
.
 En otras palabras, existe una correspondencia de aridad 
\family typewriter
n:m
\family default
 entre una unidad de comportamiento a nivel arquitectónico, como lo es una
 
\emph on
responsabilidad
\emph default
 UCM, y una unidad de comportamiento a nivel implementación, como lo son
 los métodos de una clase.
 Tal relación se denomina mapeo 
\emph on
responsabilidad
\emph default
 - 
\emph on
código
\emph default
.
 El mapeo permite la trazabilidad entre la 
\emph on
res\SpecialChar \-
pon\SpecialChar \-
sa\SpecialChar \-
bi\SpecialChar \-
li\SpecialChar \-
dad
\emph default
 UCM de un componente y su implementación en las distintas clases.
\end_layout

\begin_layout Standard
En la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Mapeos-clase-componente"

\end_inset

 y la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Mapeos-método-responsabilidad"

\end_inset

 se muestra la correspondencia de la documentación arquitectónica del caso
 de referencia y su implementación en Java mediante tales mapeos.
 Si bien en este ejemplo las correspondencias clase-componente y método-responsa
bilidad son directas, es posible especificar casos más complejos.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableMappingClass.jpg
	lyxscale 50
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Mapeos-clase-componente"

\end_inset

Mapeos clase - componente
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableMappingMethod.jpg
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Mapeos-método-responsabilidad"

\end_inset

Mapeos método - responsabilidad
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Algunos hechos 
\emph on
Prolog
\emph default
 del Cuadro\InsetSpace ~

\begin_inset LatexCommand ref
reference "tab:Hechos-Prolog-pare"

\end_inset

 muestran cómo es representada la información mostrada en el ejemplo (clases,
 interfaces, propiedades, mapeos, etc.).
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Puede ir una tabla con las diferentes reglas...
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Las reglas definen un conjunto de hechos 
\emph on
Prolog
\emph default
 que proponen cambios al modelo arquitectónico que se aplican cuando una
 sugerencia es aceptada.
 Dentro de este conjunto se encuentran los hechos que estan relacionados
 con el mapeo del modelo arquitectónico al código fuente.
 Generalmente, la creación de un componente (agregar un hecho como 
\family typewriter
\size small
component(A)
\family default
\size default
) es realizada junto con un mapeo al código (se agrega otro hecho 
\family typewriter
\size small
materialization(A, package, Class)
\family default
\size default
).
 Otra forma de realizar el mapeo es por medio de los diagramas, es decir,
 realizar explícitamente la asociación entre los artefactos arquitectónicos
 y el código fuente utilizando los editores de los diagramas de componentes
 y de UCMs.
 Luego, estos diagramas son sincronizados con el modelo arquitectónico incorpora
ndo la información de mapeo.
\begin_inset Note Note
status collapsed

\begin_layout Standard
Aca faltaria un parrafo o dos que explique la relacion entre estos mappings
 y como ayudan en el proceso del tool.
 Es decir, estos mappings los tiene que proveer el desarrollador "a priori"
 al tool?, el tool tiene reglas ya sobre como hacer los mappings? o como
 es que funciona ...
\end_layout

\begin_layout Standard
[explicar los facts que se agregan luego de ejecutar una regla]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="1">
<features>
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Hechos Prolog (información estática)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
class(UserModel).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
class(UserInterface).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
class(UserLog).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
interface(Observable).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
method(update).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
child(UserModel, update).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
package(drarch.observer).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
package(drarch.observable).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
modifier(UserModel, public).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
returns(update, void).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
field(name).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
child(UserModel, name).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
child(drarch.observer, UserModel).
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
implements(Observable, UserInterface).
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Hechos-Prolog-pare"

\end_inset

Hechos 
\emph on
Prolog
\emph default
 que representan la información estática pare el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Análisis dinámico
\end_layout

\begin_layout Standard
Al igual que la información estática, la información dinámica es representada
 en forma de hechos al estilo 
\emph on
ProLog
\emph default
 y sobre la misma base del conocimiento.
 Para obtener dicha información, primero se debe instrumentar la aplicación
 para poder generar logs de ejecución.
 Luego, es necesario realizar un análisis de los 
\emph on
logs
\emph default
 de ejecución del sistema.
 Los 
\emph on
logs
\emph default
 de ejecución representan las trazas reales de ejecución de la aplicación
 en su estado actual.
 Contienen información de bajo nivel, como llamadas a métodos, threads,
 creaciones de objetos, etc.
\end_layout

\begin_layout Standard
En el ejemplo 
\emph on
Observer-Observable
\emph default
, el flujo de eventos que genera la ejecución de la aplicación queda reflejado
 en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Ejemplo-Observer-Observable-UCM"

\end_inset

 .
 Este caso se produce cuando algún dato del modelo es modificado.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableSample.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-Observer-Observable-UCM"

\end_inset

Ejemplo 
\emph on
Observer-Observable
\emph default
 de UCM
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para generar de los 
\emph on
logs
\emph default
 de ejecución, es necesario instrumentar la aplicación y realizar ejecuciones
 sobre casos de uso que reflejen el comportamiento del sistema.
 En este punto es imprescindible la intervención manual del arquitecto ya
 que es necesario guiar la ejecución de la aplicación.
 Para esto, se interactúa con el sistema de manera que se ejerciten los
 casos de uso en donde los artefactos que se quieren reconstruir tengan
 participación dentro de la ejecución.
\end_layout

\begin_layout Standard
Los mapeos clase-componente y método-responsabilidad que se mostraron en
 la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sub:Análisis-de-información"

\end_inset

 son de gran ayuda para la generación del log ya que se reduce considerablemente
 la cantidad puntos del sistema en dónde se tienen que instrumentar.
 Si este mapeo no existe, es posible instrumentar todo el código fuente
 seleccionado para generar el log.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[nico] En este último caso se debe tener en cuenta que el código seleccionado
 para instrumentar la aplicación y el caso de uso seleccionado para ejercitar
 el sistema podría generar gran cantidad de información...
 [hace falta aclarar esto?]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los hechos generados por el análisis dinámico, se almacenan en la base de
 conocimientos junto con el resto de la información para que las consultas
 que se realicen puedan relacionar tanto información estática como dinámica.
 Adicionalmente, es posible relacionar información del modelo que incrementalmen
te se está generando y la información aportada por experiencia y el conocimiento
 de las personas involucradas en el proceso de reconstrucción.
 De esta manera, al termino de cada fase los diagramas son generados y el
 experto en reconstrucción tiene la posibilidad de agragar, quitar o modificar
 artefactos arquitectónicos directamente sobre los diagramas.
 Luego, las modificaciónes realizadas sobre los diagramas se sincronizan
 con el modelo para continuar con el proceso de reconstrucción.
 Por ejemplo, si alguna de las personas involucradas en el proceso de reconstruc
ción sabe que existe un componente 
\emph on
observer
\emph default
 que no ha sido detectado, este nuevo componente se agrega directamente
 al diagrama.
\end_layout

\begin_layout Standard
En el ejemplo de la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Ejemplo:-Observer-Observable"

\end_inset

, el análisis del log tiene como salida todas las llamadas a métodos formando
 
\emph on
paths
\emph default
 de ejecución así como también un "snapshot" de las propiedades de los objetos
 involucrados en cada llamada a método.
 Algunos hechos generados por el análisis del log se muestran en el Cuadro\InsetSpace ~

\begin_inset LatexCommand ref
reference "tab:Hechos-Prolog-info-dinamica"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="1">
<features>
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Hechos Prolog (información dinámica)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
executedMethod(1, Main.changeDataModel, void, null).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
executedMethod(2, UserModel.setName, void, null).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
executedMethod(3, UserModel.notifyAllObservers, void, null).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
executedMethod(4, UserInterfaceView.update, void, null).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
executedMethod(5, UserLogger.update, void, null).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
snapshot(1, userModel.name, 'aName').
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
snapshot(2, userModel.name, 'aNewName').
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
snapshot(3, userModel.name, 'aNewName').
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
snapshot(4, userModel.name, 'aNewName').
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
snapshot(5, userModel.name, 'aNewName').
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Hechos-Prolog-info-dinamica"

\end_inset

Hechos 
\emph on
Prolog
\emph default
 que representan la infromación dinámica pare el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
En predicado 
\family typewriter
executedMethod
\family default
 el primer argumento es el orden de ejecución, el segundo, el método ejecutado,
 el tercero el tipo de retorno y el cuarto, el valor de retorno.
 Y en el predicado 
\family typewriter
snapshot 
\family default
el primer argumento es el identificador de ejecución, el segundo, la propiedad
 del objeto afectada y el tercero el valor de la propidedad del objeto.
\end_layout

\begin_layout Subsection
Reglas para la identificación de artefactos arquitectónicos
\end_layout

\begin_layout Standard
Las iteraciones están representadas por las fases las cuales realizan actualizac
iones al modelo arquitectónico.
 Cada fase recibe como entrada un 
\emph on
snapshot
\emph default
 del modelo recuperado por fases anteriores, y produce como salida un nuevo
 modelo que es el resultado de aplicar las transformaciones seleccionadas
 por el arquitecto en la fase actual sobre el modelo de entrada.
\end_layout

\begin_layout Standard
La ejecución de cada fase es un proceso interactivo.
 Cada fase contiene un conjunto de reglas, las cuales determinan las transformac
iones al modelo.
 Estas transformaciones permitirán al arquitecto relacionar elementos arquitectó
nicos (ej.: componentes, relaciones entre componentes, etc.) a diferentes
 estructuras de código (ej.: clases, métodos, etc).
 Cada regla consta de tres partes: 
\end_layout

\begin_layout Enumerate
una consulta sobre la base de conocimiento; 
\end_layout

\begin_layout Enumerate
una sugerencia, construida a partir de cada uno de los resultados de la
 consulta;
\end_layout

\begin_layout Enumerate
una serie de hechos (
\emph on
facts
\emph default
), los cuales representan las transformaciones a aplicar sobre la base de
 conocimiento.
\end_layout

\begin_layout Standard
El algoritmo 
\begin_inset LatexCommand ref
reference "alg:Ejemplo de regla"

\end_inset

 muestra un ejemplo concreto de una regla con las 3 partes antes descripta.
 El arquitecto encargado de la reconstrucción es el responsable de la especifica
ción de las reglas.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard

\series bold
Consulta: 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
implements(?Class, ?Interface),
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
name(?Class, ?ClassName),
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
name(?Interface, 'Observer')
\end_layout

\begin_layout Standard

\series bold
Sugerencia:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
"Crear el componente ?ClassName"
\end_layout

\begin_layout Standard

\series bold
Hechos:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
Componente(?ClassName)
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Ejemplo de regla"

\end_inset

Ejemplo de definición de regla.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Especificación de reglas
\end_layout

\begin_layout Standard
El enfoque provee un conjunto de reglas basadas en patrones de diseño y
 en un análisis realizado sobre diversos sistemas.
 El proposito de estas reglas es la codificacion de heuristicas que buscan
 ciertas estructuras y evidencias en el codigo para determinar la (posible)
 presencia de un artefacto arquitectonico particular.
 Estas heuristicas han sido compiladas a partir de enfoques como DiscoTech
 
\begin_inset LatexCommand ref
reference "par:DiscoTect"

\end_inset

.
 Por ejemplo, una regla puede detectar la presencia de un componente del
 tipo Observer y una evidencia puede ser la presencia de una clase que implement
a la interface Observer.
\end_layout

\begin_layout Standard
Un conjunto inicial de reglas genéricas es provista por la herramienta,
 las cuales pueden ser utilizadas siempre y cuando se correspondan con las
 características del sistema y/o los objetivos de la reconstrucción.
 Adicionalmente, las reglas pueden ser especificadas por el arquitecto que
 realiza el proceso de reconstrucción.
 Las reglas incorporadas por el arquitecto pueden ser utilizadas en cualquiera
 de las fases del proceso de reconstrucción.
\end_layout

\begin_layout Section
Identificación de estructuras arquitectónicas
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Los parrafos de esta seccion tienen redundancia con lo anterior, consolidarlo
 mejor con lo anterior.
 Otro comentario: no entiendo cual fase iria primero, la de sugerir el observer-
observable y luego la de sugerir el MVC? o es al reves, primero el MVC y
 luego el Observer? Si es la 2da opcion, entonces Ademas, "invertir" la
 explicacion actual porque las reglas Observer-Observable funcionan dentro
 del MVC.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como se mostró en el ejemplo 
\emph on
Observer-Observable
\emph default
, las reglas que identifican estructuras arquitectónicas son simples.
 Por ejemplo, una clase que implementa la interface 
\emph on
Observer
\emph default
 se mapea a un componente arquitectónico.
 Si bien esto se define como una regla, durante el proceso de reconstrucción
 esta regla se presenta como sugerencia y es responsabilidad del arquitecto
 aceptar o refutar la generación un nuevo componente.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
El conjunto de reglas que se seleccionaron para reconstruir el sistema de
 ejemplo 
\emph on
Observer-Observable
\emph default
 no fue casual
\begin_inset Note Note
status open

\begin_layout Standard
Porque no mostrar un ejemplo de la regla para sugerir este estilo, cosa
 de ilustrar lo descripto en 1, 2, 3 arriba?
\end_layout

\end_inset

.
 Previamente se ejecutó una fase con un conjunto de reglas capaces de detectar
 estilos arquitectónicos.
 Esto permitió detectar el estilo MVC (
\emph on
Model View Controler
\emph default
) y así poder seleccionar conjuntos de reglas relacionadas con ese estilo.
\end_layout

\begin_layout Standard
En el estilo MVC puro, normalmente el modelo representa los datos a ser
 mostrados, la vista es responsable de reflejarlos visualmente al usuario
 y el controlador es responsable de administrar las entradas del usuario,
 realizando cambios en el modelo cuando corresponda y refrescando a la vista.
 En muchas implementaciones, las interfaces de los modelos son diseñados
 específicamente para la vista.
 Cuando la vista se dibuja, se comunica fuertemente con el modelo.
 Es por esta razón que se seleccionan reglas relacionadas con el patrón
 
\emph on
Observer-Observable
\emph default
 cuando el estilo arquitectónico MVC fue detectado.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
No entiendo el proposito de este parrafo tan general aca, ni tengo idea
 de como se "soporta/implementa" esto en el tool.
 Yo diria de recortarlo y evitar ser pesados ..
\end_layout

\begin_layout Standard
Lo que si pondria es una frase tipo: "Inicialmente, se decidio codificar
 en DRArch un repertorio basico de fuentes de conocimiento (reglas) para
 asistir en la deteccion de artefactos arquitectonicos.
 Las reglas se basan en enfoques preexistentes [REFs], y se describen en
 las secciones subsiguientes." 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
SACAR --> A su vez, es posible construir reglas mas complejas que ayuden
 a identificar estructuras arquitectónicas relacionando distintos tipos
 de información.
 Para ello es necesario conocer cuales son los aspectos a tener en cuenta
 a la hora de reconocer dichas estructuras.
 Durante el proceso de diseño se toman decisiones importantes que persistirán
 a lo largo de todo el ciclo de vida del sistema.
 Decisiones como por ejemplo de que manera agrupar los componentes en paquetes,
 que patrones de diseño utilizar para realizar un modulo específico o más
 simples como por ejemplo que visibilidad darle a determinadas clases dentro
 de un paquete.
 Todos estos elementos o practicas son comunes a todos los sistemas y las
 mismas pueden ser aprovechadas para realizar ingeniería reversa sobre un
 sistema.
\end_layout

\end_inset

Como se mencionó anteriormente, se decidió codificar en 
\emph on
DRArch
\emph default
 un repertorio básico de fuentes de conocimiento (reglas) para asistir en
 la detección de artefactos arquitectónicos.
 Las reglas se basan en enfoques preexistentes y se describen en las secciones
 subsiguientes.
\end_layout

\begin_layout Subsubsection
Estructura De Paquetes 
\end_layout

\begin_layout Standard
Cualquier sistema grande se debe dividir en unidades más pequeñas, de modo
 que las personas puedan trabajar con una cantidad de información limitada,
 a la vez y de modo que los equipos de trabajo no interfieran con el trabajo
 de los otros.
 Un paquete es una parte de un modelo.
 Cada parte del modelo debe pertenecer a un paquete.
 Pero para ser funcional, la asignación debe seguir un cierto principio
 racional, tal como funcionalidad común o implementación relacionada
\begin_inset Note Note
status collapsed

\begin_layout Standard
 y punto de vista común ?????
\end_layout

\end_inset

.
 Los paquetes ofrecen un mecanismo general para la organización de los modelos/s
ubsistemas agrupando elementos de modelado.
 Cada paquete corresponde a un sub\SpecialChar \-
mo\SpecialChar \-
de\SpecialChar \-
lo (subsistema) del modelo (sistema).
 Los paquetes son unidades de organización jerárquica de uso general de
 los modelos de UML.
 UML no impone una regla para componer los paquetes.
 Pueden ser utilizados para el almacenamiento, el control de acceso, la
 gestión de la configuración y la construcción de bibliotecas que contengan
 fragmentos reutilizables del modelo.
 Un paquete puede contener otros paquetes, sin límite de anidamiento pero
 cada elemento pertenece a (está definido en) sólo un paquete.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Pela: yo sacaria esto: Los paquetes contienen elementos del modelo al más
 alto nivel tales como clases y sus relaciones, máquinas de estado, diagramas
 de casos de uso, interacciones y colaboraciones; atributos, operaciones,
 estados, líneas de vida y mensajes están contenidos en otros elementos
 y no aparecen como contenido directo de los paquetes.
 Una clase de un paquete puede aparecer en otro paquete por la importación
 a través de una relación de dependencia entre paquetes.
 Todas las clases no son necesariamente visibles desde el exterior del paquete,
 es decir, un paquete encapsula a la vez que agrupa.
 En general, un paquete no puede tener acceso al contenido de otro paquete.
 Los paquetes son opacos, a menos que sean abiertos por una dependencia
 de acceso o de importación.
 La dependencia de acceso indica que el contenido del paquete del proveedor
 puede aparecer en referencias efectuadas por los elementos del paquete
 cliente.
 En general, un paquete puede ver solamente los elementos de otros paquetes
 que tienen visibilidad pública.
 Los elementos con visibilidad protegida pueden ser vistos únicamente por
 los paquetes que son descendientes del paquete contenedor de dichos elementos.
 Los elementos con visibilidad privada sólo son vistos por su paquete contenedor
 y anidados.
 La visibilidad también se aplica a las clases.
 El permiso de acceso y visibilidad son necesarios para hacer referencia
 a un elemento.
 La dependencia de acceso no modifica el espacio de nombres del cliente
 no crea las referencias automáticamente, simplemente concede permiso para
 establecer referencias.
 La dependencia de importación se utiliza para agregar nombres al espacio
 de nombres del paquete del cliente como sinónimos de los caminos completos.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aprovechando la organización estructural que brinda la estructura de paquetes,
 junto con los permisos de acceso y la visibilidad de los elementos contenidos
 en éste, es posible individualizar o detectar posibles componentes arquitectóni
cos.
\end_layout

\begin_layout Subsubsection
Reconocimiento de componentes de utilidad 
\end_layout

\begin_layout Standard
\align block
Cuando se busca reconocer componentes es interesante también filtrar o excluir
 del análisis aquellos elementos que no aportan valor agregado al análisis.
 En la literatura, estos elementos son conocidos como componentes de utilidad.
 Dichos componentes determinan detalles de implementación de bajo nivel.
 Hamou et.
 al.
 
\begin_inset LatexCommand cite
key "Abdelwahab"

\end_inset

 definen un componente de utilidad como cualquier elemento de un programa
 diseñado por conveniencia del diseñador o el programador con la intensión
 de ser accedido desde múltiples lugares dentro de cierto ámbito (
\emph on
scope
\emph default
) dentro del programa.
 Con el propósito de detectar componentes de utilidad, los autores desarrollaron
 un algoritmo basado en un análisis
\emph on
 fan-in
\emph default
.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
\align block
[Y] Este algoritmo...explora el grafo de dependencias...
 
\end_layout

\end_inset

 Este algoritmo explora del grafo de dependencias de clases construido en
 base al análisis estático del sistema y se encarga de individualizar aquellas
 clases que tienen un gran número de arcos entrantes (muchas clases dependientes
).
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
\align block
[Y] y se encarga de individualizar aquellas clases que tienen un gran número
 de arcos entrantes (muchas clases dependientes) puede ir despues..
\end_layout

\end_inset

El grafo de dependencias de clases es un grafo dirigido donde los nodos
 son las clases del sistema y los arcos representan las relaciones entre
 las clases.
 Por ejemplo, si agregamos una nueva clase llamada 
\family typewriter
Helper
\family default
 al ejemplo 
\emph on
Observer-Observable
\emph default
 y suponemos que la mayoría de estas clases utiliza por algún motivo la
 nueva, un posible componente de utilidad seria estaría representado por
 la clase 
\family typewriter
Helper
\family default
.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Grafo-de-dependencias Utilidad"

\end_inset

 muestra un grafo dependencias en donde se puede observar esta situación.
\end_layout

\begin_layout Standard
\align block
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/GrafoObserverObservable.png
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Grafo-de-dependencias Utilidad"

\end_inset

Grafo de dependencias que muestra un componente utilidad y clase de entrada
 al módulo.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [nico] explicar la imagen desde el ejemplo
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Para determinar si una clase es considerada una utilidad, se propone la
 siguiente medición 
\begin_inset LatexCommand cite
key "Abdelwahab"

\end_inset

:
\end_layout

\begin_layout Standard
Dada una clase 
\family typewriter
C
\family default
 y los siguientes conjuntos:
\end_layout

\begin_layout Itemize

\family typewriter
S
\family default
: Conjunto de clases consideradas en el análisis.
\end_layout

\begin_layout Itemize

\family typewriter
IN
\family default
: Un subconjunto de S que consiste en las clases que dependen de C (
\emph on
fan-in
\emph default
).
\end_layout

\begin_layout Standard
Se define la medición de utilidad 
\family typewriter
U
\family default
 de la clase 
\family typewriter
C
\family default
 como:
\end_layout

\begin_layout Standard
\align center

\family typewriter
U = |IN| / (|S|-1)
\end_layout

\begin_layout Standard
El conjunto 
\family typewriter
S
\family default
 es usado para representar el 
\emph on
scope
\emph default
 considerado en el análisis de 
\family typewriter
U
\family default
.
 Por ejemplo, si se están buscando utilidades a nivel de sistema, 
\family typewriter
S
\family default
 contendrá todas las clases del sistema.
 Por el contrario, si la búsqueda está restringida a un paquete en particular,
 entonces 
\family typewriter
S
\family default
 contendrá solo las clases de dicho paquete.
\end_layout

\begin_layout Standard
Los valores de 
\family typewriter
U
\family default
 varían de 0 a 1 en donde 0 indica que la clase no tiene arcos de entrada.
 Este dato es de mucha utilidad, por ejemplo cuando se esta evaluando un
 módulo específico, esta clase determina el punto de acceso a dicho módulo.
 Si en cambio evaluamos el sistema entero, dicha clase es el punto de entrada
 al sistema o es una clase que nunca se invoca.
 Notar que las dependencias de dicha clase sobre sí misma no están consideradas
 lo que explica el valor 
\family typewriter
|S| -1
\family default
.
\end_layout

\begin_layout Standard
Dada esta medición y el grafo de dependencias, el algoritmo de detección
 de componentes de utilidad se muestra en el Algoritmo\InsetSpace ~

\begin_inset LatexCommand ref
reference "alg:Algoritmo-de-utilidad"

\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Mejorar la descripcion del algoritmo y 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard

\series bold
utility
\series default
(S)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
for
\series default
 class 
\series bold
in
\series default
 S
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
u = calculateUtility(class, S)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
if
\series default
 u > UMBRAL
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
solution.add(class)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end if
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard

\series bold
\InsetSpace ~
\InsetSpace ~
return 
\series default
solution
\end_layout

\begin_layout Standard

\series bold
end run-phase
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Algoritmo-de-utilidad"

\end_inset

Algoritmo de detección de componentes de utilidad.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
mostrar mediante un ejemplo..
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Crear un conjunto resultado (vacio).
\end_layout

\begin_layout Enumerate
Para cada clase C del conjunto S, calcular U.
\end_layout

\begin_layout Enumerate
Identificar las class que tienen un valor U mayor o igual a un valor umbral
\begin_inset LatexCommand cite
key "Abdelwahab"

\end_inset

 y agregarla al conjunto solución.
\end_layout

\begin_layout Enumerate
Las clases contenidas en el conjunto solución son cadidatas a ser clases
 de utilidad.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Identificación de componentes basado en acoplamiento
\begin_inset Note Note
status open

\begin_layout Standard
Incluir referencia de donde sale esta heuristica [ref a la matriz de dependencia
]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Utilizando un enfoque similar al descripto anteriormente es posiblecalcular
 una medida de acoplamiento entre clases.
 Se define acoplamiento como el grado en que un componente esta conectado
 a otros componentes del sistema, es decir, su 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] su 
\end_layout

\end_inset

grado de dependencia que tiene.
 Todo buen diseño de componentes está o debería estar pensado de tal forma
 que sus componentes sean cohesivos y con bajo acoplamiento con los demás
 componentes.
 De esta forma es posible detectar componentes agrupando en 
\emph on
clusters
\emph default
 aquellas clases que tengan una fuerte interacción con sus clases vecinas.
 Por ejemplo, si el caso del 
\emph on
Observer-Observable
\emph default
 se describe mediante un grafo de dependencias como muestra la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Grafo-de-dependencias-acoplamiento"

\end_inset

, se pueden distinguir estas propiedades.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
Es decir, el acoplamiento del conjunto de clases que relacionadas con el
 modelo (conjunto 
\family typewriter
A
\family default
 de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Grafo-de-dependencias-acoplamiento"

\end_inset

) podrían conformar un componente mientras que el conjunto de clases relacionada
s con la presentación (conjunto 
\family typewriter
B
\family default
 de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Grafo-de-dependencias-acoplamiento"

\end_inset

) podrían conformar otro componente distinto.
 ANDRES: Reescribir para que sea mas claro y el lector pueda asociarlo con
 drarch.
\end_layout

\end_inset

En la figura pueden verse claramente dos conjuntos de clases (Modelo y Presentac
ión) agrupados por el grado de acoplamiento entre sus clases vecinas.
 De esta forma es posible realizar reglas que reconozcan este tipo de agrupación
es y el asistente las sugerirá como componentes del modelo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/GrafoAcoplamientoObserverObservable.png
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Grafo-de-dependencias-acoplamiento"

\end_inset

Grafo de dependencias en el que se observan el grado de acoplamiento entre
 los componentes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Varios son los tipos de dependencia entre clases que determinan el grado
 de acoplamiento entre componentes.
 Por ejemplo:
\end_layout

\begin_layout Itemize
Referencia entre componentes: el componente A invoca al componente B.
\end_layout

\begin_layout Itemize
Cantidad de datos intercambiados entre componentes: El componente A pasa
 como parámetro a otro B un vector, una matriz, una variable, etc.
\end_layout

\begin_layout Itemize
Decisiones de control que un componente realiza sobre otro: El componente
 A pasa un valor de control al componente B.
 El valor de la variable determina el comportamiento del componente B.
\end_layout

\begin_layout Itemize
El grado de la complejidad de la interfaz de los componentes.
\end_layout

\begin_layout Standard
Como base fundamental para medir el acoplamiento dentro de un módulo se
 tomaron tanto medidas de 
\emph on
fan-in
\emph default
 como medidas 
\emph on
de fan-out
\emph default
 (valores altos determinan una alta dependencia con el ext
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] t
\end_layout

\end_inset

erior) conseguidas a través de la evaluación del grafo de dependencias.
\end_layout

\begin_layout Standard
El algoritmo propuesto selecciona un conjunto de clases a analizar 
\family typewriter
S
\family default
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] que es S?? aca tambien gráfico que describa el procedimiento en base
 a un ejemplo 
\end_layout

\end_inset

como espacio de solución, el cual contiene todas las clases bajo análisis.
 Comienza el procesamiento eligiendo una clase de dicho espacio, posiblemente
 la que mayor 
\emph on
fan-out
\emph default
 tenga y se la agrega a un espacio de solución (
\emph on
cluster
\emph default
) 
\family typewriter
C1
\family default
.
 Se agregan luego las clases vecinas a esta a una lista de elementos a evaluar
 dentro del espacio 
\family typewriter
C1
\family default
.
 Se recorre dicha lista y se van agregando dichas estas clases al 
\emph on
cluster
\emph default
 siempre que su incorporación no lleve el grado de acoplamiento del todo
 el 
\emph on
cluster
\emph default
 por debajo de un valor umbral .
 Si se acepta dicha clase, las clases vecinas son incorporadas a la lista
 de elementos candidatos y se continua el análisis hasta que no haya elementos
 en esta lista.
 En este momento se coloca a 
\family typewriter
C1
\family default
 como componente candidato y se continua el análisis para todas aquellas
 clases del espacio S original.
\end_layout

\begin_layout Standard
Al termino de la ejecución del algoritmo se dispone de un conjunto de 
\emph on
clusters
\emph default
 
\family typewriter
Ci
\family default
, los cuales representan componentes cuyo valores de acoplamiento están
 por encima del valor umbral seleccionado.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard

\series bold
component-recognizer
\series default
(S: conjunto de clases a analizar)
\end_layout

\begin_layout Standard

\series bold
List
\series default
 solution_clusters = new 
\series bold
List()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
fore 
\series default
class c 
\series bold
in
\series default
 S
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
Cluster
\series default
 Ci = new 
\series bold
Cluster()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
Ci.add(c)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
remove c from S
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
List
\series default
 neightboards = new 
\series bold
List
\series default
()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
neightboards.add(c.neightboards())
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
for 
\series default
n 
\series bold
in
\series default
 neightboards 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
if
\series default
 ( agregar n a Ci no baja el acoplamiento) 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
Ci.add(n)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
remove n from S
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
neightboards.add(n.neightboards())
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end if
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
solution_clusters.add(Ci)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard

\series bold
end component-recognizer
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Algoritmo para la detección de componentes basado en el grado de acoplamiento.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Identificación de 
\emph on
Hot Spot
\emph default
 
\emph on
en frameworks
\end_layout

\begin_layout Standard
Los frameworks orientados a objetos son, quizás, la herramienta más efectiva
 para alcanzar el reuso tanto de diseño como de código 
\begin_inset LatexCommand cite
key "Fayad97"

\end_inset

.
 El principal beneficio de los frameworks 
\begin_inset LatexCommand cite
key "Johnson97,Fayad99"

\end_inset

 es que estos proveen un esqueleto general y reusable de clases y patrones
 de comportamiento para un dominio específico.
 Basándose en frameworks, el desarrollo de nuevas aplicaciones se puede
 llevar a cabo de manera flexible y directa con un adicional ahorro de tiempo
 y esfuerzo de diseño.
\end_layout

\begin_layout Standard
El concepto principal del diseño de 
\emph on
frameworks 
\emph default
se basa en separar aquellos aspectos que son invariantes en un dominio de
 aplicación de aquellos 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] se basa en separar aquellos aspectos que son invariantes ...en un dominio
 de aplicación de aquellos que...
\end_layout

\end_inset

 otros que varían a lo largo de las aplicaciones y que deben mantenerse
 flexibles y customizables (
\emph on
hot spots
\emph default
).
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Ambos tipos de spots son soportados mediante los conceptos herencia y ..
 en lenguajes orientados a objetos..
 A partir de estos conceptos....los frameworks defininen metodos templates y
 hooks....
 FIJARSE DE CONECTAR MEJOR LOS PARRAFOS..
 
\end_layout

\end_inset

Los conceptos de herencia y 
\emph on
binding
\emph default
 dinámico son las claves para llevar a cabo esto en lenguajes orientados
 a objetos.
 A partir de estos conceptos los 
\emph on
frameworks
\emph default
 proveen su flexibilidad definiendo métodos 
\emph on
templates
\emph default
 y 
\emph on
hooks
\emph default
.
 Los métodos 
\emph on
template
\emph default
 son implementados basados sobre los métodos 
\emph on
hook
\emph default
.
 Un método 
\emph on
hook
\emph default
 en un método elemental en el contexto en el que el 
\emph on
hook
\emph default
 particular es usado (este puede ser tanto un método abstracto, un método
 regular u otro método 
\emph on
template
\emph default
)
\begin_inset LatexCommand cite
key "Fayad99"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Andres: Agregar las REFERENCIAS en las que se basaron para lo de frameworks
 de esta subseccion.
 ej.
 Fayad99
\end_layout

\end_inset

Generalmente, los métodos 
\emph on
template
\emph default
 son usados para implementar los 
\emph on
frozen spots
\emph default
 en un 
\emph on
framework
\emph default
, y los métodos 
\emph on
hook
\emph default
 los 
\emph on
hot spots
\emph default
.
 Los 
\emph on
frozen spots
\emph default
 son aspectos que son invariantes a lo largo de las aplicaciones en el dominio,
 posiblemente representando comportamiento abstracto, flujos de control
 genéricos y relaciones comunes entre objetos.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/HookTemplateObserverObservable.png
	width 40theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Hooks-y-Templates"

\end_inset


\emph on
Hooks
\emph default
 y
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Adaptar la figura al ejemplo conductor..
\end_layout

\end_inset

 
\emph on
Templates 
\emph default
en el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para poder comprender este concepto, se modificó la clase 
\family typewriter
UserLogger
\family default
 del ejemplo 
\emph on
Observer-Observable
\emph default
 de la siguiente forma.
 Se declaró un nuevo método abstracto llamado 
\family typewriter
write\SpecialChar \-
Log(\SpecialChar \-
String message)
\family default
 el cual es invocado por el método 
\family typewriter
update
\family default
.
 Así el método 
\family typewriter
update
\family default
 se convierte en un método 
\emph on
template
\emph default
 mientras que el método 
\family typewriter
writeLog
\family default
 es un método 
\emph on
hook
\emph default
 (ver figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Hooks-y-Templates"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
agregar el diagrama de clases que muestre este concepto
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En base a esto, se decidió utilizar una estrategia para identificar componentes
 arquitectónicos.
 En primer lugar identificamos los métodos 
\emph on
hook
\emph default
, y a partir de esto se plantean dos posibilidades.
 
\end_layout

\begin_layout Itemize
La método 
\emph on
template
\emph default
 invoca el metodo 
\emph on
hook
\emph default
 declarado en la misma clase.
 La implementación de el método 
\emph on
hook
\emph default
 pertenece a la misma jerarquía que la clase que declara el método 
\emph on
template
\emph default
.
 De esta forma se busca quién invoca al método 
\emph on
template
\emph default
.
 Se seleccionan como posibles componentes y se recupera la relación (Sección
 A de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Hot-Spot-y-Frameworks"

\end_inset

).
 Haciendo referencia al ejemplo 
\emph on
Observer-Observable
\emph default
, la clase 
\emph on
hook
\emph default
 
\family typewriter
UserLogger
\family default
 posee el método 
\emph on
template
\emph default
 
\family typewriter
update
\family default
 y éste último es invocado por la clase 
\family typewriter
Observable
\family default
.
\end_layout

\begin_layout Itemize
El método 
\emph on
hook
\emph default
 y el método 
\emph on
template 
\emph default
pertenecen a clases de distintas jerarquías.
 Es decir, la clase que invoca el método 
\emph on
hook
\emph default
 no pertenece a la jerarquía de la clase que contiene al método 
\emph on
template
\emph default
 que lo invoca.
 Se seleccionan dichas clases como posibles componentes, y se recupera también
 la relación, en la que la clase 
\emph on
hook
\emph default
 provee un servicio y la clase 
\emph on
template
\emph default
 lo consume (Sección B de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Hot-Spot-y-Frameworks"

\end_inset

).
 Para describir esta situación desde el ejemplo 
\emph on
Observer-Observable
\emph default
, se incorporó una nueva clase llamada 
\family typewriter
LogEvent
\family default
.
 Esta clase posee una propiedad privada del tipo 
\family typewriter
UserLogger
\family default
 y un método trace que invoca al método 
\emph on
hook
\emph default
 
\family typewriter
writeLog
\family default
 perteneciente al 
\family typewriter
UserLogger
\family default
.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y ...agregar el diagrama de clases para que se entienda un poco mas] 
\end_layout

\begin_layout Standard
Ejemplo conductor..
 para explicar..
\end_layout

\begin_layout Standard
Cada parte debe ir construyendo una porcion de la arquitectura final..
 hasta terminar la explicacion del enfoque
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Standard
Andres: 
\end_layout

\begin_layout Standard
Que son la (A) y la (B) aca? fases?...
 no puedo adivinarlo
\end_layout

\begin_layout Standard
Por ahi no es el mejor tipo de diagrama para visualizar "invocations", asi
 que agregar texto al diagrama que aclare quien es el template/hook que
 llama a quien ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/HotspotObserverObservableJuntos.png
	width 50theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard

\emph on
\begin_inset LatexCommand label
name "fig:Hot-Spot-y-Frameworks"

\end_inset

Identificación de Hot Spots.
 
\emph default
Ejemplo
\emph on
 para el caso Observer-Observable.
 
\emph default
En la sección A de la figura se puede ver a la clase Consumer que invoca
 al método 
\emph on
Template
\emph default
.
 En sección B, se puede ver que la clase 
\emph on
Consumer
\emph default
 implementa el método template el cual invoca al método 
\emph on
Hook
\emph default
.
 Ambos casos con sus correspondietes contrapartes en el ejemplo Observer-Observa
ble.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Manipulación de alternativas arquitectónica
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
queda descolgada de la linea general..
 hay saltos..
 referir al proceso gereral..
 algo como ..
 una vez realizado ....
 DrArch utiliza un conjunto de reglas...
 para proponer alternativas .
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como se mencionó anteriormente una sugerencia es el resultado de evaluar
 una de las reglas disponibles sobre la base del conocimiento.
 La importancia de estas decisiones de diseño varía para cada sistema de
 software y está dada en función de los interesados en el sistema, sus preocupac
iones, y sus necesidades específicas.
 Por ejemplo, es posible que una sugerencia proponga la creación de uno
 de los componentes mas importantes del sistema, pero el arquitecto no desea
 mostrar ese componente en la vista que esta trabajando, ya que no esta
 interesado en ese aspecto del sistema.
 En ese caso, el arquitecto decide rechazar la sugerencia y continuar analizando
 el resto de las sugerencias.
\end_layout

\begin_layout Standard
De esta forma, aceptar o rechazar una sugerencia se convierte en una decisión
 de la arquitectura.
 Las decisiones de la arquitectura se concentran en lo que es esencial en
 un sistema.
 Estas elecciones pueden incluir estructura, organización, funcionalidad,
 comportamiento, o más propiedades no funcionales como la usabilidad, flexibilid
ad, seguridad, etc.
\end_layout

\begin_layout Standard
Al termino de cada fase, se cuenta cuenta con una representación gráfica
 del modelo arquitectónico la cual cubre dos aspectos fundamentales de la
 arquitectura del sistema: estructura y comportamiento.
 Las sugerencias aceptadas de las reglas que fueron ejecutadas, agregaron
 hechos a la base de conocimiento.
 Los hechos agregados representas aspectos del sistema de alto nivel, y
 son interpretados como tales para generar vistas que permitan mostrar la
 arquitectura del sistema.
 Cuando un conjunto de reglas finaliza su ejecución, se generan diagramas
 de componentes y de UCMs.
\begin_inset Note Note
status collapsed

\begin_layout Standard
ANDRES: Esto sale out of nowhere.
 Porque el mapeo es "correspondiente"?, y donde se hablo de FLABot antes?
\end_layout

\begin_layout Standard
Saco esto --> con su correspondiente mapeo al código fuente.
 Estos diagramas están representados en 
\emph on
FLAbot
\emph default
.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Modelar o capturar las decisiones de diseño arquitectónico está estrechamente
 ligado con la visualización arquitectónica y con la forma en que las decisiones
 de diseño son representadas y manipuladas por los interesados.
 Cada visualización tiene diferentes ventajas y desventajas que un arquitecto
 debe considerar.
\end_layout

\begin_layout Standard
Una vez que la vista es generada, el arquitecto pude realizar modificaciones
 sobre los diagramas.
 Las modificaciones realizadas son sincronizadas con la base de conocimiento
 para reflejar los cambios.
\end_layout

\begin_layout Standard
Es importante destacar que los componentes pueden estar mapeados al código
 fuente de forma explícita.
 Es decir, existe una relación que vincula a la clase 
\family typewriter
UserInterface
\family default
 con el componente 
\family typewriter
UserInterfaceObserver
\family default
 de la figuras 
\begin_inset LatexCommand ref
reference "fig:Diagrama-de-clases-UML-para-el-ejemplo-Observer-Observable"

\end_inset

 y 
\begin_inset LatexCommand ref
reference "fig:Diagrama-de-componentes-de-los-Observers"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Llevar esta seccion y distribuirla en la implementacion..
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Conclusiones-Cap4"

\end_inset

Conclusiones
\end_layout

\begin_layout Standard
En este capitulo se presentó el enfoque 
\emph on
DRArch
\emph default
, que permite obtener vistas arquitectónicas de un sistema a partir de un
 proceso guiado por el arquitecto.
 Este proceso intenta utilizar la mayor cantidad de información que sea
 posible y sus principales fuentes son: el código, la trazas 
\begin_inset Note Note
status open

\begin_layout Standard
Trazas o log? ponerse de acuerdo en como lo van a nombrar y usarlo consistenteme
nte en toda la tesis 
\end_layout

\end_inset

de ejecución y la ex\SpecialChar \-
pe\SpecialChar \-
rien\SpecialChar \-
cia de las personas involucradas en el sistema.
\begin_inset Note Note
status collapsed

\begin_layout Standard
ANDRES: Me sigue quedando en el aire como se incorpora esta experiencia
 al tool.
 Asumo que este knowledge se configura en el setup del tool con reglas "predefin
idas" para ciertos estilos arquitectonicos, es asi?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El proceso de reconstrucción es controlado por el arquitecto en todo momento.
 Su modelo 
\begin_inset Note Note
status collapsed

\begin_layout Standard
flexible (ANDRES: Nunca se dijo claramente en el capitulo que las reglas
 se puede generar "flexiblemente" (por ahi esto esta en el capitulo que
 sigue))
\end_layout

\end_inset

 de generación de reglas permite al arquitecto tener el control de cuándo
 y cómo actualizar el modelo arquitectónico.
\end_layout

\begin_layout Standard
Si bien la implementación por defecto de DRAch es para Java, no se imponen
 restricciones de un lenguaje específico en el que este implementado el
 sistema a analizar.
 El hecho de transformar la información del sistema a una base de conocimientos
 permite la aplicación del enfoque en muchos lenguajes existentes.
\end_layout

\begin_layout Standard
Debemos admitir que no existe la magia.
 Es imposible, desde nuestro punto de vista, que una herramienta pueda recuperar
, sin ayuda alguna, el diseño arquitectónico de un sistema.
 Se necesita del conocimiento del dominio de la aplicación y fundamentalmente
 de la ex\SpecialChar \-
pe\SpecialChar \-
rien\SpecialChar \-
cia del usuario.
 Utilizando el enfoque 
\emph on
DRArch
\emph default
, es posible alcanzar una aproximación de la arquitectura.
 
\end_layout

\begin_layout Standard
En el siguiente capítulo se muestran en detalle algunos aspectos de la implement
ación de DRArch.
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Implementación"

\end_inset

Diseño e implementación
\end_layout

\begin_layout Standard
El presente capítulo está dedicado a la descripción del diseño e implementación
 de 
\emph on
DRArch
\emph default
.
 Para ello, su estructura y funcionamiento serán descriptos mediante diagramas
 de paquetes y de descomposición de módulos a nivel arquitectónico y, a
 nivel de diseño detallado, mediante diagramas de clases y de interacción
 en notación UML (
\emph on
Uniﬁed Modeling Language
\emph default
) 
\begin_inset LatexCommand cite
key "BURKHARDT97"

\end_inset

, presentando los aspectos más importantes de su implementación.
 A su vez, a medida que se describen los componentes, se muestra cómo hace
 la herramienta 
\emph on
DRArch
\emph default
 para satisfacer las necesidades del enfoque mencionado, siguiendo el ejemplo
 de la sección 
\begin_inset LatexCommand ref
reference "sec:Ejemplo"

\end_inset

.
 El recorrido mencionado en este apartado es un ejemplo simple de una iteración
 en donde se puede observar la intervención del arquitecto en el momento
 de tomar las decisiones que modifican el modelo arquitectónico.
\end_layout

\begin_layout Standard
El capitulo inicia describiendo la arquitectura general de 
\emph on
DRArch
\emph default
 en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Arquitectura"

\end_inset

.
 Con\SpecialChar \-
ti\SpecialChar \-
nu\SpecialChar \-
a con una descripción de cada uno de los componentes más importantes
 de la arquitectura.
 En las secciones\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Query-Engine"

\end_inset

, 
\begin_inset LatexCommand ref
reference "sec:Rule-Model"

\end_inset

, 
\begin_inset LatexCommand ref
reference "sec:Phase-Engine"

\end_inset

 y 
\begin_inset LatexCommand ref
reference "sec:TraceLog-Analyzer"

\end_inset

 se explican en detalle cómo fueron diseñados e implementados los componentes
 
\emph on
Query Engine
\emph default
, 
\emph on
Rule Model, Phase Engine, 
\emph default
y 
\emph on
TraceLog Analyzer
\emph default
, respectivamente.
 Finalmente, en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Conclusiones"

\end_inset

 se presentan las conclusiones del capítulo.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Arquitectura"

\end_inset

Arquitectura
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] tendrian que tener una seccion donde explican las decisiones de diseño
 para cada subcomponente..
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
DRArch
\emph default
 fue implementado como un plug-in de la plataforma Eclipse, aprovechando
 su arquitectura extensible, su modelo para análisis estático de código
 fuente Java y su framework de interfaz de usuario.
 Otro factor que influenció la decisión es la tendencia creciente en el
 uso de Eclipse como herramienta para el desarrollo de software.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
aprovechando su arquitectura extensible, su modelo para análisis estático
 de código fuente Java y su framework de interfaz de usuario.
 
\begin_inset Note Note
status open

\begin_layout Standard
Otra factor que influenció la decisión es la tendencia creciente en el uso
 de eclipse como herramiento para el desarrollo de software.
\end_layout

\end_inset

Esto iria despues..
 de la explicacion de eclipse..
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Standard
En vez de esto..
 tendrian que poner algo como ..
 para el soporte de edicion de diagramas se integró DrArch a FLABot...
 La manipulacion de la informacion estatica de codigo fue implementada sobre
 JQuery...
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para el soporte de edición de diagramas se integró 
\emph on
DRArch
\emph default
 a 
\emph on
FLABot
\emph default
, permitiendo aprovechar el editor gráﬁco de UCMs.
 Además se utilizó el instrumentador de 
\emph on
bytecode
\emph default
 del proyecto 
\emph on
FLABot
\emph default
, ya que también fue implementado como plug-in.
 La manipulación de la información estática de código fue implementada sobre
 
\emph on
JQuery
\emph default
.
 Si bien 
\emph on
JQuery
\emph default
 también ha sido desarrollado como plug-in, en este trabajo se utilizo a
 modo de librería.
 El diseño de 
\emph on
DRArch
\emph default
 está muy inﬂuenciado por la arquitectura ya deﬁnida por 
\emph on
Eclipse
\emph default
.
 Esencialmente, 
\emph on
Eclipse
\emph default
 (ver Apéndice\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Plataforma-Eclipse"

\end_inset

) es una plataforma diseñada para construir herramientas de desarrollo.
 Si bien la plataforma por sí misma no provee mucha funcionalidad al usuario
 ﬁnal, facilita el rápido desarrollo de herramientas con características
 integradas.
 Así, la organización de estas herramientas alrededor de un espacio de trabajo
 común es un principio de diseño central, tanto para Eclipse como para 
\emph on
DRArch
\emph default
.
 En el caso particular de este trabajo, es necesario un cierto nivel de
 integración para aprovechar los componentes existentes de 
\emph on
FLABot
\emph default
 y la infraestructura básica de Eclipse.
 Por estas razones, la arquitectura de 
\emph on
FLABot
\emph default
 ha sido organizada mayormente alrededor de un estilo 
\emph on
data-centered
\emph default
 (centrado en los datos).
 La imposición de este estilo ayuda a soportar los niveles de integración
 antes mencionados y además permite una evolución casi independiente de
 las herramientas.
\end_layout

\begin_layout Standard
La funcionalidad propia de 
\emph on
DRArch
\emph default
 se encuentra organizada alrededor del modelo arquitectónico 
\emph on
BlackBoard
\emph default
, en el cual una base de conocimientos común
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] podrian ponerle un mejor nombre ;-) como base de conocimiento ..
 o algo asi..
\end_layout

\end_inset

 es iterativamente actualizada por fuentes de conocimiento especializadas
 (los especialistas), comenzando con la especificación de un problema y
 culminando con la solución.
 Cada fuente de conocimiento actualiza la base de conocimiento con una solución
 parcial cuando sus requisitos coinciden con el estado de la base de conocimient
o.
 De esta forma los especialistas trabajan juntos en la resolución del problema.
 El modelo 
\emph on
BlackBoard
\emph default
 fue originalmente designado para manejar problemas complejos y mal definidos.
 Los sistemas basados en este modelo están principalmente enfocados en la
 inteligencia artificial.
\end_layout

\begin_layout Standard
En la base de conocimiento las fuentes de conocimiento son ejecutadas automática
mente cuando sus precondiciones coinciden con el estado de la base de conocimien
to y el estado de este es actualizado con las transformaciones propias de
 cada fuente.
 Dado que proceso de recuperación arquitectónica descripto por 
\emph on
DRArch
\emph default
 es un proceso guiado, es el arquitecto el responsable de seleccionar qué
 fuente de conocimiento se va a ejecutar y de decidir cuáles son las transformac
iones que actualizaran el estado del modelo arquitectónico bajo análisis.
 Por esta razón, en la implementación del modelo 
\emph on
BlackBoard
\emph default
 utilizada en esta herramienta, será el arquitecto el encargado de seleccionar
 el orden de ejecución de las transformaciones.
 La base de conocimiento esta determinada por una base de hechos lógicos
 estilo Prolog la cual, como se dijo anteriormente, es cargada en una fase
 inicial de recolección de información estática (código fuente) y dinámica
 (logs de ejecución).
 Las fuentes de conocimiento encargadas de evaluar el estado de la base
 de conocimiento y actualizarlo, están materializados mediante un modelo
 de reglas.
 Éstas reglas están definidas a partir de una consulta, que evalúa el estado
 del repositorio en busca de algún patrón; una sugerencia, la que será presentad
a al arquitecto para cada uno de los resultados de la consulta; y una serie
 de hechos que determinan la actualización del repositorio y por ende la
 transformación del modelo arquitectónico bajo reconstrucción.
\end_layout

\begin_layout Standard
Por último, el modelo de fases determina la operatibilidad de la herramienta.
 Es el componente orquestador responsable de guiar el proceso y coordinar
 la interoperabilidad entre los módulos.
\end_layout

\begin_layout Standard
En la figura 
\begin_inset LatexCommand ref
reference "fig:Diagrama de Paquetes"

\end_inset

 se describen los componentes principales de la herramienta.
 A continuación se provee una descripción de las responsabilidades de cada
 uno.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Package Domain Model.png
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama de Paquetes"

\end_inset

Diagrama de paquetes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Decisiones de diseño
\end_layout

\begin_layout Standard
En esta sección se describen algunas de las principales decisiones de diseño
 tomadas para cada componente de la arquitectura del 
\emph on
DRArch
\emph default
.
\end_layout

\begin_layout Standard
Para el componente Query Engine se utilizó el motor de consultas que provee
 el plug-in 
\emph on
JQuery.

\emph default
 Principalmente, por ofrecer un lenguaje de programación lógica fácilmente
 ma\SpecialChar \-
ni\SpecialChar \-
pu\SpecialChar \-
la\SpecialChar \-
do desde una API en Java.
 JQuery, además de aportar el motor y el lenguaje, también provee del parseo
 de código fuente como así también la generación de hechos lógicos en base
 a éste parseo.
\end_layout

\begin_layout Standard
En el componente Rule Model, en donde es necesario persistir, visualizar
 y editar de forma gráfica y amigable el modelo, se eligió para su implementació
n el framework EMF de Eclipse.
 EMF es un framework de modelado y generación de código para generar aplicacione
s basadas en un modelo de datos estructurado.
\end_layout

\begin_layout Standard
La plataforma eclipse posibilitó la creación de 
\emph on
wizards
\emph default
 que asistan la generación de proyectos DRArch, así como la generación de
 reglas mediante la creación de un editor gráfico que opera directamente
 sobre el modelo EMF utilizado para las reglas.
\end_layout

\begin_layout Standard
En diseño del componente Phase Engine con el fin de dar soporte a distintos
 tipos de fases, se utilizó una clase abstracta para representar una fase.
 Luego, los distintos tipos de fase pueden extender de la clase abstracta.
 Pirncipalmente se detectaron dos tipos de fases: Interactivas y No Interactivas
 (acepta automáticamente todas las sugerencias).
 Para orquestar la lógica del motor de fases, se utilizó una entidad 
\family typewriter
PhaseManager
\family default
 responsable de coordinar y dirigir el estado de cada fase.
 En este componente se incluye la generación y modelado de diagramas.
 Esto es realizado por 
\emph on
Flabot 
\emph default
ya que posee unos editores gráficos para diagramas de Componentes y de UCMs
 y expone un modelo fácilmente manejable.
 De esta forma, se traduce la información representada en hechos 
\emph on
Prolog
\emph default
, al modelo 
\emph on
FLAbot
\emph default
.
\end_layout

\begin_layout Standard
Por último, para el componente Trace Log Analizer, se decidió utilizar el
 
\emph on
Flabot
\emph default
 como herramienta de instrumentación de código ya que la instrumentación
 no es intrusiva (no es necesario modificar el código) y genera un log de
 ejecución en formato XML de forma que se posible su análisis.
 
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Query-Engine"

\end_inset

Query Engine
\end_layout

\begin_layout Standard
Este componente tiene como principal responsabilidad la ejecución de las
 consultas sobre la base de conocimiento y la gestión de esta.
\end_layout

\begin_layout Standard
Forma parte de este componente el motor de consultas y la base de conocimiento.
 Ambas entidades están construidas sobre el plug-in 
\emph on
JQuery
\emph default
 
\begin_inset LatexCommand ref
reference "sec:JQuery"

\end_inset

.
 
\end_layout

\begin_layout Standard

\emph on
JQuery
\emph default
 esta basado en 
\emph on
TyRuBa
\emph default
 que es un lenguaje de programación lógica implementado en Java.
 De esta forma 
\emph on
JQuery
\emph default
 provee a 
\emph on
DRArch
\emph default
 de tres componentes fundamentales: el motor de inferencias, el lenguaje
 de consultas que se ulitizarán en las reglas y la implementación de la
 base de conocimiento sobre la que se realizarán dichas consultas.
 Cada uno de estos componentes han sido abstraídos desacoplándolos de su
 implementación permitiendo que, con mínimo esfuerzo, dichas implementaciones
 puedan variar o evolucionar independientemente.
\end_layout

\begin_layout Subsubsection
KnowledgeBase
\end_layout

\begin_layout Standard
La base de conocimiento consta de dos partes.
 La primera esta basada en los hechos generados durante la fase de recolección
 de la información y la segunda consiste en todos lo hechos generados por
 las ejecuciones de las reglas 
\emph on
DRArch
\emph default
 los cuales se agrupan por fases de ejecución.
 Estos últimos se han hecho persistentes en un archivo de texto con el propósito
 de reutilizar el resultado del análisis realizado en fases subsiguientes.
\end_layout

\begin_layout Standard
De esta forma la base de conocimiento evaluada en cada fase esta compuesta
 por la base de conocimiento (generada por el parseo del código fuente)
 y por todos los archivos de hechos lógicos que se agreguen a la fase.
\end_layout

\begin_layout Standard
En el análisis estático, una porción del código fuente correspondiente al
 ejemplo 
\emph on
Observer-Observable
\emph default
, se transforma a la representación que se detalla en la figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-de-la-representación-del-código-fuente"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/java2jquery.jpg
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-de-la-representación-del-código-fuente"

\end_inset

Ejemplo de la representación del código fuente
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Rule-Model"

\end_inset

Rule Model
\end_layout

\begin_layout Standard
El modelo de reglas esta formado principalmente por cuatro entidades: 
\family typewriter
Rule
\family default
, 
\family typewriter
Query
\family default
, 
\family typewriter
SuggestTemplate
\family default
 y 
\family typewriter
FactTemplates
\family default
.
 Una regla 
\family typewriter
Rule
\family default
 es la entidad mas importante de este componente porque determina la unidad
 funcional de la herramienta.
 Una regla, esta determinada por un 
\family typewriter
Query
\family default
, un 
\family typewriter
SuggestTemplate
\family default
 y un conjunto de 
\family typewriter
FactTemplates
\family default
.
 Un 
\family typewriter
Query
\family default
, a su vez, esta compuesto por una sentencia en formato ProLog que será
 utilizada para realizar una consulta sobre la base de conocimiento y un
 conjunto de variables de interés.
 Estas variables son parte de la consulta.
\end_layout

\begin_layout Standard
Cada 
\family typewriter
SuggestTemplate
\family default
 es una cadena de caracteres con 
\emph on
wildcard
\emph default
 que serán reemplazados por cada uno de los resultados de la consulta.
 Generalmente cada 
\emph on
wildcard
\emph default
 se corresponde con una variable de la consulta.
 Luego de la ejecución, el resultado de la consulta queda determinado por
 los valores de las variables de interés.
 Para cada uno de estos resultados se genera una sugerencia reemplazando
 cada 
\emph on
wildcard
\emph default
 con su correspondiente variable.
\end_layout

\begin_layout Standard
Por ultimo cada 
\family typewriter
FactTemplate
\family default
 del conjunto esta construido de la misma forma que los templates de sugerencias.
 Luego que las sugerencias hayan sido aceptadas se procede a instanciar
 un conjunto de hechos con los correspondientes valores para cada una de
 las sugerencias aceptadas.
 La figura 
\begin_inset LatexCommand ref
reference "fig:Modelo-de-reglas"

\end_inset

 muestra la relación entre estas entidades.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ruleModel.png
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Modelo-de-reglas"

\end_inset

Modelo de reglas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Básicamente el modelo de reglas es una estructura de datos, la cual es necesario
 persistir, visualizar y editar de forma gráfica y amigable para el usuario.
 Se eligió para su implementación el framework EMF de Eclipse.
 EMF es un framework de modelado y generación de código para generar aplicacione
s basadas en un modelo de datos estructurado.
 A partir de la especificación de un modelo descripto en XMI, EMF provee
 las herramientas para producir un conjunto de clases Java para el modelo,
 junto con un conjunto de clases 
\emph on
adapters
\emph default
 que permiten la visualización y edición del mismo.
\end_layout

\begin_layout Standard
Como se mencionó anteriormente, es necesario que un conjunto de reglas pueda
 ser reutilizado y ejecutado varias veces y sobre distintas instancias de
 la base de conocimiento.
 Por esta razón es necesario persistir las reglas creadas para su posterior
 utilización y/o edición.
 Utilizando las capacidades del framework EMF, se logró la persistencia
 del modelo como así también la creación de un editor propio de la herramienta
 
\emph on
DRArch
\emph default
 que hace realmente sencilla la edición y visualización de los datos.
\end_layout

\begin_layout Standard
La herramienta 
\emph on
DRArch
\emph default
 presenta una interface de usuario para la especificación de reglas (crear,
 editar y borrar reglas).
 En la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Especificando-Reglas"

\end_inset

 se muestra un 
\emph on
screenshot
\emph default
 de la pantalla con las tres partes mas importantes de la especificación
 de una regla: la consulta, la sugerencia que genera la ejecución de la
 consulta, y los hechos que se deben agregar a la base de conocimientos
 en el caso de que el arquitecto decida aceptar la sugerencia durante el
 proceso de reconstrucción.
 En la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:JQuery"

\end_inset

 del apéndice se encuentra un catálogo completo de los hechos disponibles
 junto con una descripción (en la herramienta es posible acceder a dicho
 catálogo a través de la ayuda).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableRule.jpg
	scale 80

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Especificando-Reglas"

\end_inset

Especificación de una regla para el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Phase-Engine"

\end_inset

Phase Engine
\end_layout

\begin_layout Standard
Este componente es el encargado de la coordinación y mediación entre los
 componentes descriptos anteriormente.
 Como se menciono en capítulos anteriores, el enfoque 
\emph on
DRArch
\emph default
 posee las propiedades de ser interactivo, iterativo e incremental.
 
\end_layout

\begin_layout Standard
La primera de estas características se da al brindarle al arquitecto el
 control total de lo que se evalúa, tomando todas las decisiones aceptando
 o rechazando las sugerencias propuestas por la herramienta.
 Para satisfacer las demás características se implementó un mecanismo de
 fases iterativas que permite la composición de los resultados de las evaluacion
es realizadas en iteraciones previas.
 
\end_layout

\begin_layout Subsubsection*
Fase
\end_layout

\begin_layout Standard
Una fase tiene como entrada un 
\emph on
working set 
\emph default
(modulo de código que será analizado), una serie de reglas que serán evaluadas
 sobre ese módulo y los archivos de hechos que vayan a componer la base
 de conocimiento para la fase en cuestión.
 El resultado de ejecutar una fase son dos artefactos: un archivo de hechos
 que fueron producto de la ejecución de cada regla de la fase y un archivo
 
\emph on
FLABot
\emph default
 con la representación gráfica del modelo arquitectónico recuperado.
\end_layout

\begin_layout Standard
Alternativamente se puede enriquecer la base de conocimientos de la fase,
 incorporando un archivo 
\emph on
FLABot
\emph default
 con un modelo arquitectónico definido y transformar la información del
 modelo arquitectónico del archivo a hechos lógicos.
\end_layout

\begin_layout Standard
La entidad 
\family typewriter
PhaseManager
\family default
 es la encargada de lanzar la ejecución de una fase.
 En ese momento se comienzan a ejecutar una por una las reglas que forman
 parte de la fase.
 Al finalizar la ejecución de cada regla, desde la capa de presentación
 se le piden al 
\family typewriter
PhaseManager
\family default
 dichas sugerencias para ser presentadas al usuario.
 Allí se pasa el control al usuario, quien es responsable de decidir que
 sugerencias acepta y disparar la ejecución de la próxima regla.
 Antes de ejecutar la siguiente regla de la fase, la entidad 
\family typewriter
PhaseManager
\family default
 le pide a la entidad 
\family typewriter
RuleManger
\family default
 que transforme las sugerencias en hechos concretos y luego agrega dichos
 hechos a la base de conocimientos.
 Luego, le da la orden a la entidad 
\family typewriter
DiagramManager
\family default
 que genere los diagramas.
 Finalmente con los nuevos hechos en la base de conocimiento y el diagrama
 generado se dispara la ejecución de la nueva regla.
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Phase-model"

\end_inset

 muestra la estructura del modelo de ejecución de fases.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/stepEngine.png
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Phase-model"

\end_inset

Modelo de fases
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Existen dos tipos de fases: las interactivas y las no interactivas.
 Las fases interactivas son aquellas que al finalizar la ejecución de cada
 regla se presentan las sugerencias al usuario para que este las acepte
 o las rechace.
 Las no interactivas en cambio, automáticamente aceptan todas las sugerencias
 y retorna el control al usuario una vez completada la fase.
 De esta forma se da la posibilidad de automatizar aquellas fases que contengan
 reglas con sugerencias que siempre serán aceptadas.
 Por ejemplo, es posible definir reglas que enriquezcan el análisis estático
 de código fuente provisto por 
\emph on
JQuery
\emph default
 y utilizar dichas reglas en la fase inicial de recolección de información.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard

\series bold
run-phase
\series default
(phase: Phase)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
for
\series default
 rule 
\series bold
in
\series default
 phase
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
suggestions = rule.execute()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
for
\series default
 suggestion 
\series bold
in
\series default
 suggestions
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
if
\series default
 suggestion.isAccepted()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
knowledgeBase.add(suggestion.getFacts())
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
loadModel()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
updateDiagram()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end if
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard

\series bold
end run-phase
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Algoritmo-ejecución-de-fases"

\end_inset

Algoritmo de ejecución del modelo Fases
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La ejecución de cada fase se describe en el Algoritmo\InsetSpace ~

\begin_inset LatexCommand ref
reference "alg:Algoritmo-ejecución-de-fases"

\end_inset

, en donde cada una de éstas obtiene la primer regla y la ejecuta.
 Luego muestra las sugerencias y si el arquitecto aceptas, agrega los nuevos
 hechos a la base de conocimiento.
 Posteriormente carga el nuevo modelo, actualiza los diagramas, y vuelve
 a ejecutar la siguiente regla.
 Esto se repite hasta que no queden más reglas.
\end_layout

\begin_layout Standard
Para reflejar la toma de decisiones y poder
\series bold
 
\series default
manipular las propuestas arquitectónicas, la herramienta expone dicha funcionali
dad por medio de 
\emph on
chekboxes
\emph default
 que indican si la sugerencia se acepta o se rechaza.
 Siguiendo con el ejemplo del 
\emph on
Observer-Observable
\emph default
, en la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Vista-de-sugerencias"

\end_inset

 se muestra la vista de sugerencias para la regla que detecta componentes
 
\emph on
Observer.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/DrarchSuggestView.jpg
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Vista-de-sugerencias"

\end_inset

Vista de sugerencias
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las iteraciones terminan cuando ya no quedan más reglas dentro de la fase
 que actualmente se esté ejecutando.
\end_layout

\begin_layout Subsubsection*
RuleManager
\end_layout

\begin_layout Standard
La entidad 
\family typewriter
RuleManager
\family default
 es responsable de la ejecución de las reglas y de interpretar los resultados
 para armar las sugerencias, así como también de crear para cada sugerencia
 aceptada el conjunto de hechos correspondiente según lo define el modelo
 de reglas.
 También es responsable de incorporar estos a la base de conocimiento.
 La ejecución de las consultas como se dijo anteriormente está a cargo de
 la entidad 
\family typewriter
QueryEngine
\family default
.
\end_layout

\begin_layout Standard
La Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Rule-Manager"

\end_inset

 muestra la estructura de este componente y su interacción con el 
\family typewriter
QueryEngine
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
corregir esta imgen
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename img/ruleEngine.png
	width 70theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Rule-Manager"

\end_inset

Rule Manager
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
DiagramManager
\end_layout

\begin_layout Standard
La entidad 
\family typewriter
DiagramManager
\family default
 esta encargada de traducir la información contenida en la base de conocimiento
 a los modelos de diagramas de 
\emph on
DRArch
\emph default
 (componentes y UCMs).
 Ejecuta una serie de consultas a la base de conocimiento mediante 
\family typewriter
QueryEngine
\family default
 para obtener la información arquitectónica con la que construirá el modelo.
 Luego es llevado al modelo 
\emph on
FLABot
\emph default
 y se delega a esta herramienta el renderizado de los diagramas.
 
\end_layout

\begin_layout Standard
La Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Phase-Management-Interaction"

\end_inset

 y la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-secuencias"

\end_inset

 muestran los distintos componentes y sus relaciones.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Phase Interaction.png
	width 90text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Phase-Management-Interaction"

\end_inset

Diagrama de interacciones entre los componentes 
\emph on
DRArch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Sequence Diagram.png
	width 50pheight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-secuencias"

\end_inset

Diagrama de secuencia entre los componentes 
\emph on
DRArch
\emph default
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es decir, la entidad es responsable de la generación de vistas.
 Si las sugerencias de la regla especificada en el ejemplo\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Especificando-Reglas"

\end_inset

 son aceptadas, el proceso de reconstrucción genera el diagrama de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-componentes-de-los-Observers"

\end_inset

.
 A su vez, una vez que se termine la actualización de las vistas, el arquitecto
 tiene la posibilidad de modificar los diagramas desde el editor gráfico.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserversComponentDiagram.jpg
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-componentes-de-los-Observers"

\end_inset

Diagrama de componentes de los 
\emph on
Observers
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:TraceLog-Analyzer"

\end_inset

TraceLog Analyzer
\end_layout

\begin_layout Standard
Como se expuso brevemente en el capítulo anterior, es necesario registrar
 los eventos de bajo nivel que ocurren en la aplicación mientras el usuario
 la ejercita con los casos de uso correspondientes.
 Para ello se utilizó la infraestructura de instrumentación de código de
 
\emph on
FLABot
\emph default
 (apéndice\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Eclipse-FLABot-y-JQuery"

\end_inset

, sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:FLABot"

\end_inset

), ya que ésta define un punto de extensión para la configuración de los
 eventos que deben ser registrados en tiempo de ejecución.
\end_layout

\begin_layout Standard
Básicamente, para la ejecución de una aplicación instrumentada es necesario
 (a) crear una nueva configuración de ejecución en Eclipse (
\emph on
launch configuration
\emph default
, Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "cap:Launch-config"

\end_inset

) y (b) iniciar la ejecución de esta configuración.
 
\emph on
FLABot
\emph default
 permite la es\SpecialChar \-
pe\SpecialChar \-
cia\SpecialChar \-
li\SpecialChar \-
za\SpecialChar \-
ción de la funcionalidad del módulo de instrumentación
 mediante el punto de extensión 
\emph on

\begin_inset Quotes eld
\end_inset

org.isistan.flabot.contextProvider
\begin_inset Quotes erd
\end_inset


\emph default
, que consiste en la definición de dos interfaces abstractas: 
\emph on
AbstractConfigurationTab
\emph default
 y 
\emph on
FlabotFileContextProvider
\emph default
, responsables de los puntos (a) y (b) respectivamente\SpecialChar \@.
 Las implementaciones
 de la primera interfaz se encargan de permitir al usuario configurar de
 manera gráfica la información necesaria para la creación del log de ejecución
 (ubicación del archivo de sa\SpecialChar \-
li\SpecialChar \-
da, tipos de eventos a registrar, profundidad
 de la inspección, etc.), mientras que las de la segunda interfaz proveen
 esta información al módulo de instrumentación.
 La relación entre 
\emph on
DRArch
\emph default
 y 
\emph on
FLABot
\emph default
 por medio de puntos de extensión se resume en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Relación-entre-DRArch"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/RunFlabotCollecting.png
	lyxscale 80
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Configuración-de-ejecución"

\end_inset

Configuración de ejecución en Eclipse
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/TraceLogConfigurationClassDiagram.PNG
	width 45page%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Relación-entre-DRArch"

\end_inset

Relación entre 
\emph on
DRArch
\emph default
 y 
\emph on
FLABot
\emph default
 mediante puntos de extensión
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una vez definida la extensión, la interacción entre 
\emph on
FLABot
\emph default
 y 
\emph on
DRArch
\emph default
 es relativamente simple.
 El arquitecto debe configurar la ejecución de la aplicación a instrumentar
 desde una interfaz de usuario de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Configuración-de-ejecución"

\end_inset

.
 Algunas de estas configuraciones son:
\end_layout

\begin_layout Enumerate
La aplicación a ser instrumentada.
\end_layout

\begin_layout Enumerate
El archivo de salida (
\emph on
nombre_del_archivo.tracelog
\emph default
).
\end_layout

\begin_layout Enumerate
El modelo 
\emph on
FLABot
\emph default
 que contiene la información de qué es lo que se va a instrumentar.
 Este modelo es generado por 
\emph on
DRArch.
\end_layout

\begin_layout Enumerate
El nivel de profundidad en el que se va a guardar la información.
 Cuanto mas profundidad, más información tendrá el log.
\end_layout

\begin_layout Standard
Una vez que fue creado un log de ejecución para un caso de uso en particular,
 
\emph on
Log Analyzer
\emph default
 se encarga de interpretar los eventos de bajo nivel contenidos en el log
 para transformarlos en hechos al estilo 
\emph on
ProLog
\emph default
.
 El proceso de transformación sigue un algoritmo simple: el componente utiliza
 la información de mapeo entre responsabilidades y métodos recorriendo el
 log de ejecución y tomando sus entradas (ejecuciones de métodos) una a
 una.
 Este proceso se muestra en el Algoritmo\InsetSpace ~

\begin_inset LatexCommand ref
reference "alg:Algoritmo-Log-Analyzer"

\end_inset

.
 Este algoritmo también se encarga de generar los hechos del estilo 
\family typewriter
snapshot
\family default
, encargados de guardar la información relacionada con el estado del sistema
 en el momento que se ejecuto una responsabilidad.
 Guardar toda la información del estado del sistema en el momento en el
 que se ejecuta cada responsabilidad es costoso debido a que la información
 aumenta exponencialmente y puede traer problemas de referencia cíclica.
 Por esta razón se define la profundidad del análisis como parámetro de
 configuración de la ejecución del log (parámetro 
\emph on
Level of Depth Log
\emph default
 de la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Configuración-del-log"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard

\series bold
log-analyzer
\series default
(log: Log, mappings: Mappings)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
factList = new List
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
for
\series default
 entradaLog 
\series bold
in
\series default
 log
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
responsabilidades = mappings.getResponsibilities(entradaLog)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
materializaciones = responsabilidades.getExecutions()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
for
\series default
 materialization 
\series bold
in
\series default
 materializaciones
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
execId = materialization.getTags().get("executionId")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
exitValue = materialization.getTags().get("value")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
arguments[] = materialization.getTags().get("arguments")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
behavior = materialization.getTags().get("behavior")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
methodName = behavior.getTags() .get("name")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
className = behavior.getTags().get("declaringClass")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
factsList.add(predicateFactory.createExecutedMethodValue(
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
className + "." + methodName, execId, exitValue, arguments[]))
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
snapshotFacts(materialization)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
return
\series default
 factList
\end_layout

\begin_layout Standard

\series bold
end log-analyzer
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Algoritmo-Log-Analyzer"

\end_inset

Algoritmo Log Analyzer
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los hechos generados por este componente son almacenados en la base de datos
 del conocimiento junto con el resto de la información.
 De esta forma, quedaría disponible la posibilidad de relacionar información
 tanto estática como dinámica.
\end_layout

\begin_layout Standard
Como resumen del análisis dinámico, el 
\emph on
log
\emph default
 de ejecución generado por la combinación de las he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
tas 
\emph on
DRArch
\emph default
 y 
\emph on
FLAbot
\emph default
, es analizado por el componente TraceLog Analizer para generar los hechos
 ProLog correspondientes al 
\emph on
log
\emph default
 de ejecución.
 De esta forma, en la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Observer-Observable-TraceLog"

\end_inset

 se muestran los hechos correspondientes al ejemplo 
\emph on
Observer-Observable
\emph default
 que se generan luego de analizar el 
\emph on
log
\emph default
 de ejecución.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableTraceLog.jpg
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Observer-Observable-TraceLog"

\end_inset

Transformación del 
\emph on
log
\emph default
 de ejecución del ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Conclusiones"

\end_inset

Conclusiones
\end_layout

\begin_layout Standard
En éste capítulo se describieron los aspectos más importantes acerca de
 la arquitectura, diseño detallado e implementación de 
\emph on
DRArch
\emph default
.
 La herramienta requiere la colaboración de componentes pertenecientes a
 otros sistemas, mas específicamente 
\emph on
Eclipse
\emph default
, 
\emph on
FLABot
\emph default
 y 
\emph on
JQuery
\emph default
.
 
\end_layout

\begin_layout Standard

\emph on
Eclipse
\emph default
 fue seleccionado principalmente por ser el entorno de desarrollo Java más
 popular en la actualidad y además, por brindar una arquitectura preparada
 para la integración de herramientas mediante extensiones.
 En segundo lugar, 
\emph on
Eclipse
\emph default
 ofrece un metamodelo del lenguaje Java idóneo para la manipulación de informaci
ón de código fuente.
 
\end_layout

\begin_layout Standard

\emph on
JQuery
\emph default
 es quien utiliza las ventajas de Eclipse sobre el metamodelo del lenguaje
 Java para realizar la transformación del código fuente a una representación
 de hechos al estilo 
\emph on
ProLog
\emph default
.
 
\end_layout

\begin_layout Standard

\emph on
FLABot
\emph default
, por otro lado, se emplea por dos razones centrales: ofrece un editor UCM
 con soporte para mapeo responsabilidad-código y además incluye soporte
 para instrumentar aplicaciones.
 El motor de instrumentación de aplicaciones 
\emph on
FLABot
\emph default
 genera un log de bajo nivel que es procesado por el componente 
\emph on
TraceLog Analyzer
\emph default
 para realizar una transformación de la información en hechos al estilo
 
\emph on
ProLog
\emph default
.
\end_layout

\begin_layout Standard
A diferencia de algunos de los enfoques mencionados en el capítulo 
\begin_inset LatexCommand ref
reference "cha:Trabajos-relacionados"

\end_inset

, los cuales siguen el mismo patrón de extraer, abstraer y presentar y que
 utilizan una base de datos relacional para almacenar las representaciones
 intermedias del modelo arquitectónico, 
\emph on
DRArch
\emph default
 utiliza el motor de consultas y la base de datos lógica provista por 
\emph on
JQuery
\emph default
.
 Esta decisión se basa en que al momento de realizar una consulta en un
 lenguaje lógico, se consulta por el qué y no por el cómo es el caso de
 los enfoques relacionales Esto hace que hace más sencillo y natural al
 arquitecto formular sus propias reglas.
 Para tal propósito se creó un editor utilizando las ventajas que ofrece
 SWT, un 
\emph on
toolkit
\emph default
 de elementos gráficos diseñados para ser portables y aprovechar las capacidades
 de los sistemas operativos sobre los que se ejecuta.
\end_layout

\begin_layout Standard
De esta forma al estar todo lo necesario integrado en el ambiente de desarrollo,
 si el arquitecto pretende incorporar la tarea de reconstrucción a su rutina,
 podrá hacerlo incluyendo únicamente el plug-in 
\emph on
DRArch
\emph default
 y sus dependencias, es decir: 
\emph on
FLABot
\emph default
 y 
\emph on
JQuery
\emph default
.
\end_layout

\begin_layout Standard
En el próximo capítulo se analizará el desempeño de 
\emph on
DRArch
\emph default
 ante un sistema real en desarrollo: 
\emph on
G2
\emph default
.
 Tales casos de estudio permitirán evaluar mejor la conveniencia de las
 decisiones de diseño explicadas en este capítulo.
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Casos-de-Estudio"

\end_inset

Casos de estudio
\end_layout

\begin_layout Standard
Este capítulo describe una serie de casos de estudio que realizamos para
 verificar que el enfoque 
\emph on
DRArch
\emph default
 puede ser aplicable a la reconstrucción arquitectónica de un sistema, y
 segundo, a ilustrar cómo se usó la herramienta en diferentes proyectos
 para poder investigar los puntos fuertes y débiles del enfoque.
 En cada caso de estudio se presenta (a) un detalle de la arquitectura del
 sistema --necesaria para realizar comparaciones--, (b) un resumen de las
 fases ejecutadas --describiendo la naturaleza de las reglas-- y (c) las
 vistas mas relevantes que se obtuvieron durante la ejecución del proceso
 de reconstrucción --importante para realizar la comparación con la arquitectura
 presentada en el punto (a)--.
\end_layout

\begin_layout Standard
Se realizó la reconstrucción de un proyecto de prueba llamado Market, y
 luego, se paso a reconstruir un proyecto comercial de tamaño mediano, llamado
 
\emph on
G2
\emph default
.
 En esta etapa, se probó el desempeño de la herramienta frente a un sistema
 real.
 Ambos proyectos utilizan un framework basado en invocaciones implícitas
 llamado Bubble\InsetSpace ~

\begin_inset LatexCommand cite
key "CAMPO02"

\end_inset

.
\end_layout

\begin_layout Standard
El capítulo se encuentra organizado de la siguiente manera.
 Primero se presenta el caso de estudio Market en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Market"

\end_inset

.
 Luego se presenta un caso para el sistema 
\emph on
G2
\emph default
 en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:G2"

\end_inset

.
 Para ambos casos de estudio, se muestra la arquitectura originalmente propuesta.
 Finalmente, en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Análisis-de-resultados"

\end_inset

, se comparan los resultados de ambos mediante un breve análisis.
\end_layout

\begin_layout Description
Suposiciones
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Description
No estoy seguro que esta subseccion de suposiciones tenga que ir aca...
 Dado que algunos de los comentarios parecen "postmortem" luego de realizar
 los experimentos, se podria mover la subseccion a la parte de analisis
 (del final) Otra alternativa es mover una version resumida de esto antes
 del parrafo anterior (ver flecha) Otra alternativa es juntar la suposicion
 de los estilos arquitectonicos como aclaracion luego de una subseccion
 que habla del framework Bubble aca (y luego si introducir el ejemplo del
 Market)
\end_layout

\begin_layout Description
--->para mi va al final
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si bien los casos de uso se basan en un mismo estilo arquitectónico subyacente
 (framework de invocación implícita), esto no implica que la herramienta
 
\emph on
DRArch
\emph default
 sea aplicable sólo a este tipo de estilos arquitectónicos, sino que soporta
 tambien otros estilos 
\begin_inset Note Note
status open

\begin_layout Standard
Andres: tales como....
\end_layout

\end_inset

.
 Los casos de estudio seleccionados son sistemas donde la organización estática
 (estructura de paquetes) no tiene un rol relevante en la arquitectura.
 Sin embargo, la naturaleza dinámica de estos sistemas, los hacen atractivos
 para poner a prueba a 
\emph on
DRArch
\emph default
.
\end_layout

\begin_layout Standard
El contar con los expertos que desarrollaron el sistema permitió obtener
 un panorama muy acertado de los elementos arquitectónicos que se deberían
 construir.
 Este hecho permitió que la documentación original del sistema fuera tenida
 en cuenta solamente para realizar comparaciones y asi poder medir la eficiencia
 de la herramienta.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
2- Los casos de estudio, como estan presentados, no muestran mucha informacion
 de como se fueron reconstruyendo las vistas, que limitaciones hubo, que
 cosas el tool pudo reconstruir y cuales no, ...
 ...Algunos cabos "sueltos" mientras leia respecto a esto: 
\end_layout

\begin_layout Standard
[Y] a) no ayuda mucho el hecho de que los 2 casos de estudio se basen en
 el mismo estilo arquitectonico subyacente (Bubble), ya que hay que hacer
 el analisis si lo recuperado es porque esta el Bubble de base y DRArch
 trabaja bien para Bubble, o se puede aplicar a otros tipos de arquitecturas.
 O sea, no estoy diciendo que haya que cambiar los casos de estudio, pero
 si hacer las salvedades, suposiciones y analisis del caso 
\end_layout

\begin_layout Standard
[Y] b) no entendi que muestran las metricas que toman para evaluar cosas
 de los casos de estudio.
 Dado que las metricas me suenan fuertemente inspiradas en el paper de ArchSync,
 no se hasta que punto el "contexto " del ArchSync es extrapolable al DRArch,
\end_layout

\begin_layout Standard
[Y] c) otra cosa que hay que discutir en los casos de estudio es como se
 uso la documentacion original de cada caso de estudio.
 Una opcion es: casi no se uso, y luego de realizar la recuperacion se realizo
 una comparacion entre lo recuperado y lo que decia la documentacion inicial.
 Otra opcion es: se uso la documentacion inicial como una forma de explorar
 mejor el codigo realizar una mejora substancial en la documentacion o entendimi
ento de la arquitectura.
 Either option, se tiene que discutir 
\end_layout

\begin_layout Standard
d) un posible trabajo que yo agregaria en los casos de estudio es recuperar
 las mismas arquitecturas (Market y G2) con otro tool, ej con Shrimp/Creole,
 y hacer una comparacion de cuales son los puentos fuertes y debiles de
 ese tool, y como DRArch mejora eso (especialmente la parte dinamica, interactiv
idad, bla bla)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Framework Bubble
\end_layout

\begin_layout Standard
Market y G2 utilizan un framework basado en invocación implícita llamado
 Bubble\InsetSpace ~

\begin_inset LatexCommand cite
key "CAMPO02"

\end_inset

, donde los componentes principales son: agentes, tareas, sensores y eventos.
 Los agentes representan entidades del dominio y para separa el estado de
 las acciones, se utiliza la noción de tareas.
 La interacción entre los agentes, es realizada a través de eventos que
 ellos mismos producen y reciben.
 Los agentes están asociados a sensores (filtros) que son registrados para
 activarse con determinados eventos o grupos de eventos 
\begin_inset LatexCommand cite
key "Andres2001"

\end_inset

.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-clases-Bubble"

\end_inset

 muestra un diagrama de clases del framework Bubble con las principales
 clases pintadas con color azul y la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Modelo-arquitectónico-del-Market-Bubble"

\end_inset

 muestra un diagrama del modelo arquitectónico del 
\emph on
framework
\emph default
.
 
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Market"

\end_inset

Caso 1: Market
\end_layout

\begin_layout Standard
El comercio electrónico consiste en la compra y venta de productos o de
 servicios a través de sistemas electrónicos como Internet u otras redes
 de computadoras.
 Generalmente estos sistemas son implementados como aplicaciones Web.
 Una gran variedad de comercio se realiza de esta manera, estimulando la
 creación y utilización de innovaciones como la transferencia de fondos
 electrónica, la administración de cadenas de suministro, el marketing en
 Internet, el procesamiento de transacciones en línea, el intercambio electrónic
o de datos, los sistemas de administración del inventario, y los sistemas
 automatizados de recolección de datos.
\end_layout

\begin_layout Standard
Market es un sistema donde compradores (
\emph on
buyers
\emph default
) y vendedores (
\emph on
sellers
\emph default
) son libres de realizar transacciones.
 Para realizar las interacciones, Market se basa en el protocolo 
\emph on
Contract-Net
\emph default
 (CNP)\InsetSpace ~

\begin_inset LatexCommand cite
key "Smith1980"

\end_inset

.
 CNP consiste en la automaticación de la negociación entre compradores y
 vendedores a traves del comercio electrónico.
 El protocolo define dos tipos de agentes, inicializadores y participantes.
 De esta forma, el mercado es un contenedor de agentes en donde compradores
 (participantes) y vendedores (inicializadores) son simples agentes (
\emph on
agents
\emph default
).
 Todos los agentes pueden realizar un conjunto de tareas (
\emph on
tasks
\emph default
) tales cómo: 
\end_layout

\begin_layout Itemize
Realizar un aviso de venta de un producto.
\end_layout

\begin_layout Itemize
Realizar una oferta.
\end_layout

\begin_layout Itemize
Aceptar una oferta.
\end_layout

\begin_layout Itemize
Rechazar una oferta.
\end_layout

\begin_layout Standard
Una tarea esta compuesta por uno o mas procedimientos.
 Las tareas se disparan con condiciones predefinidas, y pueden estar relacionada
s al estado interno del agente o a un evento 
\begin_inset LatexCommand cite
key "Drogoul92"

\end_inset

.
 
\end_layout

\begin_layout Standard
Market es un proyecto de ejemplo para probar el funcionamiento de un framework,
 con unas 40 clases, especificado parcialmente a nivel arquitectónico por
 10 escenarios UCM.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/BubbleCoreClassDiagram.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-clases-Bubble"

\end_inset

Diagrama de clases del framework Bubble.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/MarketModeloConceptual.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Modelo-arquitectónico-del-Market-Bubble"

\end_inset

Modelo arquitectónico Market instanciado por el 
\emph on
framework
\emph default
 Bubble.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La instanciación del 
\emph on
framework
\emph default
 Bubble que realiza Market esta materializada por las siguientes clases:
\end_layout

\begin_layout Itemize
Tareas:
\end_layout

\begin_deeper
\begin_layout Itemize
BidTask: Realiza una oferta.
\end_layout

\begin_layout Itemize
BuyTask: Responsable de realizar una compra.
\end_layout

\begin_layout Itemize
InitializeTimerTask: Comienza el tiempo de una oferta.
\end_layout

\begin_layout Itemize
ProcessOrderTask: Envía el contrato de la transacción.
\end_layout

\begin_layout Itemize
RequestTask: Escucha ofertas de los clientes.
\end_layout

\begin_layout Itemize
SellTask: Realiza la acción de venta.
\end_layout

\begin_layout Itemize
TimerTask: Controla el tiempo de una oferta.
\end_layout

\end_deeper
\begin_layout Itemize
Agentes
\end_layout

\begin_deeper
\begin_layout Itemize
Customer: Clientes interesados en comprar productos.
\end_layout

\begin_layout Itemize
Dealer: Inicializador o vendedor del producto.
\end_layout

\begin_layout Itemize
Timer: Controla el tiempo de la oferta.
\end_layout

\end_deeper
\begin_layout Itemize
Eventos
\end_layout

\begin_deeper
\begin_layout Itemize
MarketAgentEvent: Contenedor de agentes.
\end_layout

\end_deeper
\begin_layout Itemize
Sensores
\end_layout

\begin_deeper
\begin_layout Itemize
CustomerSensor: Eventos relacionados con los compradores.
\end_layout

\begin_layout Itemize
DealerSensor: Eventos relacionados con los vendedores.
\end_layout

\begin_layout Itemize
TimerSensor: Eventos relacionados con el tiempo de las ofertas.
\end_layout

\end_deeper
\begin_layout Standard
La información de la arquitectura del Market se obtuvo por medio de la documenta
ción existente y por medio de los expertos que construyeron el 
\emph on
framework
\emph default
 Bubble y la aplicación.
 La documentación de la arquitectura provee un conjunto de UCMs que nos
 permiten entender el comportamiento del sistema.
 Con el objetivo de poder hacer comparaciones con los resultados obtenidos
 con el 
\emph on
DRArch
\emph default
, en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Market-UCMs"

\end_inset

 se muestran algunos de estos UCMs.
 En el primer caso, el un vendedor realiza una oferta (
\family typewriter
startAction
\family default
 y 
\family typewriter
afferProduct
\family default
) y un cliente recive (
\family typewriter
listenToBids
\family default
) la oferta y la revisa (
\family typewriter
checkPreferences
\family default
).
 En el segundo caso, el cliente realiza un pedido de compra (
\family typewriter
initializeRequest
\family default
 y 
\family typewriter
placeOrder
\family default
), luego el vendedor acepta el pedido (acceptRequest) y lo registra (
\family typewriter
storeRequest
\family default
).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/MarketDiagramasUCM.png
	width 50theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Market-UCMs"

\end_inset

Diagramas UCMs para el proyecto Market
\emph on
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Uso de 
\emph on
DRArch
\end_layout

\begin_layout Standard
Como se mencionó en el capítulo xxx
\begin_inset Note Note
status open

\begin_layout Standard
ENFOQUE????
\end_layout

\end_inset

 es necesario realizar una fase inicial, fase cero, en la que se realizan
 entrevistas con los expertos del sistema (a recuperar) y se reavisa la
 documentación del sistema con el objetivo de llegar a un entendimiento
 común sobre cuáles son los elementos del sistema de interes arquitectónico.
 Es el objetivo de esta fase también que juntos, los expertos del sistema
 y el/los expertos en recuperación, armen las reglas y su agrupación en
 fases, como asi también el orden de evaluación de las mismas.
 En esta fase se recolecta toda la información necesaria para que el experto
 en recuperación pueda tener conocimiento suficiente como para poder aceptar
 o rechazar las sugerencias de DRArch.
\end_layout

\begin_layout Standard
Fase cero
\end_layout

\begin_layout Standard
En el framework Bubble, el comportamiento de los agentes esta definido mediante
 tareas mediante un mecanismo condición-acción.
 Por ejemplo, una tarea es un módulo compuesto por una serie de acciones
 a ser ejecutadas por un agente cuando se cumplen ciertas condiciones.
 De esta forma se ve que la funcionalidad del sistema está organizada alrededor
 de éstas tareas.
\end_layout

\begin_layout Standard
De las entrevistas con los expertos surgieron las siguientes especificaciónes
 de componentes:
\end_layout

\begin_layout Itemize
Todo lo que hereda de la clase Task es un componente.
 El nombre de la clase es el nombre del componente.
 El método run de la tarea se debe asociar a una responsabilidad con el
 mismo nombre de la tarea.
\end_layout

\begin_layout Itemize
\begin_inset LatexCommand label
name "ite:Asociación-Tarea-Evento-1"

\end_inset

Crear una asociación entre un componente tarea y un evento cuando dentro
 de la implementación de la tarea se encuentra la siguiente porción de código:
 new EventIdCondition( EventHierarchyManager.getEventId(...Event.class)));
\end_layout

\begin_layout Itemize
\begin_inset LatexCommand label
name "ite:Asociación-Tarea-Evento-2"

\end_inset

Crear una asociación entre un componente tarea y un evento cuando dentro
 de la ejecucion del método run de la tarea se ejecuta un EventManager.publishEve
nt(anEvent); donde la clase de anEvent es el nombre del componente evento
 que debe ser asociado.
 
\end_layout

\begin_layout Standard
Basado en estas reglas se planeo dividir el analisis en x fases.
 La primera, la fase de recolección es común a todos los procesos de recuperació
n.
 La misma consiste en recolectar la información dinámica y en la instrumentación
 de código.
 El objetivo de la fase siguiente es reducir el espacio de solución haciendo
 foco principalemente en aquellas porciones de código relevantes a la recuperaci
ón.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Poner aca una explicacion del setup inicial de DRArch (ej.
 que conocimiento inicial le tuvieron que cargar), y tambien introducir
 lo que van a hacer a traves de una serie de fases (que vienen luego), asi
 el lector no se pierde ...
 Por ejemplo, hay una serie de reglas de deteccion usadas en la fase de
 invocacion implicita que el lector no tiene idea de donde salieron!
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fase de recolección de información
\end_layout

\begin_layout Standard
Como primera fase, se debe seleccionar el código fuente que se va a incluir
 en el análisis.
 En este caso, utilizaremos todo el código fuente disponible del sistema
 Market.
 Luego, se debe incluir la información dinámica, y para esto, se debe ejecutar
 un caso de uso que represente la funcionalidad principal del sistema.
 
\end_layout

\begin_layout Standard
Un caso de uso típico para este sistema es el de realizar una oferta (
\emph on
bidding
\emph default
)
\begin_inset Note Note
status collapsed

\begin_layout Standard
Como les puse antes, esto require que previamente se haya explicado el protocolo
 de Contract-Net (donde el bidding es una de las fases del protocolo)
\end_layout

\end_inset

.
 Debido a que la aplicación es un ejemplo para utilizar el framework Bubble,
 hay un único punto de entrada al sistema que ejecuta todos los casos de
 uso sin interface de gráfica (modo consola) y sin necesidad de utilizar
 datos de entrada.
 En la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Configuración-del-log"

\end_inset

 se muestra la configuración necesaria para generar el log de ejecución.
 Cabe destacar que para la instrumentación de Market se incrementó el nivel
 de profundidad del snapshot de objetos (sección Level Of Depth Log de la
 figura).
 Esta propiedad que brinda Flabot permitirá obtener la información necesaria
 para la ejecución de las reglas como las descriptas en la sección anterior
 (
\begin_inset LatexCommand ref
reference "ite:Asociación-Tarea-Evento-1"

\end_inset


\begin_inset LatexCommand ref
reference "ite:Asociación-Tarea-Evento-2"

\end_inset

) en las que se necesita acceder a información de los objetos contenidos
 en otra instancia.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/EclipseRunFlabotConfiguration.png
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Configuración-del-log"

\end_inset

Configuración para la generación del log de ejecución en 
\emph on
Eclipse
\emph default
 utilizando 
\emph on
FLAbot.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Todo bien con la figura anterior, pero en ningun momento comentaron que
 es lo que se "instrumento" del codigo de Bubble para generar el log ...
 Pongan algo de eso (porque asumo que no instrumentaron todos los metodos
 del codigo antes y despues)
\end_layout

\end_inset

Luego de generar el log, 
\emph on
DRArch
\emph default
 traduce automáticamente la información del log a la base de conocimientos
 para que se pueda tener en cuenta en el análisis.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Antes de entrar con todas las subsecciones "Fase de ...", explicar de donde
 salen y que es lo que van a hacer...
 (esta explicacion tambien podria ir al inicio de 6.1.1)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fase de estructura de paquetes
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Un poco atravesado el parrafo este.
 Reformular y acortar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Basado en la premisa de que todo sistema se debe dividir en unidades más
 pequeñas, esta fase intenta identificar esas unidades con el objetivo de
 acotar el análisis y hacer foco en aquellas unidades de mayor relevancia.
\end_layout

\begin_layout Standard
De esta forma, se identificaron tres unidades distintas: 
\family typewriter
bubble.core
\family default
, 
\family typewriter
distribution
\begin_inset Note Note
status collapsed

\begin_layout Standard

\family typewriter
Una aclaracion: el paquete distribution es una extension del Bubble, pero
 es "irrelevante" desde el punto de vista de la reconstruccion del Market
 (porque no se usa), asi que en algun lado mas adelante debieran mostrar
 como uds (los reverse engineers) "descartaron" un analisis fino de este
 paquete ...
\end_layout

\end_inset


\family default
 y 
\family typewriter
market
\family default
.
 
\end_layout

\begin_layout Standard
En este punto se volvio a pedir asistencia a los expertos del sistema, quienes
 recomendaron descartar el paquete 
\family typewriter
distribution 
\family default
dado que es irrelevante desde el punto de vista de la reconstrucción de
 Market (no lo usa) dado que es una extensión Bubble.
\end_layout

\begin_layout Subsubsection
\begin_inset LatexCommand label
name "sub:Fase-de-invocación-implicita"

\end_inset

Fase de invocación implícita
\end_layout

\begin_layout Standard
Esta fase esta compuesta por reglas cuyo propósito es descubrir componentes
 y relaciones que puedan ser parte de un framework basado en invocaciones
 implícitas, es decir, detectar los puntos de extensión para el manejo de
 eventos, tareas, agentes, etc.
 Con la división de unidades realizada en la fase anterior, se decidió correr
 esta fase únicamente a los artefactos de código fuente ubicados dentro
 del paquete 
\family typewriter
bubble.core
\family default
, ya que por su nombre y por las clases que lo contienen, se presenta como
 candidato para alojar los componentes principales del framework.
 Las reglas más importantes presentadas por la herramienta 
\emph on
DRArch
\emph default
 se agrupan en las siguientes categorías construidas en base al análisis
 y la información provista por los expertos en la fase cero.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Todo ok, pero de donde salieron estas reglas? quien las define? cuando las
 define (setup, a medida que progresa la reconstrucion)??? Quien cargo conocimie
nto sobre la arquitectura Bubble que le informa a DRArch que puede detectar
 conceptos tales como "manejador de eventos", "agente", etc ...
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
tareas: Este conjunto de reglas tiene como objetivo materializar
 artefactos del código fuente a componentes que representen una tarea.
 Las consultas buscan clases que tengan un nombres clave (
\family typewriter
Task
\family default
, 
\family typewriter
Tarea
\family default
, etc.), que contengan métodos 
\emph on
hook
\emph default
 o abstractos, que alguno de estos métodos sea tenga el nombre 
\family typewriter
run
\family default
, etc.
\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
manejadores\InsetSpace ~
de\InsetSpace ~
eventos: Es complicado reconstruir este tipo de
 componentes, generalmente, son clases que implementan alguna clase con
 el nombre 
\family typewriter
Event\SpecialChar \-
Handler
\family default
, con algún método que tenga como argumento un evento, así como también
 propiedades privadas del tipo listas que contengan eventos.
 Esto se presenta como su\SpecialChar \-
ge\SpecialChar \-
ren\SpecialChar \-
cias y es el arquitecto que debe corroborar
 este tipo de supuestos, aceptando o rechazando cada sugerencia.
 En este tipo de sugerencias es donde la herramienta presenta una de sus
 limitaciones ya que la sugerencia presenta una gran ambiguedad.
\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
agentes: Como dijimos anteriormente, los agentes representan
 entidades del sistema, y este conjunto de reglas intenta descubrir el conjunto
 de clases que se materializan con un componente agente.
\end_layout

\begin_layout Itemize
Relaciones: Las relaciones entre componentes fueron difíciles de reconstruir
 ya que la información que se utilizó fue la que generó el log de ejecución.
 De esta forma, se intentó crear una asociación entre un componente tarea
 y un evento cuando dentro de la ejecución del método 
\family typewriter
run
\family default
 de la tarea se ejecuta la siguiente linea de código:
\begin_inset Note Note
status collapsed

\begin_layout Standard
Esto involucra un conocimiento bastante fino del modelo Bubble y de su implement
acion.
 Por lo tanto, habria que explicar de donde salio esta regla? Una alternativa,
 es decir que la "minaron" en base a entrevistas con los expertos que diseñaron
 el sistema ...
\end_layout

\end_inset


\newline

\family typewriter
EventManager.publishEvent(anEvent);
\family default
 
\newline
Donde la clase 
\family typewriter
anEvent
\family default
 es el nombre del componente evento que debe ser asociado.
 Para saber cuál es el nombre de la clase 
\family typewriter
anEvent
\family default
 en tiempo de ejecución, se utilizan hechos como 
\family typewriter
invocationMethod
\family default
 y 
\family typewriter
snapshot
\family default
 dentro de la consulta que compone la regla.
 Esta regla involcra un conocimiento muy fino del modelo Bubble y su implementac
ión que sólo puede conocerce gracias a las entrevistas realizadas en la
 fase cero.
\end_layout

\begin_layout Standard
El resultado obtenido luego de la ejecución de esta fase es un conjunto
 de diagramas y los más importantes se muestran en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Resultado-de-la-fase-de-invocacion-implicita-market"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/BubbleDiagramasDrarch.png
	width 55theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Resultado-de-la-fase-de-invocacion-implicita-market"

\end_inset

Resultado de la fase de Invocación Implícita
\emph on
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fase de materialización de invocación implícita
\end_layout

\begin_layout Standard
A diferencia de la fase anterior, esta fase esta compuesta por reglas cuyo
 propósito es descubrir componentes y relaciones que estén materializados
 con invocaciones implícitas, es decir, implementaciones de manejo de eventos,
 tareas, etc.
 De esta forma, se agruparon las reglas más importantes presentadas por
 la herramienta 
\emph on
DRArch
\emph default
 en las siguientes categorías:
\begin_inset Note Note
status collapsed

\begin_layout Standard
Idem comentarios sobre las reglas de la subseccion anterior
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
tareas: Este conjunto de reglas tiene como objetivo materializar
 artefactos del código fuente a componentes que representen una tarea.
 Algunas consultas sugieren ma\SpecialChar \-
te\SpecialChar \-
ria\SpecialChar \-
li\SpecialChar \-
zar componentes con las clases que
 extienden de alguna clase 
\family typewriter
Task
\family default
 que contenga un método 
\family typewriter
run()
\family default
 implementado.
\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
manejadores\InsetSpace ~
de\InsetSpace ~
eventos: Este conjunto de reglas tiene como objetivo
 materializar artefactos del código fuente a componentes que representen
 a contenedores de eventos.
\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
Agentes: Las consultas que pertenecen a las reglas de este conjunto
 su\SpecialChar \-
gie\SpecialChar \-
ren que las clases que extienden de la clase 
\family typewriter
Agent
\family default
 sean componentes.
\end_layout

\begin_layout Standard
Uno de los diagramas generados luego de la ejecución de esta fase se muestra
 en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Resultado-de-la-fase-de-materializacion-i-e-market"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/MarketDiagramasDrarch.png
	width 55theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Resultado-de-la-fase-de-materializacion-i-e-market"

\end_inset

Resultado de la fase de Materialización de Invocación Implícita
\emph on
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fase de instanciación
\end_layout

\begin_layout Standard
Al termino de la ejecución de esta fase se obtuvieron aquellos componentes
 comprometidos con la ejecución del caso de uso que forman parte de la instancia
ción del 
\emph on
framework
\emph default
 Bubble para el dominio del Market.
 Las consultas realizadas en esta fase están muy relacionadas al caso de
 uso que se utilizó para generar el log de ejecución.
 Las responsabilidades de los componenetes estan mapeadas a métodos.
 Los métodos corresponden a las clases que están asociadas con cada componente.
 Esto es de gran utilidad ya que una de las informaciones que provee el
 log de ejecución, indica qué métodos fueron ejecutados y en qué orden.
 Así, es posible realizar consultas que sugieran un 
\emph on
path
\emph default
 de ejecución que recorra las responsabilidades de cada componente reconstruido.
 A continuación se muestra en detalle una de las consultas que se utilizó
 para obtener el 
\emph on
path
\emph default
 de ejecución:
\end_layout

\begin_layout Quote

\family typewriter
\size small
executedMothod(?Order, ?Method, ?Type, ?Value), 
\newline
child(?Class, ?Method),
 
\newline
materialization(?Component, ?Package, ?Class), 
\newline
component(?Component), 
\newline
responsib
ility(?Responsibility),
\newline
hasResponsibility(?Component, ?Responsibility),
\newline
name(?Meth
od, ?Responsibility)
\end_layout

\begin_layout Standard
Esta consulta retorna una lista de las responsabilidades ejecutadas respetando
 orden de ejecución.
 El resultado obtenido luego de la ejecución de esta fase se muestra en
 la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Resultado-de-la-fase-de-instanciacion-market"

\end_inset

, en donde un cliente (
\family typewriter
Customer
\family default
) realiza un pedido (
\family typewriter
Request
\family default
) para procesar una compra y el vendedor (
\family typewriter
Dealer
\family default
) es quién recive ese pedido.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/MarketDiagramasUCMDrarch.png
	width 55theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Resultado-de-la-fase-de-instanciacion-market"

\end_inset

Resultado de la fase de Instanciación del Market
\emph on
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Uso de Structure 101
\end_layout

\begin_layout Standard
Como se mencionó en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Trabajos-relacionados"

\end_inset

, Structure 101 es una herramienta de análisis estático de código orientada
 al análisis de estructura (diseño, arquitectura y packaging).
\end_layout

\begin_layout Standard
El proceso de recuperación de Structure 101 comienza seleccionando el archivo
 .jar que contiene el 
\emph on
bytecode 
\emph default
de la aplicación que se quiere analizar y automáticamente la herramienta
 crea las perspectivas (vistas) de la arquitectura.
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Structure 101 - Estructura de paquetes"

\end_inset

 se muestra la estructura de paquetes de la aplicación y en la figura 
\begin_inset LatexCommand ref
reference "fig:Structure101-Buble"

\end_inset

, el primer nivel de explosion del paquete core.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/bubbleStructure101.png
	width 50text%

\end_inset


\begin_inset Note Note
status open

\begin_layout Standard
Hay que decir en algun lado (por ahi en el texto) que son las flechas y
 numeritos
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Structure 101 - Estructura de paquetes"

\end_inset

Structure 101 - Bubble-Market Estructura de paquetes
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/bubble_core_structure101.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Esta es una ingenieria reversa "tradicional" del codigo, pero tengo entendido
 que Structure101 permite recuperar vistas "mas interesantes" para la comparacio
n! Por ej.
 hay una que muestra la estructura de "layers" y "salteo de layers" y otra
 que permite identificar tambien "fat", calculo que este tipo de vistas
 son mas utiles y significativas para su comparacion con DRArch (otherwise,
 me estan tirando abajo a proposito al Structure101 :-))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Structure101-Buble"

\end_inset

Structure101 - Bubble core
\begin_inset Note Note
status open

\begin_layout Standard
En general, es importante "interpretar" para el lector lo que resulta de
 cada diagrama "reconstruido" (tanto con DRArch como con Structure101)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como se mencionó con anterioridad, la herramienta cubre aspectos estructurales
 del sistema en diversas perspectivas
\begin_inset Note Note
status open

\begin_layout Standard
Aja, que perspectivas son estas? (comentar las que serian utiles para Market)
\end_layout

\end_inset

.
 Para el caso analizado, Market, se puede observar que se toma la estructura
 de paquetes como base del análisis y arma el grafo de dependencias basado
 en las relaciones de uso y de "
\emph on
imports
\emph default
" de otros paquetes.
 Para el paquete example.market, bajo la perspectiva DSM, figura 
\begin_inset LatexCommand ref
reference "fig:Structure-101-Market"

\end_inset

, se pueden observar las clases que lo componen y el grado de acoplamiento
 con sus pares.
 Un asistente de la herramienta resalta aquellos que tienen mayor cantidad
 de dependencias y los resalta como componentes.
 Debajo de la matriz se puede ver la misma vista en forma de grafo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/bubble.examples.marketDSMStructure101.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Structure-101-Market"

\end_inset

Structure 101 - Market
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:G2"

\end_inset

Caso 2: G2
\end_layout

\begin_layout Standard
El sistema G2 se basa en la arquitectura cliente-servidor de tres bandas
 (
\emph on
three-tier
\emph default
) que se muestra en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Arquitectura-de-G2"

\end_inset

.
 El usuario interactúa por medio de un 
\emph on
browser
\emph default
 y envía solicitudes que son interceptadas por un servidor 
\emph on
web
\emph default
 para ser delegadas al servidor G2 en la segunda banda, correspondiente
 a la lógica del negocio, por intermedio del componente GateKeeper.
 Esta banda está implementada mediante la instanciación del framework 
\emph on
Bubble
\emph default
 
\begin_inset LatexCommand cite
key "CAMPO02"

\end_inset

, donde la funcionalidad se encuentra organizada en 
\emph on
tareas
\emph default
 que son asignadas a diferentes 
\emph on
agentes reactivos
\emph default
.
 GateKeeper traduce cada solicitud para activar a los agentes encargados
 de ejecutar las tareas correspondientes.
 Las tareas relacionadas con la administración del modelo del negocio normalment
e interactúan con el componente de persistencia para consultar o alterar
 los datos relevantes del repositorio de datos, en la tercer banda.
 
\end_layout

\begin_layout Standard
G2 es un proyecto mediano de aproximadamente 900 clases, especificado parcialmen
te a nivel arquitectónico por 34 escenarios UCM.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/G2ThreeTier.png
	width 90text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Arquitectura-de-G2"

\end_inset

Arquitectura de G2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los siguientes casos de uso sobre el sistema G2 se efectuaron sobre el subsistem
a de la segunda banda del modelo 
\emph on
three
\emph default
-
\emph on
tier
\emph default
, por ser éste el más complejo.
\end_layout

\begin_layout Standard
Con la colaboración de los expertos que desarrollaron el sistema G2, en
 la documentación del sistema se encontraron digramas de componentes y diagramas
 de UCMs.
 Estos diagramas resultan de mucha utilidad para poder comparar los resultado
 obtenidos por 
\emph on
DRArch
\emph default
.
 En la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-componentes-g2-eliminar-usuario"

\end_inset

 se muestra un diagrama de componenetes destacando las principales responsabilid
ades de cada uno y sus relaciones.
 El componente 
\family typewriter
GateKeeper
\family default
 se comunica con el dominio de la aplicación (
\family typewriter
UserManager
\family default
) y con la presentación (
\family typewriter
HTMLResponseGenerator
\family default
) mientras que el componente 
\family typewriter
UserDBView
\family default
 sólo se comunica con el dominio de la aplicación (
\family typewriter
UserManager
\family default
).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
De nuevo, "interpretar" los diagramas para el cristiano comun, y tambien
 aclarar que este "entendimiento inicial" del sistema lo lograron hablando
 con los expertos que diseñaron G2 (juan carlino, alvaro, others...)
\end_layout

\begin_layout Standard
...Luego, en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-UCMs-g2-eliminar-usuario"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/RemoveUserComponent.png
	width 40theight%

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-componentes-g2-eliminar-usuario"

\end_inset

Diagrama de componentes original para el caso de uso 
\emph on
removeUser
\emph default
 de la aplicación G2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un escenario donde pueden verse la implementación del 
\emph on
framework
\emph default
 Bubble en el sistema G2 es el caso de uso 
\emph on
removeUser
\emph default
 (utilizado más tarde para ejercitar la herramienta).
 Aquí un usuario administrador envía por medio de su 
\emph on
browser
\emph default
 una solicitud de eliminar a otro usuario del sistema, siempre que sus permisos
 lo permitan.
 Cuando esta solicitud llega al sistema por medio del 
\family typewriter
GateKeeper
\family default
, se activan los agentes encargados de eliminar a un usuario del modelo.
 Una vez que el agente asignado detecta esta señal, invoca a la tarea de
 eliminación, representada por la responsabilidad UCM 
\emph on
removeUser
\emph default
 (ver figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-UCMs-g2-eliminar-usuario"

\end_inset

).
 Mas adelante se eliminan los registros relacionados del repositorio de
 datos, como lo indica la responsabilidad UCM 
\emph on
delete\SpecialChar \-
User\SpecialChar \-
From\SpecialChar \-
DB
\emph default
 y finalmente se retorna a la página con un listado actualizado de los usuarios;
 representado por la secuencia de activación de responsabilidades 
\emph on
list\SpecialChar \-
Users
\emph default
, 
\emph on
generate\SpecialChar \-
HTML\SpecialChar \-
Response
\emph default
 y 
\emph on
send\SpecialChar \-
Response
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/RemoveUserUCM.png
	width 45theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Este diagrama me parece que es muy escueto, pueden poner al menos 2 casos
 de uso ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-UCMs-g2-eliminar-usuario"

\end_inset

Diagrama de UCMs original para el caso de uso 
\emph on
removeUser
\emph default
 de la aplicación G2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Uso de Drarch
\begin_inset LatexCommand label
name "sub:G2-Caso-1"

\end_inset


\end_layout

\begin_layout Standard
Con el objetivo de poder reconstruir uno de los aspectos más importantes
 
\begin_inset Note Note
status open

\begin_layout Standard
Lo mismo que el otro comentario, cual es el "aspecto mas importante"? (no
 lo nombran)
\end_layout

\end_inset

de la arquitectura del sistema G2, en este caso de estudio se utilizó la
 herramienta 
\emph on
DRArch
\emph default
 teniendo en cuenta de que la funcionalidad del sistema esta organizada
 en 
\emph on
tareas 
\emph default
y
\emph on
 eventos.
 
\emph default
Como se mencionó en la sección anterior, este sistema esta basado en el
 framework 
\emph on
Bubble 
\emph default
de la misma forma que el sistema analizado anteriormente con lo cual se
 reutilizarán las fases de análisis implementadas en el análisis anterior
 para recuperar la instanciación del 
\emph on
framework
\emph default
.
 Pos\SpecialChar \-
te\SpecialChar \-
rior\SpecialChar \-
mente, se irán descubriendo todos aquellos componentes que interactúan
 con los componentes del 
\emph on
framework
\emph default
.
 
\end_layout

\begin_layout Subsubsection
Fase de recolección de información
\end_layout

\begin_layout Standard
Como primera fase, se debe seleccionar el código fuente que se va a incluir
 en el análisis.
 En este caso, también utilizaremos todo el código fuente disponible del
 sistema G2.
 Luego, se debe incluir la información dinámica, y para esto, se debe ejecutar
 un caso de uso que represente la funcionalidad principal del sistema.
 El escenario seleccionado fue 
\emph on
removeUser
\emph default
 descripto en la sección anterior.
\end_layout

\begin_layout Standard
La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Instrumentación-de-la"

\end_inset

 muestra la interfaz gráfica del sistema G2 durante su ejecución instrumentada,
 lista para proceder con la eliminación de un usuario.
 A su vez puede observarse un panel de control que el arquitecto emplea
 para decidir el momento en que las acciones instrumentadas deben registrarse
 en el log de ejecución.
 
\end_layout

\begin_layout Standard
Luego de la ejecución del escenario sobre el sistema instrumentado, el log
 de ejecución resultante es transformado
\emph on
 
\emph default
a hechos al estilo 
\emph on
Prolog
\emph default
 por el componente 
\emph on
TraceLog Analizer
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/listadoUsuariosFlabot.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Instrumentación-de-la"

\end_inset

Instrumentación de la aplicación G2 durante el caso de uso “eliminar usuario”
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una vez finalizada la fase de recolección, se continúa con la ejecución
 del resto de las fases.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Mismo comentario que para el Market: 
\end_layout

\begin_layout Standard
- de donde salen estas fases? 
\end_layout

\begin_layout Standard
- ya se tenia knowledge pre-compilado sobre el estilo arquitectonico de
 invocacion implicita (what about el 3-tier que se usa en G2) 
\end_layout

\begin_layout Standard
- Ya se tenia info precompilada de posibles mapeos (para la fase de materializac
ion)? 
\end_layout

\begin_layout Standard
- Ya se tenia info para la fase de instanciacion?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fase de invocación implícita 
\end_layout

\begin_layout Standard
Al igual que para el caso de estudio anterior, esta fase tiene como propósito
 principal descubrir aquellos componentes y relaciones que pertenecen al
 framework Bubble.
 Las reglas 
\emph on
DRArch
\emph default
 que forman esta fase están encargadas de materializar artefactos de códigos
 fuentes que representen punto de extensión a tareas, agentes y aquellos
 encargados del manejo de eventos.
\end_layout

\begin_layout Standard
Al estar basados en el mismo 
\emph on
framework
\emph default
 que el caso de estudio anterior, se reutilizaron las mismas reglas.
 En fases posteriores se detectan artefactos arquitectónicos pertenecientes
 al 
\emph on
framework
\emph default
 de invocación implícita.
 De esta forma, se refinan el proceso incorporando nuevas reglas para esta
 fase.
 Es por eso que la fase de invocación implícita se ejecuta nuevamente con
 un conjuto de reglas refinadas.
\end_layout

\begin_layout Subsubsection
Fase de materialización
\end_layout

\begin_layout Standard
De nuevo, se reutilizaron las mismas reglas que en el caso de estudio anterior.
 Una vez in\SpecialChar \-
di\SpecialChar \-
vi\SpecialChar \-
dua\SpecialChar \-
li\SpecialChar \-
za\SpecialChar \-
dos los puntos de extensión del 
\emph on
framework
\emph default
 se buscaron los componentes específicos del dominio de G2.
 Estos componentes responden a la instanciación del framework para el caso
 específico del sistema G2.
 De esta forma, algunos de los componentes que se detectaron basados en
 la ejecución de 
\emph on
DRArch
\emph default
 con el caso de uso 
\emph on
removeUser 
\emph default
son:
\end_layout

\begin_layout Standard

\family typewriter
RemoveUserTask
\family default
, 
\family typewriter
ListUserTask
\family default
 y 
\family typewriter
StaticHTMLStaticTask
\family default
, etc.
\end_layout

\begin_layout Standard
Al termino de la ejecución de esta fase se cuenta con la base de conocimientos
 cargada con la información específica del framework y su instanciación
 en el dominio de G2.
 Fases posteriores irán trabajando sobre esta base de conocimiento general
 y la irán enriqueciendo con información que el arquitecto considere relevante
 a las fases posteriores.
 Tambén se cuenta con los diagramas generados que permiten observar parcialmente
 la reconstrucción de la arquitectura del sistema.
\end_layout

\begin_layout Subsubsection
Fase de instanciación
\end_layout

\begin_layout Standard
Durante esta fase se trabajó sobre el caso de uso utilizado para ejercitar
 la herramienta, RemoveUser.
 Para elevar el nivel de detalle de la información recuperada se buscó seguir
 el 
\emph on
path
\emph default
 de ejecución e ir individualizando a lo largo de éste, cuáles son las responsab
ilidades que se ejecutaron.
 Dado que es una aplicación 
\emph on
multithread
\emph default
 no es recomendable realizar un seguimiento de la ejecución a nivel de 
\emph on
thread
\emph default
.
 En lugar de esto se hizo a nivel de datos.
 Es decir, un elemento es compartido y/o utilizado en la comunicación de
 cada uno de los distintos 
\emph on
threads
\emph default
 que componen la ejecución del sistema.
 En el caso de G2 y mas específicamente de Bubble estos elementos son los
 eventos.
 Así, siguiendo el rastro de un evento a lo largo de la ejecución del caso
 de uso, se encontró un nuevo tipo de componente que no había sido descubierto
 en fases anteriores y que pertenece al 
\emph on
framework
\emph default
 Bubble: los Sensores.
 Las fases anteriores no descibrieron el nuevo componente debido a que se
 utilizó un caso de uso simple y por esto han quedado fuera del análisis
 dinámico varios eventos de bajo nivel.
 Luego, la riqueza del caso de uso utilizado para ejercitar 
\emph on
DRArch
\emph default
 con el sistema G2 facilitó la detección de dicho componente.
 Con esta nueva información, se procedió a incorporar nuevas reglas a la
 fase de invocación implícita que descubrieran estos eventos de bajo nivel
 y se re-ejecutaron las fases anteriores.
\end_layout

\begin_layout Standard
Al termino de la ejecución de esta fase se obtuvieron aquellos componentes
 comprometidos con la ejecución del caso de uso que forman parte de la instancia
ción del framework Bubble para el dominio de G2.
\end_layout

\begin_layout Subsubsection
Fase de reconocimiento de intermediarios
\end_layout

\begin_layout Standard
Una vez reconocidos los componentes que forman parte de la implementación
 del 
\emph on
framework
\emph default
, se pretendió encontrar todos aquellos componentes que interactúan con
 los elementos del 
\emph on
framework
\emph default
.
 De esta forma se descubrieron los componentes GateKeeper y UserDBView encargado
s de activar los agentes que ejecutan las tareas y de abstraer el acceso
 a la capa de persistencia de datos respectivamente.
\end_layout

\begin_layout Standard
Las figuras 
\begin_inset LatexCommand ref
reference "fig:Diagrama-de-componentes-DRArch-remove-user"

\end_inset

 y 
\begin_inset LatexCommand ref
reference "fig:Diagrama-UCM-DRArch-remove-user"

\end_inset

 reflejan como ha resultado la reconstrucción de la arquitectura para el
 sistema G2 basados en el caso de uso 
\emph on
removeUser
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Recovered G2 Components.png
	width 50theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Interpretar la figura para el usuario!!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-componentes-DRArch-remove-user"

\end_inset

Diagrama de componentes generado por 
\emph on
DRArch
\emph default
 para el caso de uso 
\emph on
removeUser
\emph default
 de la aplicación G2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Recovered G2 UCM.png
	width 65theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Interpretar la figura para el usuario!!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-UCM-DRArch-remove-user"

\end_inset

Diagrama UCM generado por 
\emph on
DRArch
\emph default
 para el caso de uso 
\emph on
removeUser
\emph default
 de la aplicación G2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Uso de Structure 101
\end_layout

\begin_layout Standard
De la misma forma que con Market, se utilizó Structure101 para analizar
 el sistema G2.
\end_layout

\begin_layout Standard
Dado que Market es un sistema pequeño, se pudieron detectar facilmente las
 extensiones del framework Bubble como son tareas y eventos.
 En el caso de G2, estas extensiones del 
\emph on
framework
\emph default
 se encuentran desperdigadas a lo largo de toda la estructura de paquetes
 del proyecto.
 La forma en que Structure 101 trabaja es inherentemente estructural por
 lo que el gran aporte que esta herramienta ofrece en este caso es la comprensió
n de la forma en que está organizado el sistema y como así tambien permite
 visualizar las dependencias entre paquetes.
\end_layout

\begin_layout Standard
A nuestro entender, G2 al igual que Market son sistemas donde lo más importante
 es saber cómo funcionan.
 Así, las vistas estructurales no aportan el conocimiento necesario sobre
 su funcionamiento como si lo harían representaciones UCMs o diagramas UML
 de secuencia.
\end_layout

\begin_layout Standard
La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:G2-Structure101"

\end_inset

 muestra las dependencias entre los principales módulos del sistema G2.
 En ella se puede ver el gran acoplamiento con el módulo bubble y marcadas
 en rojo, las dependencias circulares entre algunos módulos.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/G2_structure101.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Mismos comentarios sobre mostrar instead "vistas interesantes" que puede
 proveer Structure101 (y que por ahi DRArch no tiene), cosa de que el analisis
 al final sea mas fair :-)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:G2-Structure101"

\end_inset

G2 analizado por Strucutre101
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Análisis-de-resultados"

\end_inset

Análisis de resultados
\end_layout

\begin_layout Standard
Los casos de prueba desarrollados en el presente capítulo ponen bajo análisis
 dos sistemas de proporciones diferentes y con un mismo 
\emph on
framework
\emph default
 subyacente (Bubble), el cuál es uno de los objetivos a reconstruir.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
Antes de empezar a discutir las metricas, es importante poner upfront los
 criterios (o cosas que se busco analizar) con DRArch en los 2 casos de
 estudio.
 Veo 2 criterios (al menos): 
\end_layout

\begin_layout Standard
1) DRArch permite recuperar arquitecturas de sistemas complejos --> aca
 juega la metrica de complejidad ciclomatica 
\end_layout

\begin_layout Standard
2) DRArch da buenas sugerencias porque complementa la info estatica con
 info dinamica --> aca entra a jugar la metrica que uds llaman "eficiencia"
 (ver mis comentarios sobre esto)
\end_layout

\begin_layout Standard
Se entiende la idea de como "justificar" las metricas que usaron?
\end_layout

\end_inset

Uno de los criterios utilizados para realizar el análisis de los resultados
 obtenidos se basa en recuperar arquitecturas de sistemas complejos.
 Otro, se basa en las buenas sugerencias que proporciona la herramienta
 
\emph on
DRArch
\emph default
 porque complementa la información estática, la dinámica y la experiencia
 de los que desarrollaron el sistema.
\end_layout

\begin_layout Standard
Si bien es importante tener en cuenta la cantidad de clases como medida
 de tamaño de un sistema, en nuestro caso es importante determinar cuáles
 de estas clases juegan un papel importante en la materialización de la
 arquitectura.
\end_layout

\begin_layout Standard
En el análisis se incluye el concepto de exactitud, ya que es de utilidad
 medir qué tan cerca del valor real se encuentra el valor medido.
 Por ejemplo, si una porción de la arquitectura original del sistema muestra
 15 componentes, y la reconstrucción muestra 10, la exactitud describe la
 proximidad del valor medido (10 artefactos arquitectónicos) al valor real
 (15 artefactos arquitectónicos).
 Cuanto más cerca están las medidas a un valor aceptado, más exacto es un
 sistema.
 En la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Fórmula-de-Exactitud"

\end_inset

 se muestra la fórmula utilizada para calcular la exactitud.
 Es por esto que en la fase de recolección de información de los casos de
 estudio, los casos de uso que se seleccionaron para generar el log de ejecución
, se basaron en los escenarios UCM disponibles en la documentación arquitectura
 de cada proyecto.
 De esta forma, es posible medir la exactitud del 
\emph on
DRArch
\emph default
 comparando los componentes descubiertos sobre los que debería haber descubierto.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[andres]Por esto pregunto si su concepto de eficiencia es lo mismo que "precisio
n" ...
 (recuerden que Daniela viene de este area)
\end_layout

\begin_layout Standard
Precisión se refiere a la dispersión del conjunto de valores obtenidos de
 mediciones repetidas de una magnitud.
 Cuanto menor es la dispersión mayor la precisión.
 Una medida común de la variabilidad es la desviación estándar de las mediciones
 y la precisión se puede estimar como una función de ella.
\end_layout

\begin_layout Standard
Exactitud se refiere a que tan cerca del valor real se encuentra el valor
 medido.
 En términos estadístico, la exactitud está relacionada con el sesgo de
 una estimación.
 Cuanto menor es el sesgo más exacta es una estimación.
\end_layout

\begin_layout Standard
Cuando expresamos la exactitud de un resultado se expresa mediante el error
 absoluto que es la diferencia entre el valor experimental y el valor verdadero.
\end_layout

\begin_layout Standard
Analogías útiles [editar]
\end_layout

\begin_layout Standard
Ejemplo 1
\end_layout

\begin_layout Standard
Varias medidas son como flechas disparadas hacia un objetivo.
 La exactitud describe la proximidad de las flechas al centro del objetivo.
 Las flechas que impactaron más cerca del centro se consideran más exactas.
 Cuanto más cerca están las medidas a un valor aceptado, más exacto es un
 sistema.
\end_layout

\begin_layout Standard
La precisión, en este ejemplo, es el tamaño del grupo de flechas.
 Cuanto más cercanas entre sí estén las flechas que impactaron el objetivo,
 más preciso será el sistema.
 Hay que notar que el hecho de que las flechas estén muy cercanas entre
 sí es independiente al hecho que estén cerca del centro del objetivo.
 En sí, se puede decir que la precisión es el grado de repetibilidad del
 resultado.
 Se podría resumir que exactitud es el grado de veracidad, mientra que precisión
 es el grado de reproductibilidad.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/FormulaExactitud.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Fórmula-de-Exactitud"

\end_inset

Fórmula de Exactitud para Artefactos Arquitectónicos
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otra de las métricas que se incluye en el análisis es la Complejidad Ciclomática
 (
\emph on
Cy\SpecialChar \-
clo\SpecialChar \-
ma\SpecialChar \-
tic Com\SpecialChar \-
plexi\SpecialChar \-
ty
\emph default
) ya que es una métrica del software que proporciona una medición cuantitativa
 de la complejidad lógica de un programa.
 Es una de las métricas de software más am\SpecialChar \-
plia\SpecialChar \-
men\SpecialChar \-
te aceptada, ya que ha
 sido concebida para ser independiente del lenguaje.
 Se basa en el diagrama de flujo determinado por las estructuras de control
 de un determinado código.
 De dicho análisis se puede obtener una medida cuantitativa de la complejidad
 del sistema.
 En la tabla\InsetSpace ~

\begin_inset LatexCommand ref
reference "tab:Eficacia-del-DRArch"

\end_inset

 se muestran los resultados obtenidos por la herramienta Cobertura\InsetSpace ~

\begin_inset LatexCommand cite
key "Cobertura"

\end_inset

 de la complejidad obtenida para el proyecto Market y el G2.
\end_layout

\begin_layout Standard
En el caso de Market, 
\emph on
DRArch 
\emph default
detectó un 78% de los artefactos arquitectónicos pertenecientes al 
\emph on
fremework
\emph default
 Bubble, mientras que en el G2, la exactitud fue del 92%.
 Esto quiere decir que las modificaciones realizadas a las reglas asociadas
 a Bubble son válidas ya que la exactitud mojoró luego del refinamiento.
 La Tabla\InsetSpace ~

\begin_inset LatexCommand ref
reference "tab:Eficacia-del-DRArch-parcial"

\end_inset

 muestra la exactitud de los artefactos arquitectónicos (componentes, relaciones
 y responsabilidades) del Market y del G2.
 La cantidad de artefactos arquitectónicos esperados se calculó teniendo
 en cuenta la documentación original.
 Por ejemplo, en uno de los diagramas que describe el 
\emph on
framework
\emph default
 Bubble se muestran 4 componentes (valor esperado) entonces la reconstrucción
 debería aproximarse a esos 4 componentes (valor obtenido).
 Los mismos resultados están representados en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Eficacia-entre-los-artefactos"

\end_inset

 en donde claramente se observa que la diferencia entre las barras pares
 de cada proyecto es menor para el proyecto G2.
 Esto significa que el margen de error es mayor en el proyecto Market.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features>
<column alignment="left" valignment="middle" rightline="true" width="2in">
<column alignment="center" valignment="middle" leftline="true" width="0.9in">
<column alignment="center" valignment="middle" leftline="true" width="0.7in">
<column alignment="center" valignment="middle" leftline="true" width="0.8in">
<column alignment="center" valignment="middle" leftline="true" width="0.7in">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Market.bubble
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Market
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
G2.bubble
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
G2
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# componentes arquitectónicos que se deben reconstruir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# componentes arquitectónicos reconstruidos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# relaciones arquitectónicos que se deben reconstruir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# relaciones arquitectónicos reconstruidos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# responsabilidades arquitectónicos que se deben reconstruir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# responsabilidades arquitectónicos reconstruidos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Promedio de la exactitud 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0,78
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0,67
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0,92
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1,21
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Eficacia-del-DRArch-parcial"

\end_inset

Exactitud por artefactos arquitectónicos del 
\emph on
DRArch
\emph default
 en los proyectos Market y en G2.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
La pregunta sobre que tan fair es el analisis para Structure101: - Porque
 no incluir tambien en la tabla la "eficiencia" de Structure101, para hacer
 las comparaciones mas "jugosas"????
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/CasosDeEstudioEficacia.PNG
	width 50theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Eficacia-entre-los-artefactos"

\end_inset

Eficiencia entre los distintos artefactos arquitectónicos para los proyectos
 Market y G2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Hace falta esta figura??? 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/CasosDeEstudioEficaciaMejorada.PNG
	width 40theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Mejora-de-la-Eficacia"

\end_inset

Mejora de la eficiencia luego de la incorporación de nuevas reglas.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para poder darnos cuentas del impacto que tiene la complejidad ciclomática
 de los proyectos en la eficiencia del 
\emph on
DRArch
\emph default
, se realizó una nueva ejecución de las fases del sistema G2 con el mismo
 conjunto de reglas que se usaron para el proyecto Market.
 Es decir, no se utilizaron las reglas mejoradas que se detectaron durante
 la reconstrucción del G2.
 Un resumen de estos índices puede verse en la Tabla\InsetSpace ~

\begin_inset LatexCommand ref
reference "tab:Eficacia-del-DRArch"

\end_inset

.
 En gráfico de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Eficiencia-vs.-Complejidad"

\end_inset

 se pueden observar estos índices.
 La primer conclusión que puede derivarse de estos valores es que cuanto
 menos complejidad tenga el sistema, más eficiente es la reconstrucción
 arquitectónica que realiza la herramienta 
\emph on
DRArch
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features>
<column alignment="left" valignment="top" rightline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Market
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
G2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
G2 (sin mejora)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# total de clases
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
~40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
~1100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
~1100
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# clases con mapeo arquitectónico
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
98
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
98
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# artefactos arquitectónicos que se debe reconstruir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
87
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
42
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
42
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# artefactos arquitectónicos reconstruidos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
62
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
42
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
39
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
complejidad ciclomática
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1,672
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1,45
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1,45
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
% Exactitud
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
71%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
100%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
92%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Mismos comentarios que para Tabla 6.1 arriba: - como se determino lo que
 "se debe reconstruir"? - como se calcularo el & eficiencia? - porque no
 se pueden incluir los resultados de Structure101 en la tabla?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Eficacia-del-DRArch"

\end_inset

Exactitud total del 
\emph on
DRArch
\emph default
 en los proyectos Market y en G2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Otro aspecto importante a analizar en un asistente es la "cantidad de conocimien
to" (o el esfuerzo) para hacer el setup del tool al principio, para que
 luego pueda dar "sugerencias utiles" al usuario.
 Discutir este punto en el analisis please...
\end_layout

\begin_layout Standard
[todo] ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ComplejidadVsEficiencia.PNG
	width 55theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Eficiencia-vs.-Complejidad"

\end_inset

Exactitud vs.
 Complejidad
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es importante mencionar el esfuerzo realizado para hacer el 
\emph on
setup 
\emph default
inicial de la herramienta 
\emph on
DRArch
\emph default
 ya que esto es fundamental para que las sugerencias propuestas por el asistente
 sean útiles para el usuario.
 El 
\emph on
setup 
\emph default
de la herramienta significa realizar entrevistas con los expertos del sistema
 y crear las reglas necesarias para comenzar con el proceso de reconstrucción.
 En promedio (entre G2 y Market), este 
\emph on
setup 
\emph default
requirió un esfuerzo de 24 horas/hombre aproximadamente.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Dar una idea de cuantos hechos Prolog se debieron almacenar y como esto
 puede haber afectado la inferencia (o sea, la escalabilidad del enfoque
 DRArch, que seria un tradeoff a sus buenas capacidades de asistencia)
\end_layout

\end_inset

El haber utilizado 
\emph on
Prolog
\emph default
 para la implementación del componente 
\emph on
Rule Model
\emph default
, si bien brinda flexibilidad a la hora de agregar o modificar reglas, acarrea
 los problemas típicos en los lenguajes interpretados.
 Para un sistema como el Market, que sólo posee 40 clases, la cantidad de
 hechos que se necesitan para representar el código fuente supera los 100.000
 hechos.
 También es necesario tener en cuenta la cantidad de hechos que genera la
 representación del log de ejecución.
 Esta cantidad aumenta a medida que se ejecutan los casos de uso instrumentados.
 Esto causa un problema de escalabilidad y representa un tradeoff a las
 buenas capacidades de asistencia del 
\emph on
DRArch
\emph default
.
 Por otro lado, la ejecución de una aplicación instrumentada es cada vez
 más lenta a medida que crece la cantidad de puntos que están siendo inspecciona
dos.
 Asimismo, la memoria y el procesamiento requeridos para el análisis de
 los logs de bajo nivel crece según la naturaleza del caso de uso que esta
 siendo analizado.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
El analisis es bastante superficial :-( Un aspecto a tener en cuenta es
 que uds recuperaron solo "algunos casos de uso" que se reconstruyeron como
 UCMs, porque se suponia que eran los relevantes al estudio ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En resumen, las pruebas realizadas sobre ambos proyectos revelaron la importante
 asistencia que significa el uso de 
\emph on
DRArch
\emph default
 en el proceso de reconstrucción.
 Por otro lado, la precisión de la herramienta se ve comprometida por la
 complejidad de cada proyecto y por las reglas seleccionadas para realizar
 la reconstrucción.
 Éste último índice irá en aumento a medida que se refinen las reglas y
 se agregue información a la base de conocimiento.
 Un aspecto a tener en cuenta es que se recuperaron sólo los casos de uso
 relevantes y se reconstruyeron como UCMs.
\end_layout

\begin_layout Standard
Adicionalmente, pudo notarse que la herramienta Structure 101, si bien es
 muy atractiva en terminos visuales y de navegación de la información, está
 destinada a resolver problemas de erosión arquitectónica.
 
\begin_inset Note Note
status open

\begin_layout Standard
El analisis que hacen es muy light y "castigado" para Structure101 :-( Los
 problemas de erosion arquitectonica tambien los puede tratar DRArch (porque
 son generales), asi que esto no es un aspecto negativo ...
\end_layout

\end_inset

Carece totalmente de aspectos comportamentales.
 Con ver y analizar los diagramas se sabe muy poco de cómo es el funcionamiento
 del sistema y de qué manera interactuan los componentes
\begin_inset Note Note
status open

\begin_layout Standard
Bue,no fue tan asi, de los diagramas producidos por Structure101 "se sabe
 muy poco", porque Uds los presentan sin explicarlos y no muestran los "diagrama
s interesantes" que provee Structure101 :-)
\end_layout

\end_inset

.
 La falta de información dinámica extraida a travéz de trazas de ejecución
 deja ocultas relaciones entre componentes que se resulven en tiempo de
 ejecución.
 Otro punto de disconformidad es que esta herramienta presenta toda la informaci
ón de una sola vez.
 No permite establecer reglas de diseño que guien la recuperación, ni la
 interacción del usuario en el proceso de reconstrucción.
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Conclusiones-y-Trabajos"

\end_inset

Conclusiones y trabajos futuros
\end_layout

\begin_layout Standard
En los capítulos previos de este trabajo se presentó 
\emph on
DRArch
\emph default
, un enfoque para la re\SpecialChar \-
cons\SpecialChar \-
trucción de arquitecturas que define un proceso
 interactivo, iterativo e incremental.
 Mediante el uso de información estática (código fuente), dinámica (logs
 de ejecución), experiencia de los distintos 
\emph on
stakeholders
\emph default
, etc., 
\emph on
DRArch
\emph default
 permite reconstruir la arquitectura de un sistema por medio de un proceso
 en el cual el arquitecto acepta o rechaza sugerencias para generar diagramas
 de UCMs.
\end_layout

\begin_layout Standard
El prototipo de 
\emph on
DRArch
\emph default
 fue implementado como plug-in de 
\emph on
Eclipse
\emph default
, aprovechando su arquitectura extensible, su modelo para análisis estático
 de código fuente Java y su 
\emph on
framework
\emph default
 de interfaz de usuario.
 A su vez, ésto permitió aprovechar los editores de UCM y el módulo de instrumen
tación de código de 
\emph on
FLABot
\emph default
 así como también la utilización del plug-in 
\emph on
JQuery
\emph default
, que es quien utiliza las ventajas de 
\emph on
Eclipse
\emph default
 sobre el metamodelo del lenguaje Java para realizar la transformación del
 código fuente a una representación de hechos al estilo 
\emph on
ProLog
\emph default
.
\end_layout

\begin_layout Standard
Como aporte principal, 
\emph on
DRArch
\emph default
 permite reconstruir la arquitectura de software de un sistema generando
 vistas que describan el comportamiento a un nivel de abstracción a\SpecialChar \-
pro\SpecialChar \-
pia\SpecialChar \-
do.
 Generalmente, esta información es utilizada para colaborar con la documentación
 del sistema.
 Al mismo tiempo, el enfoque realiza un mapeo entre el código fuente y las
 vistas generadas.
 Por lo tanto, el análisis realizado por la herramienta también puede ser
 usado por el arquitecto para decidir la recodificación de algunas partes
 de la implementación de acuerdo con las vistas arquitectónicas.
\end_layout

\begin_layout Standard
Una de las ventajas que posee el enfoque es que el proceso de reconstrucción
 tiene en cuenta la información dinámica, es decir, la información que genera
 el sistema cuando se está ejecutando.
 Esto hace que se pueda describir el comportamiento del sistema y sea uno
 de los diferenciales más importantes con respecto a otros enfoques.
\end_layout

\begin_layout Standard
Adicionalmente, se puede incorporar al análisis información del contexto,
 información aportada por la experiencia del arquitecto, información de
 los 
\emph on
stackeholders
\emph default
 y cualquier otro tipo de información, ya que la representación es lo suficiente
mente flexible como para traducir este tipo de información.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Adicionalmente, se puede incorporar al análisis información del contexto,
 información aportada por la experiencia del arquitecto, información de
 los stackeholders y cualquier otro tipo de información, ya que la representació
n 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Limitaciones Actuales
\end_layout

\begin_layout Standard
El enfoque se basa en ciertas suposiciones y tiene algunas limitaciones.
 Una de las suposiciones mas importantes es la de la selección de reglas.
 Las reglas ejecutadas para cada sistema son específicas para el estilo
 arquitectónico predominante.
 De esta forma, el arquitecto tiene la responsabilidad de seleccionar qué
 conjunto de reglas debe correr sobre el sistema.
 En el peor de los casos, en donde se decida ejecutar todas las reglas disponibl
es, la mayoría de estas reglas no aportarían información arquitectónica
 relevante.
\end_layout

\begin_layout Standard
El haber utilizado programación lógica para definir el modelo de reglas
 brinda flexibilidad a la hora de realizar consultas, pero acarrea los problemas
 típicos en los lenguajes interpretados.
 Una de las principales desventajas del enfoque, es que el modelo de reglas
 propone cierta ambigüedad que debe resolver el arquitecto en el momento
 de tomar las decisiones, aceptando o rechazando sugerencias.
\end_layout

\begin_layout Standard
La notación UCM generada por 
\emph on
DRArch
\emph default
 da una noción de la estructura del sistema mediante componentes y responsabilid
ades, que es reforzada mediante los mapeos componente-clase y responsabilidad-mé
todo.
 Sin embargo, esta información no puede considerarse una documentación completa
 de la estructura de un sistema a nivel arquitectónico, ya que no define
 de manera explícita las relaciones entre estos elementos (por ejemplo,
 la estructura de herencia en una vista estática o los puertos y conectores
 en tiempo de ejecución).
\end_layout

\begin_layout Standard
Finalmente, es necesario mencionar algunas desventajas inherentes a las
 técnicas de instrumentación de código y análisis de logs de ejecución,
 que fueron acarreadas por este trabajo.
 El módulo de instrumentación de 
\emph on
FLABot
\emph default
 se encuentra estable y ha sido utilizado exitosamente en un gran número
 de aplicaciones.
 Sin embargo, la elección de los puntos a inspeccionar para generar un log
 de ejecución implica un 
\emph on
tradeoff
\emph default
 importante.
 En teoría, sería posible registrar la ejecución de cada línea de código
 y el estado de todos los objetos en cada instante.
 De esta manera, se podría rea\SpecialChar \-
li\SpecialChar \-
zar un análisis más preciso y exhaustivo,
 ya que se contaría con absolutamente toda la información posible acerca
 de la ejecución de la aplicación.
 Sin embargo, la cantidad de información almacenada se volvería inmanejable
 y la aplicación analizada se vería extremadamente afectada en su rendimiento,
 ya que por cada línea ejecutada se activaría el mecanismo de publicación
 y subscripción de eventos del instrumentador.
\end_layout

\begin_layout Section
Trabajos futuros
\end_layout

\begin_layout Standard
La elaboración de este trabajo, junto con la implementación del prototipo,
 puso en evidencia nuevas posibilidades para investigaciones futuras, como
 así también algunas posibles mejoras a la implementación existente.
 En esta sección se describen algunas de ellas.
\end_layout

\begin_layout Subsection
Detección de Aspectos
\end_layout

\begin_layout Standard
El Desarrollo de Software Orientado a Aspectos (DSOA) es el paradigma de
 programación cuya idea principal es proporcionar un soporte avanzado para
 la separación de 
\emph on
concerns 
\emph default
introduciendo una nueva unidad modular, llamada 
\emph on
aspecto.
 
\emph default
Existen técnicas de DSOA que proveen modios sitemáticos para identificación,
 modularización representación y composición de 
\emph on
crosscutting concerns
\emph default
.
 El término 
\emph on
crosscutting concern
\emph default
 se refiere a factores de calidad o funcionalidad del software que no pueden
 ser efectivamente modularizados usando técnicas habituales de desarrollo
 de software.
 Generalmente estos concerns constituyen requerimientos no funcionales del
 sistema y se dispersan a lo largo de todo el código fuente generando lo
 que se denomina 
\emph on
código mezclado y diseminado
\emph default
.
\end_layout

\begin_layout Standard
Con el crecimiento y madurez de los lenguajes de programación orientada
 a aspectos, como AspectJ
\begin_inset LatexCommand cite
key "AspectJ"

\end_inset

, ha surgido la necesidad de migrar los sistemas existentes a sistemas orientado
s a aspectos.
 Esta reingeniería se conoce como Reingeniería Orientada a Aspectos 
\begin_inset LatexCommand cite
key "GarciaMay2005"

\end_inset

 y se realiza en dos etapas.
 La primera etapa conocida como Aspect Mining se encarga del reconocimiento
 de aspectos.
 Una vez reconocidos los aspectos, se aplican técnicas de "Aspect Refactoring"pa
ra su migración a un sistema orientado a aspectos 
\begin_inset LatexCommand cite
key "Fowler"

\end_inset

.
\end_layout

\begin_layout Subsection
Validación de patrones de diseño
\end_layout

\begin_layout Standard
Es muy común que los sistemas se desarrollen utilizando patrones de diseño
 ya que representan soluciones a problemas genéricos 
\begin_inset LatexCommand cite
key "Gamma94"

\end_inset

.
 Muchas veces es necesario asegurarse de que los patrones estén implementados
 correctamente, ya que las modificaciones en el código fuente durante el
 desarrollo del sistema pueden afectar los patrones existentes.
 Se pude utilizar una parte de la funcionalidad del 
\emph on
DRArch
\emph default
 para generar reglas que validen si los patrones de di\SpecialChar \-
se\SpecialChar \-
ño están implementados
 correctamente.
 El diseño flexible de la herramienta permite realizar esta modificación
 realizando cambios menores en el código fuente.
\end_layout

\begin_layout Subsection
Incorporando algoritmos
\end_layout

\begin_layout Standard

\emph on
DRArch
\emph default
 esta basado en un proceso donde interviene un modelo de reglas.
 Gracias a este modelo de reglas se gana mucha flexibilidad a la hora definir
 consultas sobre la información que se quiere obtener.
 Sin embargo, también aporta cierto grado de ambigüedad, la cual es resuelta
 por el arquitecto en el momento de aceptar o rechazar cada sugerencia.
 Una forma de evitar esta ambigüedad es incorporando algoritmos que validen
 los resultados de la ejecución de cada regla.
 Esto también aumenta el grado de automatización del proceso propuesto por
 
\emph on
DRArch
\emph default
, ya que la interacción con el arquitecto disminuye al no tener que tomar
 tantas decisiones.
 Por ejemplo, una desventaja de los sistemas basados en reglas es que baja
 la eficiencia cuando se tratan espacios de búsqueda muy grandes, al generar
 sugerencias invalidas cuya evaluación y eliminación disminuye el rendimiento
 (costo humano, no computacional).
 Mediante técnicas probabilisticas o reglas de ámbito (por nombrar algunas)
 sería posible hacer este tipo de filtrado antes de presentar los resultados
 al arquitecto.
\end_layout

\begin_layout Subsection
Especialización del enfoque
\end_layout

\begin_layout Standard
Durante la elaboración de este trabajo, se trató de mantener la generalidad
 del enfoque al no limitarlo a ningún estilo arquitectónico en particular
 o a algún conjunto de convenciones de implementación específico.
 Como objetivo de diseño, ésto tuvo un efecto positivo en el trabajo ya
 que permite el uso de la herramienta en cualquier sistema que haya sido
 implementado en Java.
\end_layout

\begin_layout Standard
Sin embargo, creemos que los estilos arquitectónicos y las convenciones
 de implementación pueden aportar información valiosa al enfoque.
 Mediante la especificación de reglas, se puede mejorar su precisión incorporand
o un catálogo de de reglas orientadas a los distintos estilos arquitectónicos
 así como también, reglas que cumplan con las convenciones de implementación.
 Si mediante un conjunto de reglas se detecta cuál es el estilo arquitectónico
 que predomina en el sistema, entonces es posible aplicar un segundo conjunto
 de reglas que sean específicas para el estilo arquitectónico predominante,
 y así mejorar la eficiencia del 
\emph on
DRArch
\emph default
.
\end_layout

\begin_layout Subsection
Automatización de la herramienta con la utilización de agentes
\end_layout

\begin_layout Standard
Dada la naturaleza del problema y de la solución propuesta, es natural pensar
 en la incorporación de un agente inteligente que tome las decisiones sobre
 que sugerencias aceptar y cuales no.
 El mismo arquitecto mediante el uso de la herramienta en forma manual,
 guiará el proceso de aprendizaje del agente.
 Una alternativa viable es que el asistente no tome las decisiones pero
 que informe o notifique al arquitecto que cierta sugerencia que no aceptó
 es posible que sea de utilidad (falso negativo por parte del arquitecto).
 Un segundo agente puede ser utilizado para construir el conjunto de reglas
 que serán ejecutadas a continuación.
 
\end_layout

\begin_layout Standard
También, es destacable notar que el proceso propuesto por 
\emph on
DRArch
\emph default
 Top-Down o Down-Top tiene una correspondencia directa con el proceso de
 razonamiento de los agentes.
 Este puede ser de encadenamiento progresivo (
\emph on
forward chainning
\emph default
), considerando todos los datos conocidos y avanzar hasta encontrar la solución,
 como de razonamiento regresivo (
\emph on
backward chainning
\emph default
), que considera una posible solución y trata de probar su validez.
 
\end_layout

\begin_layout Subsection
Mapeo de paths con casos de test
\end_layout

\begin_layout Standard
Una vez que la aplicación que está siendo analizada se ha puesto en ejecución,
 el proceso de ejercitarla con los casos de uso correspondientes a los paths
 de\SpecialChar \-
sac\SpecialChar \-
tua\SpecialChar \-
li\SpecialChar \-
za\SpecialChar \-
dos se debe realizar de manera manual.
 En caso de tener que verificar un número considerable de paths, la tarea
 se puede volver muy tediosa, aumentando la probabilidad de introducir errores
 en el análisis por distracciones del usuario.
\end_layout

\begin_layout Standard
Un posible trabajo futuro para mitigar esta debilidad del enfoque puede
 ser permitir el mapeo de UCMs con casos de test.
 Al contar la herramienta con información acerca de qué caso de test corresponde
 a cada 
\emph on
path
\emph default
, sería posible la creación de los logs de ejecución necesarios sin intervención
 del usuario.
\end_layout

\begin_layout Chapter
\start_of_appendix
\begin_inset LatexCommand label
name "cha:Eclipse-FLABot-y-JQuery"

\end_inset

Eclipse, FLABot y JQuery
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Plataforma-Eclipse"

\end_inset

Plataforma Eclipse
\end_layout

\begin_layout Standard
Eclipse es una comunidad open-source cuyos proyectos están orientados a
 proveer una plataforma de desarrollo extensible y frameworks de aplicaciones
 para construir software.
 Eclipse provee herramientas y frameworks extensibles que abarcan el ciclo
 de vida de desarrollo de software, incluyendo soporte para modelado, entornos
 de desarrollo para Java, C/C++ y otros lenguajes, testing y performance,
 business intelligence, aplicaciones de escritorio y desarrollo embebido.
 Un gran ecosistema de importantes empresas de software, universidades,
 institutos de investigación e individuos extienden, complementan y soportan
 la plataforma Eclipse 
\begin_inset LatexCommand cite
key "ECLIPSE"

\end_inset

.
\end_layout

\begin_layout Standard
Uno de los beneficios claves de la plataforma Eclipse aparece a través de
 su uso como un punto de integración.
 Al construir las herramientas o aplicaciones sobre la plataforma Eclipse,
 se les permite integrarse con otras herramientas también escritas usando
 la plataforma.
 De esta manera, la plataforma integra las herramientas individuales en
 un único producto, proveyendo una experiencia rica y consistente para los
 usuarios.
\end_layout

\begin_layout Standard
El rol principal de la plataforma es brindar a los desarrolladores un conjunto
 de mecanismos y reglas para conducir a la integración simple y sistemática
 de herramientas.
 Éstos mecanismos son expuestos por medio de APIs (Application Programming
 Intefaces), clases y métodos bien definidos.
 La plataforma además provee bloques de construcción y frameworks muy útiles
 para facilitar el desarrollo de nuevas he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
tas.
\end_layout

\begin_layout Standard
En la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Arquitectura-de-Plug-ins"

\end_inset

 se muestra un esquema de los componentes principales de la arquitectura
 de plug-ins de Eclipse.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/eclipsePluginArch.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Arquitectura-de-Plug-ins"

\end_inset

Arquitectura de Plug-ins de Eclipse
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Arquitectura de Plug-ins
\end_layout

\begin_layout Standard
Un 
\emph on
plug-in
\emph default
 es la menor unidad de función de la plataforma Eclipse que puede ser de\SpecialChar \-
sa\SpecialChar \-
rro\SpecialChar \-
lla\SpecialChar \-

da y entregada por separado.
 Por lo general, una herramienta pequeña se escribe como un solo plug-in,
 mientras que una herramienta compleja tiene su funcionalidad repartida
 entre varios plug-ins.
 Excepto por un pequeño kernel llamado 
\emph on
Platform Runtime
\emph default
, toda la funcionalidad de la plataforma es provista en forma de plug-ins.
\end_layout

\begin_layout Standard
La configuración de cada plug-in se describe a través de un par de archivos.
 El manifiesto declara información esencial acerca del plug-in, incluyendo
 nombre, versión y dependencias hacia otros plug-ins.
 El segundo archivo, plugin.xml, declara las interconexiones del plug-in
 con otros plug-ins.
 El modelo de interconexión es simple: un plug-in declara cualquier número
 de puntos de extensión, y cualquier número de extensiones a uno o más puntos
 de extensión en otros plug-ins.
 Los puntos de extensión pueden ser extendidos por otros plug-ins.
\end_layout

\begin_layout Standard
Un punto de extensión puede tener una interfaz API correspondiente.
 Otros plug-ins contribuyen implementaciones de esta interfaz por medio
 de extensiones de este punto de extensión.
 Cualquier plug-in es libre de definir nuevos puntos de extensión y de proveer
 una nueva API para que usen otros plug-ins.
 En la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Comunicación-entre-Plug-ins"

\end_inset

 se ilustran los roles principales para la comunicación entre plug-ins.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/EclipsePluginComunicacion.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Comunicación-entre-Plug-ins"

\end_inset

Comunicación entre Plug-ins de Eclipse
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al iniciar, la plataforma descubre el conjunto de plug-ins disponibles,
 lee sus archivos de manifiesto, y construye un registro de plug-ins en
 memoria.
 Al determinar el conjunto de plug-ins al principio, y al soportar un significat
ivo intercambio de información entre plug-ins sin tener que activar ninguno
 de ellos, la plataforma puede proveer a cada plug-in de una rica fuente
 de información pertinente acerca del contexto en el que está corriendo.
 
\end_layout

\begin_layout Standard
La plataforma corre en una única invocación de una máquina virtual Java
 estándar.
 A cada plug-in se le es asignado su propio class loader Java, que es responsabl
e de cargar sus clases y recursos.
 Cada plug-in declara explícitamente su dependencia con otros plug-ins de
 los que espera acceder directamente a sus clases, y controla la visibilidad
 frente a los plug-ins dependientes de las clases e interfaces públicas
 en sus librerías.
 Ésta información se declara en el manifiesto, y las reglas de acceso son
 aplicadas en tiempo de ejecución por los class loaders de los plug-ins.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:FLABot"

\end_inset

FLABot
\end_layout

\begin_layout Standard

\emph on
FLABot
\begin_inset Foot
status collapsed

\begin_layout Standard
\begin_inset LatexCommand htmlurl
name "FLABot homepage:"
target "http://www.exa.unicen.edu.ar/isistan/flabot/"

\end_inset


\end_layout

\end_inset


\emph default
 es una herramienta de soporte para la localización de fallas y debugging
 de plug-ins de Eclipse.
 El tipo de soporte que provee la herramienta no se trata de encontrar puntos
 de error específicos en el código, sino que se enfoca en el modelo arquitectóni
co de un plug-in y usa esa información para aproximar las regiones de código
 donde los errores se originan con mayor probabilidad.
 El proyecto fue inspirado por el enfoque propuesto en 
\begin_inset LatexCommand cite
key "SORIA04"

\end_inset

.
 Básicamente, éste enfoque se basa en la noción de que usar modelos arquitectóni
cos permite al desarrollador razonar y resolver muchos problemas de debugging
 en un nivel que es razonablemente manejable, inclusive para sistemas complejos
 
\begin_inset LatexCommand cite
key "SAIP"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/flabotFlow.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Esquema-de-funcionamiento-FLABot"

\end_inset

Esquema de funcionamiento de 
\emph on
FLABot
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
En la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Esquema-de-funcionamiento-FLABot"

\end_inset

 se presenta un esquema del funcionamiento de 
\emph on
FLABot
\emph default
.
 Para alcanzar la funcionalidad propuesta, la herramienta utiliza información
 de mapeo responsabilidad-código para configurar un instrumentador de bytecode
 Java, de esta manera generando registros de las trazas de ejecución problemátic
as.
 Éstos registros o logs son tomados por el 
\emph on
Asistente de Localización de Fallas
\emph default
 para realizar un análisis exploratorio de los paths de funcionalidad descriptos
 en la especificación arquitectónica.
 Éste análisis combina información de ejecución de bajo nivel contenida
 en los logs con feedback del usuario, para así identificar la causa de
 la falla en un conjunto de responsabilidades.
 Una vez detectadas las causas del error, el conjunto de responsabilidades
 problemáticas es traducido en un conjunto de breakpoints en sus correspondiente
s regiones de código, una vez más utilizando la información de mapeo responsabil
idad-código.
 Finalmente, el usuario es libre de utilizar técnicas de debugging tradicionales
 sobre este espacio de búsqueda reducido.
\end_layout

\begin_layout Standard
La funcionalidad principal de 
\emph on
FLABot
\emph default
 se encuentra organizada básicamente en tres módulos:
\end_layout

\begin_layout Description
Editores\InsetSpace ~
de\InsetSpace ~
Especificaciones\InsetSpace ~
Arquitectónicas: Este módulo posee la fun\SpecialChar \-
cio\SpecialChar \-
na\SpecialChar \-
li\SpecialChar \-
dad
 necesaria para la especificación y manipulación de modelos de componentes
 UML y de UCMs de manera gráfica, como se muestra en las Figuras\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Editor-de-componentes"

\end_inset

 y 
\begin_inset LatexCommand ref
reference "fig:Editor-de-UCM"

\end_inset

.
 Los editores permiten mapear cada componente UML a un conjunto de clases
 Java, para luego mapear cada responsabilidad a un subconjunto de los métodos
 de estas clases.
 Estos modelos son los vehículos principales para construir la información
 arquitectónica que los otros dos módulos necesitan para funcionar.
 Ambos editores fueron implementados como plug-ins de Eclipse, por lo que
 se integran completamente con la plataforma y tanto los editores mismos
 como sus correspondientes modelos pueden ser reutilizados por cualquier
 otro plug-in.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/screenshot-componentEditor.png
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Editor-de-componentes"

\end_inset

Editor de componentes UML de 
\emph on
FLABot
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/screenshot-ucmEditor.png
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Editor-de-UCM"

\end_inset

Editor de UCM de 
\emph on
FLABot
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Asistente\InsetSpace ~
para\InsetSpace ~
Localización\InsetSpace ~
de\InsetSpace ~
Fallas: Este módulo materializa las estrategias
 para localización de fallas guiada por la arquitectura, de acuerdo al enfoque
 descripto en 
\begin_inset LatexCommand cite
key "SORIA04"

\end_inset

.
\end_layout

\begin_layout Description
Debugger\InsetSpace ~
Especializado: Este módulo añada el soporte para debugging en sí.
 El debugger especializado permite relacionar la salida del asistente con
 estructuras de código, insertando breakpoints en las que resulten apropiadas,
 para luego permitir al desarrollador aplicar técnicas tradicionales de
 debugging sobre el código de la aplicación.
\end_layout

\begin_layout Standard
Además de estos tres módulos principales, para generar los logs de ejecución
 
\emph on
FLABot
\emph default
 implementa un módulo de instrumentación de código estructurado en forma
 de capas.
 La capa superior recibe parámetros de configuración que indican el conjunto
 de clases y métodos que deben ser inspeccionados, es encargada de iniciar
 la ejecución de la aplicación instrumentada y produce como respuesta un
 log con las trazas de ejecución.
 En las capas inferiores se implementa la infraestructura de bajo nivel
 para la instrumentación en sí, que hace uso de un 
\emph on
class loader
\emph default
 especializado para analizar y modificar el 
\emph on
bytecode
\emph default
 de las clases en los puntos que deben ser inspeccionados.
 Cuando una clase está a punto de ser cargada dentro de la máquina virtual,
 el bytecode se analiza para detectar si en ella se produce alguno de los
 eventos indicados en los parámetros de configuración.
 Si esto es así, se utiliza la librería 
\emph on
Javassist
\emph default
 
\begin_inset LatexCommand cite
key "chiba98javassist"

\end_inset

 para insertar llamadas en los puntos inspeccionados a un mecanismo de publicaci
ón y subscripción de eventos que se encarga de generar el log.
\end_layout

\begin_layout Standard
Independientemente de sus detalles de implementación, para reutilizar el
 instrumentador de FLABot solamente hace falta comunicarse con la capa superior.
 Ésto se hace a través de un punto de extensión, definido en el instrumentador,
 al que es posible contribuir los parámetros de configuración necesarios
 para indicar tanto las clases y métodos a inspeccionar como la ubicación
 donde se debe guardar el log de ejecución.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:JQuery"

\end_inset

JQuery
\end_layout

\begin_layout Standard
JQuery es un buscador flexible de código fuente basado en consultas y desarrolla
do como un plug-in de Eclipse.
 Esta implementado sobre un lenguaje lógico de consultas.
 El mismo soporta búsquedas directas de subconjuntos de elementos especícos
 de código fuente de acuerdo a algún criterio especicado por una consulta.
 JQuery esta construido sobre las bases de un lenguaje similar a prolog:
 TyRuBa.
 El poder de un lenguaje de programación lógico provee la flexibilidad para
 expresar consultas complejas y usar reglas para denir relaciones de alto
 nivel.
 El lenguaje de consultas de JQuery es básicamente TyRuBa, complementado
 con una librería de predicados que permite consultar sobre unidades de
 código y las relaciones entre ellas.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="middle" leftline="true" rightline="true" width="3in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Nombre del Predicado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Tipo de argumento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Descripción
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
cu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
cu(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es una unidad de compilación (archivo .class o .java).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
package
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Package
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
package(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un paquete.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RefType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
class(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es una clase.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RefType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
interface(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es una interface.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
method
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Method
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
method(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un método.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
constructor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Constructor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
constructor(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un constructor.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
initializer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Initializer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
initializer(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un inicializador.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
field
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Field
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
field(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un campo.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
bookmark
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Bookmark
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
bookmark(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un 
\emph on
bookmark.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
warning
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Warning
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
warning(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un 
\emph on
warning
\emph default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
error
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Error
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
error(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un error.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
task
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Task
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
task(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es una tarea.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Predicados-unarios"

\end_inset

Predicados unarios
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="3in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Nombre del Predicado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Tipo de argumento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Descripción
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
priority
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Task, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
priority(?T, ?P)
\family default
\size default
 significa: La tarea
\family typewriter
\size small
\noun on
 ?T
\family default
\size default
\noun default
 tiene prioridad 
\family typewriter
\size small
\noun on
?P
\family default
\size default
\noun default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Element, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
name(?E, ?S)
\family default
\size default
 significa: El elemento
\family typewriter
\size small
\noun on
 ?E
\family default
\size default
\noun default
 tiene el nombre 
\family typewriter
\size small
?S
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
child
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Element, Element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
child(?Sup, ?Sub)
\family default
\size default
 significa: El elemento
\family typewriter
\size small
\noun on
 ?Sup
\family default
\size default
\noun default
 tiene el hijo 
\family typewriter
\size small
?Sub
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
extends
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RefType, RefType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
extends(?C1, ?C2)
\family default
\size default
 significa: La clase (o interface)
\family typewriter
\size small
\noun on
 ?C1
\family default
\size default
\noun default
 extiende la clase (o interface) 
\family typewriter
\size small
?C2
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
implements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RefType, RefType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
implements(?C, ?I)
\family default
\size default
 significa: La clase 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 implementa la interface 
\family typewriter
\size small
?I
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
throws
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Callable, RefType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
throws(?C, ?T)
\family default
\size default
 significa: El llamador 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 lanza 
\family typewriter
\size small
?T
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Field, Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
type(?F, ?T)
\family default
\size default
 significa: El campo 
\family typewriter
\size small
\noun on
?F
\family default
\size default
\noun default
 es del tipo 
\family typewriter
\size small
?T
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
modifier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Element, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
modifier(?E, ?S)
\family default
\size default
 significa: El elemento
\family typewriter
\size small
\noun on
 ?E
\family default
\size default
\noun default
 tiene un modificador (ej.: public, private, static, etc.) 
\family typewriter
\size small
?S
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
arg
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Callable, Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
arg(?C, ?T)
\family default
\size default
 significa: El llamador 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 tiene un argumento dle tipo 
\family typewriter
\size small
?T
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
returns
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Callable, Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
returns(?C, ?T)
\family default
\size default
 significa: El llamador 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 retorna el tipo 
\family typewriter
\size small
?T
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
signature
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Callable, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
signature(?C, ?S)
\family default
\size default
 significa: El llamador
\family typewriter
\size small
\noun on
 ?C
\family default
\size default
\noun default
 tiene una signatura 
\family typewriter
\size small
?S
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Predicados-binarios"

\end_inset

Predicados binarios
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="3in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Nombre del Predicado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Tipo de argumento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\align center

\series bold
Descripción
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
methodCall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Block, Method, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
methodCall(?B, ?M, ?L)
\family default
\size default
 significa: El bloque 
\family typewriter
\size small
?B
\family default
\size default
 llama al método 
\family typewriter
\size small
?M
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
thisCall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Constructor, Constructor, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
thisCall(?C1, ?C2, ?L)
\family default
\size default
 significa: El constructor 
\family typewriter
\size small
?C1
\family default
\size default
, realiza un llamado this al constructor 
\family typewriter
\size small
?C2
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
construcorCall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Block, Constructor, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
construcorCall(?B, ?C, ?L)
\family default
\size default
 significa: El bloque 
\family typewriter
\size small
?B
\family default
\size default
 llama al constructor 
\family typewriter
\size small
?C
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
instanceOf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Block, RefType, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
instanceOf(?B, ?T, ?L)
\family default
\size default
 significa: El bloque 
\family typewriter
\size small
?B
\family default
\size default
 es una instancia del tipo 
\family typewriter
\size small
?T
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
reads
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Block, Field, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
reads(?B, ?F, ?L)
\family default
\size default
 significa: El bloque 
\family typewriter
\size small
?B
\family default
\size default
 lee el campo 
\family typewriter
\size small
?F
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
writes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Block, Field, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
writes(?B, ?F, ?L)
\family default
\size default
 significa: El bloque 
\family typewriter
\size small
?B
\family default
\size default
 escribe el campo 
\family typewriter
\size small
?F
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
param
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Callable, Type, Integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
param(?C, ?T, ?N)
\family default
\size default
 significa: El llamador 
\family typewriter
\size small
?C
\family default
\size default
 tiene un argumento del tipo 
\family typewriter
\size small
?T
\family default
\size default
 como su argumento numero 
\family typewriter
\size small
?N
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
tag
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Element, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
tag(?E, ?N, ?V)
\family default
\size default
 significa: El elemento 
\family typewriter
\size small
?E
\family default
\size default
 tiene un javadoc tag 
\family typewriter
\size small
?N
\family default
\size default
 con el valor 
\family typewriter
\size small
?V
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Predicados-ternarios"

\end_inset

Predicados ternarios
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="3in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Nombre del Predicado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Tipo de argumento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Descripción
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
component
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
component(?C)
\family default
\size default
 significa: 
\family typewriter
\size small
\noun on
?T
\family default
\size default
\noun default
 es un componente.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
interfaceLink
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
interfaceLink(?IM1, ?IM2)
\family default
\size default
 significa: 
\family typewriter
\size small
?IM1
\noun on
 
\family default
\size default
\noun default
esta vinculada con 
\family typewriter
\size small
?IM2.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
interfaceModel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
interfaceModel(?IM)
\family default
\size default
 significa: El elemento
\family typewriter
\size small
\noun on
 
\noun default
?IM
\family default
\size default
 es una interface.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
port
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
port(?P)
\family default
\size default
 significa: 
\family typewriter
\size small
\noun on
?P
\family default
\size default
\noun default
 es un puerto.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasPort
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasPort(?C, ?P)
\family default
\size default
 significa: El componente 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 tiene un puerto 
\family typewriter
\size small
?P
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasProvided
\newline
Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasProvidedInterface(?P, ?IP)
\family default
\size default
 significa: El purto 
\family typewriter
\size small
\noun on
?P
\family default
\size default
\noun default
 provee una interface 
\family typewriter
\size small
?IP
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasRequired
\newline
Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasRequiredInterface(?P, ?IR)
\family default
\size default
 significa: El purto 
\family typewriter
\size small
\noun on
?P
\family default
\size default
\noun default
 requiere una interface 
\family typewriter
\size small
?IR
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
association
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
association(?C, ?P, ?C)
\family default
\size default
 significa: El componente 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 esta asociado a la clase 
\family typewriter
\size small
?C
\family default
\size default
 la cual esta en el paquete 
\family typewriter
\size small
?P
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
mapping
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
mapping(?C, ?P, ?C)
\family default
\size default
 significa: El componente 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 esta mapeado a la clase 
\family typewriter
\size small
?C
\family default
\size default
 la cual esta en el paquete 
\family typewriter
\size small
?P
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
relationship
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
relationship(?C1, ?C2, ?P)
\family default
\size default
 significa: El componente 
\family typewriter
\size small
\noun on
?C1
\family default
\size default
\noun default
 esta relacionado con el componente 
\family typewriter
\size small
\noun on
?C2 
\family default
\size default
\noun default
con el prototipo 
\family typewriter
\size small
?P
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
responsibility
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
responsibility(?R)
\family default
\size default
 significa: 
\family typewriter
\size small
\noun on
?R
\family default
\size default
\noun default
 es una responsabilidad.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
has
\newline
Responsibility
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasResponsibility(?C, ?R)
\family default
\size default
 significa: El componente 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 tiene la responsabilidad 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
executedMothod
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
executedMothod(?O, ?M, ?T, ?R) 
\family default
\size default
significa: 
\family typewriter
\size small
?O 
\family default
\size default
es el orden de ejecución, 
\family typewriter
\size small
?M
\family default
\size default
 es el método ejecutado, 
\family typewriter
\size small
?T 
\family default
\size default
es el tipo que retorna el método y 
\family typewriter
\size small
?R 
\family default
\size default
es el valor de lo que retornó la ejecución del método.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
snapshot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
snapshot(?I, ?F, ?V) 
\family default
\size default
significa: 
\family typewriter
\size small
?I 
\family default
\size default
el identificador de ejecución, 
\family typewriter
\size small
?F
\family default
\size default
 el campo (variable) y 
\family typewriter
\size small
?V
\family default
\size default
 el valor del campo 
\family typewriter
\size small
?F
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Predicados-DRArch"

\end_inset

Predicados 
\emph on
DRArch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "plain"
bibfiles "bibliography"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
