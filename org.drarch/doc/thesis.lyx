#LyX 1.5.6 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\language spanish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\float_placement h
\paperfontsize default
\spacing single
\papersize a4paper
\use_geometry true
\use_amsmath 2
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1.7in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language swedish
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
frontmatter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \include{cover.lyx}
preview false

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[andres]
\end_layout

\begin_layout Standard
Hola Nicolas, como estas? Si, he estado leyendo los capitulos y haciendo
 anotaciones sobre el documento, aunque todavia las tengo en papel, y las
 tengo que marcar sobre el pdf como anotaciones, pensaba mandartelas el
 viernes pasado pero no pudo ser :-) En lineas generales, como te habia
 dicho, la escritura esta razonable y muestra el big picture de la tesis,
 pero me parece que todavia quedan algunas cabos sin atar (al menos en lo
 que se refiere a lo que esta escrito hoy por hoy).
 Algunos puntos son los siguientes: 
\end_layout

\begin_layout Standard
1- Uds tienen definido el approach y el tool, eso esta Ok, pero la forma
 en que esta presentado es "una solucion que todavia no encontro su problema",
 es decir, falta clarificar (especialmente para un evaluador que no necesariamen
te conoce del tema), que cosas se pueden hacer hoy con reconstruccion, cuales
 no, y particularmente cual es el problema que ataca DArch...Algunos cabos
 "sueltos" mientras leia respecto a esto: 
\end_layout

\begin_layout Standard
a) La introduccion a arquitecturas de software del capitulo 2 es un poco
 corta, con pocos ejemplos, y asume sin mas consideraciones que la "mejor"
 forma de documentar una arquitectura es a traves de UCMs.
 No estoy diciendo que UCMs esta mal, pero todos sabes que documentar un
 disenio con UCMs no es tan simple ni efectivo ...
 
\end_layout

\begin_layout Standard
b) El capitulo 3 de trabajos relacionados esta bien, pero tiene a simplificar
 los otros enfoques y apuntar directamente a que ninguno es incremental
 o considera varias fuentes de informacion, cuando en realidad todos mas
 o menos dicen que tiene que ser incremental, y casi todas siguen el paradigma
 extraer-clasificar-presenar al igual que DArch...Herramientas mas nuevas como
 Structure101 o DSM Lattix se ocupan de una mezcla de conformance y reconstrucci
on, Bahaus-Axivion es otra bastante completita de reconstruccion...
 En este contexto, cual es el aporte especifico de DArch???(ver comentario
 abajo) 
\end_layout

\begin_layout Standard
c) no se consideran aspectos deHuman-Computer-Interaction que afectan la
 reconstruction, tipo la "presentacion de la informacion recuperada de forma
 visual y efectiva para que el usuario la pueda comprender, formas de navegar
 los modelos, etc.
 Por ejemplo, Shrimp tiene buenas capacidades de visualizacion, comprension,
 navegacion...
 
\end_layout

\begin_layout Standard
2- Los casos de estudio, como estan presentados, no muestran mucha informacion
 de como se fueron reconstruyendo las vistas, que limitaciones hubo, que
 cosas el tool pudo reconstruir y cuales no, ...
 ...Algunos cabos "sueltos" mientras leia respecto a esto: 
\end_layout

\begin_layout Standard
a) no ayuda mucho el hecho de que los 2 casos de estudio se basen en el
 mismo estilo arquitectonico subyacente (Bubble), ya que hay que hacer el
 analisis si lo recuperado es porque esta el Bubble de base y DArch trabaja
 bien para Bubble, o se puede aplicar a otros tipos de arquitecturas.
 O sea, no estoy diciendo que haya que cambiar los casos de estudio, pero
 si hacer las salvedades, suposiciones y analisis del caso 
\end_layout

\begin_layout Standard
b) no entendi que muestran las metricas que toman para evaluar cosas de
 los casos de estudio.
 Dado que las metricas me suenan fuertemente inspiradas en el paper de ArchSync,
 no se hasta que punto el "contexto " del ArchSync es extrapolable al DArch,
 
\end_layout

\begin_layout Standard
c) otra cosa que hay que discutir en los casos de estudio es como se uso
 la documentacion original de cada caso de estudio.
 Una opcion es: casi no se uso, y luego de realizar la recuperacion se realizo
 una comparacion entre lo recuperado y lo que decia la documentacion inicial.
 Otra opcion es: se uso la documentacion inicial como una forma de explorar
 mejor el codigo realizar una mejora substancial en la documentacion o entendimi
ento de la arquitectura.
 Either option, se tiene que discutir 
\end_layout

\begin_layout Standard
d) un posible trabajo que yo agregaria en los casos de estudio es recuperar
 las mismas arquitecturas (Market y G2) con otro tool, ej con Shrimp/Creole,
 y hacer una comparacion de cuales son los puentos fuertes y debiles de
 ese tool, y como DArch mejora eso (especialmente la parte dinamica, interactivi
dad, bla bla) 
\end_layout

\begin_layout Standard
Lo que pude entender de la contribucion de DArch, despues de mucho releer,
 es que "DArch, a diferencia de otros enfoques, intenta capturar fuentes
 de conocimiento sobre como recuperar ciertas cosas en base a cierta informacion
/evidencia (no necesariamente codigo) y codificar este conocimiento mediante
 reglas, de manera que se puedan "sugerir" alternativas al desarrollador.
 O sea, que DArch mas que una herramienta de reconstruccion especifica es
 un asistente que permite PLUGGEAR estrategias de reconstruccion (eventualmente
 que vienen de otros tools) y utilizar dichas estrategias para hacer la
 reconstruccion incremental e interactiva.
 Ahora, DArch NO IMPLEMENTA tecnicas especificas de reconstruccion (las
 toma prestadas) y NO MANEJA la parte de presentacion/navegacion visual
 de las cosas de una manera amena para el usuario (o sea, los UCMs estan
 bien pero no hay soporte arriba de esto).
 Please, diganmente si le erre mucho con esto, y la idea es otra :-)
\end_layout

\begin_layout Standard
Bue, la idea no es con esto desanimarlos, sino mas bien hacer una critica
 constructiva y marcar algunos problemas logicos que aparecen cuando uno
 plasma una idea (generalmente ya implementada) en papel.
 Ya les mandare los comentarios mas especificos, capitulo x capitulo Supongo
 que Alvaro tendra su propio punto de vista del estado de la tesis (probablement
e coincidente con algunas de las cosas que les puse aca), asi que diria
 que los proximos pasos son: mejorar los capitulos, formular de una manera
 clara el problema y la solucion, y completar la parte de los casos de estudio.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Resumen
\begin_inset Note Note
status open

\begin_layout Standard
[andres] De vital importancia para el resumen es que se entiendan 2 cosas:
 1- El problema especifico que se intentan resolver y porque es importante
 (para eso se da al principio un poquito de contexto) 2- El enfoque "clarito"
 que se aplico y una idea general de los resultados que se obtuvieron.
\end_layout

\begin_layout Standard
Otra pregunta (de ignorante), DR en DRArch viene de "Dynamic Recovery" o
 algo similar? Si es asi, no vi nada que hable de "recuperacion utilizando
 informacion dinamica" en el resumen, y ponerlo haria mas claro el punto
 2) del enfoque
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
addcontentsline{toc}{chapter}{Resumen}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las arquitecturas de software son modelos de sistemas que, al poseer un
 alto nivel de abs\SpecialChar \-
trac\SpecialChar \-
ción, facilitan la gestión de las relaciones y problemas
 entre re\SpecialChar \-
que\SpecialChar \-
ri\SpecialChar \-
mien\SpecialChar \-
tos e implementación.
 La adopción cada vez mayor del desarrollo centrado en la arquitectura se
 debe a que ésta expone las principales decisiones de diseño y sus consecuencias
 en una etapa temprana del desarrollo de software, y al hacerlo permite
 un mejor entendimiento del sistema y facilita razonar sobre cómo se satisfacen
 los requerimientos por parte de todas las personas involucradas.
 Por estas razones, un buen diseño arquitectónico tiene un impacto positivo
 en la calidad final de los sistemas.
\end_layout

\begin_layout Standard
Todo sistema de software posee una arquitectura de software subyacente.
 Sin embargo, no necesariamente existe en la práctica una documentación
 acertada de esta arquitectura.
 Por lo tanto, el hecho de lidiar con sistemas que no poseen documentación
 es un escenario que ocurre con frecuencia dentro de las organizaciones.
 Muchas veces, los expertos que diseñaron el sistema se han ido de la organizaci
ón, la documentación existente es escasa o esta desactualizada, no se dispone
 de todo el código fuente y lo único con que se cuenta es con el código
 ejecutable binario.
 Adicionalmente, los sistemas legados suelen no poseer documentación alguna
 y es muy común que nuevos sistemas de software tengan que integrarse con
 estos.
\end_layout

\begin_layout Standard
Actualmente, el problema de la falta de documentación arquitectónica ha
 sido tratado por medio de enfoques basados en ingeniería reversa, con resultado
s dispares.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] CUales enfoques??? cuales problemas tienen esos enfoques...
 (solo consideran estructura...
 )Hacer énfasis en considerar informacion dinámica del sistema a reconstruir...
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
No hay una herramienta que resuelva todos los problemas, o que a pesar de
 lo que hay, la reconstrucción presenta dificultades tales como no considerar
 aspectos comportamentales del sistema ni basar su análisis en información
 dinámica.
 Esto implica que la reconstrucción de las arquitecturas sigue siendo un
 problema para muchos proyectos de software.
 La Reconstrucción de Arquitecturas de Software es una técnica para generar
 representaciones arquitectónicas de un sistema que puede ser utilizada
 de diversas formas.
 El principal uso de esta representación es el de documentar la arquitectura
 existente de un sistema.
\end_layout

\begin_layout Standard
En este trabajo, proponemos un enfoque materializado en una herramienta
 de soporte llamada 
\emph on
DRArch
\emph default
, para asistir a los desarrolladores a generar la documentación arquitectónica
 utilizando un proceso de sucesivos refinamientos de forma incremental.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] evolutivo o de suscesivos refinamientos incremental Extender un poco
 estos párrafos...
\end_layout

\end_inset

En este proceso de reconstrucción de arquitecturas, se asume que existe
 el código fuente de la aplicación.
 El objetivo principal de 
\emph on
DRArch
\emph default
 es realizar un análisis de la información relevante que se pueda recolectar
 de un sistema, generando como salida una representación arquitectónica
 por medio de diagramas de componentes y de 
\emph on
Use-Case Maps
\emph default
 (UCMs).
 La mayoría de la información relevante proviene del código fuente, del
 log de ejecución del sistema, de la experiencia del arquitecto y del conocimien
to de las personas que desarrollaron el sistema.
 Los UCMs son una notación práctica para especificar tanto componentes como
 flujos de responsabilidades.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Esta notación no solo el comportamiento sino que ademas la estructura
 del sistema..
\end_layout

\end_inset

Esto permite describir el sistema mediante un conjunto de vistas de alto
 nivel que abarcan tanto aspectos estructurales como de comportamiento.
\end_layout

\begin_layout Standard
Para lograr la funcionalidad propuesta, 
\emph on
DRArch 
\emph default
sigue un proceso en el cuál el arquitecto interactúa sobre pequeñas decisiones
 de diseño.
 Así, se va especificando incrementalmente el modelo arquitectónico del
 sistema.
 El modelo arquitectónico esta representado en un lenguaje de programación
 lógica que brinda suficiente flexibilidad como para poder realizar consultas
 complejas de forma simple.
\end_layout

\begin_layout Standard
[Resultados de los experimentos]
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
[andres]
\end_layout

\begin_layout Standard
agregar una linea con informacion resumida de: - Uds realizaron experimentos
 de reconstruccion que mostraron resultados positivos en cuanto a ....
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Agregar parte del resultado de las experiencias ..
 es decir, que en base a experiencias a demostrado su ...
\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Agradecimientos
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
addcontentsline{toc}{chapter}{Agradecimientos}
\end_layout

\end_inset

A nuestros padres y demás familiares que nos brindaron su afecto y colaboración
 durante estos años de estudio.
\end_layout

\begin_layout Standard
Un especial agradecimiento a nuestro director Álvaro Soria y a nuestro co-direct
or Andrés Díaz Pace, por su colaboración, disposición y confianza brindados
 durante el desarrollo de este trabajo.
\end_layout

\begin_layout Standard
A nuestros amigos y compañeros, los cuales supieron estar a nuestro lado
 en forma incondicional durante todo este tiempo, y de los cuales nos sentimos
 muy contentos y orgullosos.
\end_layout

\begin_layout Standard
¡Gracias!
\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
mainmatter
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introducción
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Aca poner algo como..
 la tendencia actual en el proceso de desarrollo software es focalizar las
 actividades de este proceso en la arquitectura del sistema.
 A este enfoque se lo conoce como desarrollo centrado en la arquitectura
 (refs)..
 Sin embargo, en la mayoria de los sistemas la documentacion es escasa o
 inexistente..
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La arquitectura de software es una disciplina que cumple un rol central
 en la toma de decisiones de diseño 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Agregar una linea tipo "Por ejemplo, ...." [ejemplo de decisiones]
\end_layout

\end_inset

 y en la comunicación entre todos los participantes del desarrollo de un
 producto de software.
 Por ejemplo, algunas decisiones de diseño que involucra esta disciplina
 son: asignación de recursos, definición de restricciones entre la comunicación
 de los distintos elementos, declaración de responsabilidades, etc.
 Como vehículo de comunicación, su documentación es fundamental, pues la
 falta de ella, o peor aún, el descuido al producirla y mantenerla, anulan
 o revierten todos los beneficios que el desarrollo centrado en la arquitectura
 puede aportar.
\end_layout

\begin_layout Standard
La tendencia actual en el proceso de desarrollo software es focalizar las
 actividades de este proceso en la arquitectura del sistema.
 A este enfoque se lo conoce como desarrollo centrado en la arquitectura
 
\begin_inset LatexCommand cite
key "SAIP"

\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] (refs)..
\end_layout

\end_inset

 Sin embargo, en la mayoría de los sistemas la documentación es escasa o
 inexistente.
 La Arquitectura de Software refleja captura las principales decisiones
 de diseño del sistema.
 Es muy difícil que estas primeras decisiones puedan cambiarse más adelante,
 por ejemplo, durante el proceso de desarrollo.
 Los efectos que tienen estas decisiones son los que más perduran en el
 ciclo de vida de un sistema.
 En general, una arquitectura abarca aspectos estructurales y de comportamiento
 así como también de 
\emph on
deployment
\emph default
, 
\emph on
allocation of work
\emph default
, etc.
 Los aspectos estructurales se refieren a vistas estáticas del sistema,
 mientras que los aspectos de comportamiento se refieren a vistas dinámicas
 del sistema.
 Por ejemplo, los diagramas de componentes sirven para representar aspectos
 estructurales, mientras que los 
\emph on
Use Case Maps
\emph default
 
\begin_inset LatexCommand cite
key "UCMBOOK"

\end_inset

 proveen un modelo para aspectos de comportamiento.
 Aún con la ayuda de las arquitecturas, entender cómo funciona un sistema
 complejo y comunicárselo a los demás continua siendo un problema para muchas
 organizaciones.
 
\end_layout

\begin_layout Standard
Todo sistema de software posee una arquitectura de software subyacente.
 Sin embargo, no necesariamente existe en la práctica una documentación
 acertada de esta arquitectura.
 Ni siquiera es necesario que existan diagramas, vistas ó representaciones
 gráficas para poder afirmar que un sistema posee una arquitectura de software.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[alvaro] Entre las razones de la falta de documentación se encuentran .....
\end_layout

\end_inset

 Por lo tanto, el hecho de lidiar con sistemas que no poseen documentación
 es un escenario que ocurre con frecuencia dentro de las organizaciones.
 Muchas veces, los expertos que diseñaron el sistema se han ido de la organizaci
ón, la documentación existente es escasa o esta desactualizada, no se dispone
 de todo el código fuente y lo único con que se cuenta es con el código
 ejecutable binario.
 También existen casos en donde la documentación disponible es inválida,
 es decir, el sistema no fue implementado siguiendo las restricciones y
 decisiones de diseño que la documentación describe.
\end_layout

\begin_layout Standard
Adicionalmente, los sistemas legados suelen no poseer documentación alguna
 y es muy común que nuevos sistemas de software tengan que integrarse con
 estos.
 En estas situaciones, dado que una arquitectura puede existir independientement
e de su especificación, es que cobran importancia los enfoques de reconstrucción
 de arquitecturas 
\begin_inset LatexCommand cite
key "SAIP"

\end_inset

.
 Una de las principales contribuciones que aportan estos enfoques es que
 las representaciones que generan, sirven para comenzar o contribuir con
 la de documentación de la arquitectura de software.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] ...
 [andres] falta lo de ejemplificar!
\end_layout

\begin_layout Standard
Dado que es una copia del parrafo del Resumen, tengo aqui los mismos comentarios
 que puse en el Resumen.
 
\end_layout

\begin_layout Standard
Yo diria si pueden que no copien literalmente del Resumen, sino que aca
 elaboren o ejempliquen un poco :-)
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Motivación"

\end_inset

El problema de recuperar la documentación arquitectónica
\begin_inset Note Note
status collapsed

\begin_layout Standard
[andres] que los parrafos que siguen hablen del problema especifico
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es comúnmente aceptado que una arquitectura de software puede ser utilizada
 como vehículo de comunicación entre los 
\emph on
stakeholders
\emph default
 (personas con diferentes necesidades de un sistema).
 Sin embargo puede verse la falta de documentación arquitectónica en la
 mayoría de los proyectos de desarrollo actuales, especialmente en empresas
 de software pequeñas.
 Esta es una de las situaciones donde surge la necesidad de reconstruir
 la arquitectura de un sistema.
 La Reconstrucción de Arquitecturas es una técnica para generar representaciones
 arquitectónicas del sistema.
 Generalmente, esta técnica consiste en realizar las siguientes actividades
 de forma iterativa:
\end_layout

\begin_layout Itemize
Extracción de información: El propósito de esta actividad es extraer información
 de distintas fuentes.
\end_layout

\begin_layout Itemize
Unificación de la información: Es necesario que la información recolectada
 este representada en una estructura de datos común.
\end_layout

\begin_layout Itemize
Análisis de información: En esta actividad es donde se realiza el mayor
 trabajo de la reconstrucción ya que se construyen abstracciones y varias
 representaciones de la información recolectada.
\end_layout

\begin_layout Itemize
Generación de vistas: Se crean vistas que representen y describan la arquitectur
a del sistema.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] antes de explicar los posibles usos de la tecnica, explicar
 primero en que consiste la técnica en si!!!
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Standard
...que puede ser utilizada de diversas formas 
\begin_inset LatexCommand cite
key "SAIP"

\end_inset

.
 El principal uso de esta representación es el de documentar la arquitectura
 existente de un sistema.
 Si no existe la documentación o la documentación disponible esta desactualizada
, la representación obtenida mediante la reconstrucción puede ser usada
 como una base para la re-documentación de la arquitectura.
 Esta representación también puede ser usada como un punto de comienzo para
 realizar re-ingeniería sobre el sistema y crear una nueva arquitectura.
 Finalmente, la re\SpecialChar \-
pre\SpecialChar \-
sen\SpecialChar \-
ta\SpecialChar \-
ción puede ser usada como una forma de identificar
 componentes reusables o para establecer una arquitectura base dentro de
 una línea de productos de software 
\begin_inset LatexCommand cite
key "Rick2003"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Supongamos que se tiene un sistema en el que existen varios componentes
 que envían y reciben eventos, con mucha flexibilidad a la hora de programar,
 y uno quisiera saber qué componentes trabajan con qué eventos, y ver el
 estilo de eventos general para realizar modificaciones.
 En esta situación, una representación de la arquitectura podría brindarnos
 la información necesaria.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Seria bueno no hablar todo en abstracto, y agregar un párrafo
 con un ejemplito textual concreto de a lo que Uds se refieren.
 Por ejemplo, algo tipo "Supongamos que se tiene un sistema en el que existen
 varios componentes que envian y reciben eventos, con mucha flexibillidad
 a la hora de programar, y uno quisiera saber que componentes trabajan con
 que eventos, y ver el estilo de eventos general, blba bla bla ...."
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Debido a la importancia de la arquitectura de software en la toma de decisión
 en diferentes etapas del proceso de desarrollo, 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] No esta facil de leer eso de "refleje arquitectonicamente...".
 Yo diria mejor que contar con una buena documentacion es indispensable.
 Y en particular, si las prescripciones arquitectonicas se reflejan en el
 disenio detallado e implementacion, mucho mejor, porque esto ayuda a que
 los razonamientos realizados a nivel arquitectonico se cumplan efectivamente
 en la implementacion, bla bla ...
 Y luego, que las abstracciones arquitectonicas no son cosas que sean directamen
te mapeables a codigo o que puedan ejecutarse, por ejemplo la dinamica del
 sistema, bla bla...
\end_layout

\end_inset

contar con una buena documentacion es indispensable.
 Y en particular, si las prescripciones arquitectónicas se reflejan en el
 diseño detallado e implementación, mucho mejor, porque esto ayuda a que
 los razonamientos realizados a nivel arquitectónico se cumplan efectivamente
 en la implementación.
 A diferencia de las clases y paquetes, las abstracciones arquitectónicas
 no son cosas que sean directamente mapeables a código o que puedan ejecutarse.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[andres] , por ejemplo la dinamica del sistema, bla bla...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Esta documentación puede ser extraída a partir de información provista por
 las sentencias del código fuente.
 Sin embargo, el código fuente provee una vista parcial de los aspectos
 arquitectónicos que no incluye la dinámica de los diversos componentes
 de software.
 Evidencia de la dinámica del sistema puede ser obtenida del análisis de
 la ejecución de las sentencias y los valores correspondientes en tiempo
 de ejecución.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En algunas soluciones a la Reconstrucción de Arquitecturas que se han propuesto
 la arquitectura del sistema se extrae principalmente por medio del análisis
 del código fuente.
 En otra
\begin_inset Note Note
status collapsed

\begin_layout Standard
Cuales??' dividirlas en los correspondientes grupos..
 las referencias son algo antiguas..
 
\end_layout

\end_inset

s 
\begin_inset Note Note
status collapsed

\begin_layout Standard
armin o dali?
\end_layout

\end_inset

, se utilizan enfoques que reconstruyen patrones de diseño porque esto asegura
 que la reconstrucción se más precisa pero restringe el análisis a sistemas
 implementados utilizando patrones de diseño.
 Muchos de los enfoques mencionados sólo muestran aspectos estructurales
 como diagramas de componentes o de clases y muy pocos muestran resultados
 que permitan visualizar el comportamiento del sistema de forma simple.
 Es decir, en el que se puedan visualizar procesos de más alto nivel que
 la de una simple secuencia de ejecución como lo son los diagramas de secuencia.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
(ej: diagramas de UCMs o de secuencia
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Muestran componentes y connectores???
\end_layout

\end_inset

).
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] De nuevo, no sean tan tendeciosos a que si no usa UCMs esta
 todo mal, porque digamos que los UCMs son una notacion que nosotros utilizamos
 por "conveniencia" (ya estaba soportada por el FLABot), y por otro lado,
 respecto a los "diagramas de secuencia", el Eclipse trae un tool que los
 reconstruye si uno quiere, pero el problema es que son tan detallados que
 no se puede ver mucho.
 El queso de "reconstruir comportamiento" esta en reconstruir "procesos"
 y cosas de mas alto nivel que la simple secuencia, y es ahi donde los UCMs
 pueden aportar, se entiende como re-enfocar el parrafo????
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y][andres] No concuerdo con esto.
 De hecho, casi todos los tools que conozco se basan en el paradigma "extraer-ab
straer-presentar" que necesariamente require de varios pasos y de la experiencia
 del desarrollador para saber que extraer, como abstraerlo y como visualizarlo
 .
 Es cierto que algunas herramientas de reingenieria para C/Java directamente
 me transforman el codigo a diagramas UML, pero estos son los tools "menos
 interesantes".
 Lo que si creo que esta bien es que "la informacion de varias fuentes no
 es facilmente manipulable ni abstraible", y ahi si el DRArch puede aportar
 algo.
 En resumen, por favor rescriban el parrafo para que quede claro que problema
 resolveria su enfoque...
\end_layout

\end_inset

Estos enfoques presentan el resultado de la reconstrucción en un solo paso
 y el arquitecto no ve el progreso del proceso de reconstrucción.
 Esto hace que el proceso no se pueda 
\begin_inset Quotes eld
\end_inset

guiar
\begin_inset Quotes erd
\end_inset

 a medida que se reconstruye la arquitectura.
 Es decir, no se tiene control sobre qué y cómo se recupera la información,
 ni se puede intervenir si lo considera necesario.
 Además, no es posible manipular la información de forma interactiva, perdiendo
 así la posibilidad de contar con la experiencia del arquitecto y su conocimient
o en el dominio.
 
\end_layout

\begin_layout Standard
En resumen, la mayoría de los enfoques se basan en el paradigma "extraer-abstrae
r-presentar" que necesariamente requiere de varios pasos y de la experiencia
 del desarrollador para saber qué extraer, cómo abstraerlo y cómo visualizarlo.
 Por otro lado, ninguno de estos enfoques mantiene la información recuperada
 de tal forma que sea flexible su manipulación.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Necesidad-de-Documentación-Arquitectónica"

\end_inset

Necesidad de Documentación Arquitectónica 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Hay un poco de confusion (al menos en el texto) entre lo que
 es "documentacion arquitectonica" y "reconstruccion de arquitecturas",
 y me gustaria que esto este bien claro para el lector "medio".
\end_layout

\begin_layout Standard
Obvio que en algun momento la necesidad de documentar lleva a reconstruccion,
 pero en general son 2 cosas separadas.
 Uno puede (re-)documentar sin reconstruir, y puede reconstruir sin estar
 interesado en la documentacion ...
\end_layout

\begin_layout Standard
Otro comentario es que Reconstruccion es una forma de chequear Architecture
 Conformance, pero no es la unica forma ...
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Por ahi esta discusion la pondria en motivaciones..
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La documentación de una arquitectura es fundamental para el desarrollo de
 software ya que ésta actúa como vehículo comunicacional entre los diferentes
 
\emph on
stakeholders
\emph default
 que participan a lo largo de las diferentes etapas del desarrollo.
 De esta forma permite que el sistema se diseñe, implemente, pruebe, instale
 y mantenga siguiendo a la arquitectura que lo sostiene.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Esta un poco confuso este parrafo se nota la traduccion..
 Poner algo como ...
 ya que actuá como vehiculo comunicacional entre los diferentes stakeholder
 que participan a lo largo de las diferentes etapas del desarrollo ....
 Por ahi como items queda mejor que como subsecciones ya que no tiene mucho
 puesto en cada una..
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
A continuación se listan los principales motivadores que hacen necesaria
 una herramienta de reconstrucción de arquitecturas para documentar o re-documen
tar descripciones arquitectónicas de un sistema.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] ..[andres] Yo trataria que cada una de las subsecciones de abajo tenga
 una mencion a un ejemplo concreto (cosa de ir dando contexto)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Inexistencia de documentación
\end_layout

\begin_deeper
\begin_layout Standard
Como se mencionó previamente, existen varios motivos por los que un sistema
 no dispone de documentación que describa la arquitectura de software.
 También es muy común que no se cuente con los expertos que diseñaron el
 sistema.
 El hecho de lidiar con sistemas de estas características implica que sea
 necesaria una documentación de la arquitectura del mismo ya que para poder
 mantener y entender un sistema, es necesario conocer su arquitectra.
 No contar con la documentación arquitectónica de un sistema aumenta considerabl
emente el riesgo de que el proyecto fracase.
 Por ejemplo, en un sistema donde los componentes se comunican mediante
 un mecanismo de invocación implícita, es muy difícil darse cuenta cuáles
 son los componentes que se relacionan sin tener descripciones arquitectónicas
 de alto nivel que lo reflejen.
\end_layout

\end_deeper
\begin_layout Itemize
Erosión arquitectónica
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Esta frase es criptica.
 Explicarla mejor pleaes (por ejemplo, se ve que para poder entender lo
 del analisis a nivel arquitectonico, necesitan explicar en alguno lugar
 un poco mas de atributos de calidad, ya que los analisis son en general
 de atributos de calidad)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Asegurarse de que un sistema sea construido en conformidad con su diseño
 arquitectónico durante su desarrollo, evolución y mantenimiento es importante,
 ya que divergencias significativas entre arquitectura e implementación
 pueden comprometer la estructura, estilo y propiedades que han sido establecida
s mediante cuidadoso análisis a nivel arquitectónico 
\begin_inset LatexCommand cite
key "ABIANTOUN05b"

\end_inset

.
 Generalmente, estos análisis son de atributos de calidad y éstos se describen
 en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sub:Atributos-de-calidad"

\end_inset

.
\end_layout

\begin_layout Standard
Durante las diferentes etapas del desarrollo de software, pueden producirse
 cambios en la documentación arquitectónica que luego no son reflejados
 en el código, o cambios en el código que no son apropiadamente acomodados
 en la documentación.
 Siendo la arquitectura una guía fundamental durante todo el ciclo de vida
 del sistema, el desfasaje entre documentación e implementación de una arquitect
ura se hará cada vez más difícil de remediar por sus desarrolladores, finalmente
 deteriorando la calidad del producto.
\end_layout

\begin_layout Standard
Desafortunadamente, debido a la evolución natural del sistema, es probable
 que la arquitectura y la implementación pierdan consistencia.
 Una vez que el diseño arquitectónico está listo, típicamente todos los
 esfuerzos se focalizan en la implementación, y esto hace que la documentación
 se desactualice progresivamente.
 Por ejemplo, nuevos requerimientos pueden causar un rediseño de la arquitectura
, con cambios consecuentes en algunas partes de la implementación; y por
 otro lado, algunas tareas de mantenimiento pueden producir cambios en el
 código que deberían ser reflejados en modificaciones de la arquitectura.
 Es aceptable que exista temporalmente cierto desfasaje, normalmente los
 desarrolladores trabajan en la implementación sin mantener el modelo arquitectó
nico, el cual rápidamente queda desactualizado.
\end_layout

\begin_layout Standard
En algunos casos, los desarrolladores pueden introducir sutiles diferencias
 estructurales que invalidan intenciones claves de la arquitectura.
 Por ejemplo, en un sistema estructurado en capas, es posible que un programador
 inadvertido genere dependencias no deseadas al saltear la capa inmediatamente
 inferior.
 Análogamente, en el desarrollo de sistemas 
\emph on
web
\emph default
 multibanda es común el error de invocar directamente a la base de datos
 desde la banda de presentación.
 Como resultado, los arquitectos a menudo deben lidiar en sus análisis con
 conocimiento incompleto e incorrecto debido a defectos en la documentación
 
\begin_inset LatexCommand cite
key "ALDRICH05"

\end_inset

.
 En estos casos, las relaciones de los componentes (en el nivel arquitectónico)
 con clases y métodos (en el nivel de implementación) ya no se mantienen,
 y los desarrolladores deben restablecer la consistencia manualmente.
 Éste fenómeno se conoce como 
\emph on
corrimiento arquitectura-implementación
\emph default
 
\begin_inset LatexCommand cite
key "PERRY92"

\end_inset

 o 
\emph on
erosión arquitectónica
\emph default
.
 Si no se maneja correctamente, revierte los beneficios del desarrollo centrado
 en la arquitectura, ya que se pierde la trazabilidad entre re\SpecialChar \-
que\SpecialChar \-
ri\SpecialChar \-
mien\SpecialChar \-
tos,
 decisiones de diseño y artefactos de implementación.
 
\end_layout

\end_deeper
\begin_layout Section
Reconstrucción de arquitecturas
\end_layout

\begin_layout Standard
La Reconstrucción de Arquitecturas de Software se define como una técnica
 para generar representaciones arquitectónicas de un sistema.
 Si bien el principal uso de esta representación es el de documentar la
 arquitectura existente de un sistema, también puede ser utilizada de diversas
 formas: como base para la re-documentación de la arquitectura, como punto
 de comienzo para realizar re-ingeniería sobre el sistema y crear una nueva
 arquitectura, como forma de identificar componentes re-usables o para establece
r una arquitectura base dentro de una línea de productos de software 
\begin_inset LatexCommand cite
key "Rick2003"

\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y][andres] Idem, ya lo vi antes a esto :-)...
 concentrase mas en en que consiste la tecnica de reconstruccion
\end_layout

\end_inset

 Estos motivos hacen que los enfoques de reconstrucción de arquitecturas
 tomen importancia.
\end_layout

\begin_layout Standard
Existen diferentes técnicas y enfoques para recuperar representaciones de
 la arquitectura de un sistema.
 Esto hace que sea difícil describir las distintas etapas que un proceso
 de reconstrucción de arquitecturas requiere.
 Sin embargo, casi todos los enfoques estructuran un proceso en un ciclo
 basado en extraer, abstraer y visualizar la información
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y][andres] Una figura ilustrativa del extraer-abstraer-visualizar ayudaria
 a entender mejor las cosas
\end_layout

\end_inset

 (ver figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Enfoque-Extraer-Abstraer-Presentar"

\end_inset

).
 En todos los casos, este proceso es asistido por herramientas, las cuales
 extraen información del sistema (ej.
 código fuente) para ir agregando niveles de abstracción cada vez mas altos.
 El resultado final son diagramas que representan la arquitectura del sistema.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ExtraerAbstraerPresentar.png
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Enfoque-Extraer-Abstraer-Presentar"

\end_inset

Enfoque Extraer-Abstraer-Presentar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una definición genérica de la Reconstrucción de Arquitecturas de Software
 es la proponen Bass et.al.
 en 
\begin_inset LatexCommand cite
key "SAIP"

\end_inset

, definiendo ésta como como un proceso interpretativo, interactivo e iterativo
 que involucra muchas actividades: no es un proceso totalmente automático.
 Requiere de la capacidad y de la atención del experto en ingeniería reversa
 y del arquitecto (o alguien con conocimientos sobre la arquitectura del
 sistema).
 
\end_layout

\begin_layout Standard
La ingeniería de reversa sobre una arquitectura consiste en todas las actividade
s que hacen que una arquitectura de software sea explícita.
 Generalmente, el análisis comienza desde el nivel de implementación y se
 va moviendo hasta que llega el nivel arquitectónico.
 El objetivo de este proceso es extraer modelos arquitectónicos del sistema
 desde la implementación.
 
\end_layout

\begin_layout Section
Objetivos
\end_layout

\begin_layout Standard
Como objetivo principal del trabajo se propuso definir un enfoque flexible
 para reconstruir arquitecturas de sistemas de software
\begin_inset Note Note
status collapsed

\begin_layout Standard
hablar del enfoque a utilizar...
\end_layout

\end_inset

e.
 Para cumplir con este objetivo, el proceso de reconstrucción consiste en
 recolectar información de distintas fuentes (código fuente, logs de ejecución,
 experiencia de los expertos del sistema, etc) para consolidarlas en una
 representación común en la que se pueda relacionar la información de forma
 sencilla e intuitiva.
 Esta representación se realiza utilizando programación lógica.
 Luego, por medio de un mecanismo de consultas, se analiza la información
 disponible para generar sugerencias al usuario sobre el modelo arquitectónico
 a reconstruir.
 Este proceso ser repite con el fin de ir refinando de forma incremental
 el modelo arquitectónico.
 El modelo que se va construyendo se transforma diagramas (vistas arquitectónica
s) que representan aspectos estructurales y comportamentales del sistema.
\end_layout

\begin_layout Standard
Por otro lado, el análisis de algunos trabajos similares puso a la luz ciertas
 ca\SpecialChar \-
rac\SpecialChar \-
te\SpecialChar \-
rís\SpecialChar \-
ti\SpecialChar \-
cas que pueden dificultar la aplicación de un enfoque de esta
 naturaleza.
 Por esta razón se impusieron las siguientes restricciones:
\end_layout

\begin_layout Itemize
Los sistemas que utilicen el enfoque para reconstruir se arquitectura deben
 ser implementados siguiendo el paradigma de programación orientada a objetos.
\end_layout

\begin_layout Itemize
Se debe planificar cuál va a ser la estrategia de reconstrucción en base
 a un estudio de la información existente (entrevistas con desarrolladores,
 documentos, etc.) y en base a la semántica que poseen los artefactos arquitectón
icos.
 Es decir, se debe definir cuáles son los conceptos arquitectónicos que
 se desean reconstruir y a que granularidad (sub-sistema, componentes, módulos
 o clases son algunos ejemplos) ya que cada sistema tiene su propio concepto.
 Por ejemplo, en determinados sistemas se desea reconstruir componentes
 que representen eventos mientras que en otros, no es de interés que los
 eventos estén representados por componentes sino que lo que interesa es
 que se representen las tareas.
\end_layout

\begin_layout Section
Organización del trabajo
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Esto esta todo amontonado.
 Separar las ideas y comentarios de cada capitulo en sus respectivos párrafos.
 
\end_layout

\end_inset

El resto de este trabajo se encuentra organizado de la siguiente manera.
 En el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Contexto"

\end_inset

 se presentan los conceptos de Arquitecturas de Software donde se describe
 su importancia, los estilos arquitectónicos y los atributos de calidad.
 Luego se introducen las Descripciones de Arquitecturas y se detallan los
 Diagramas de Componentes, el Modelo de Vistas 4 + 1 y los Use Case Maps.
\end_layout

\begin_layout Standard
Una vez introducido el contexto, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Trabajos-relacionados"

\end_inset

 se analizan y comparan algunos trabajos relacionados que de diferentes
 maneras apuntan a solucionar el problema de falta o inexistencia de documentaci
ón arquitectónica a través de la reconstrucción de arquitecturas.
 
\end_layout

\begin_layout Standard
Luego de este análisis, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:El-enfoque-DRArch"

\end_inset

 se explica el enfoque 
\emph on
DRArch
\emph default
, detallando cada uno de los pasos que propone para la reconstrucción de
 arquitecturas.
 Para aplicar el enfoque se desarrollo un prototipo de soporte.
 
\end_layout

\begin_layout Standard
En el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Implementación"

\end_inset

 se presentan su diseño y los aspectos más importantes de su implementación.
 A su vez, se realiza un recorrido por la herramienta 
\emph on
DRArch
\emph default
 mostrando interfaces de usuario, representaciones de los datos, etc.
\end_layout

\begin_layout Standard
Más adelante, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Casos-de-Estudio"

\end_inset

, a modo de casos de estudio se ejercitó la herramienta implementada con
 el sistema G2 – una aplicación comercial desarrollada en un proyecto de
 transferencia con la empresa Delsat, S.A.
 – y de 
\emph on
Market
\emph default
 – un proyecto de prueba construido sobre un framework de invocación (nota:
 el proyecto G2 se basa en el mismo framework).
 Luego, se presentan los resultados de estos casos de estudio.
\end_layout

\begin_layout Standard
Finalmente, en el capítulo\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Conclusiones-y-Trabajos"

\end_inset

 se presentan las conclusiones del trabajo, junto con algunas propuestas
 para posibles trabajos futuros.
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Contexto"

\end_inset

Contexto
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres]
\end_layout

\begin_layout Standard
a) La introducción a arquitecturas de software del capitulo 2 es un poco
 corta, con pocos ejemplos, y asume sin mas consideraciones que la "mejor"
 forma de documentar una arquitectura es a través de UCMs.
 No estoy diciendo que UCMs esta mal, pero todos sabes que documentar un
 diseño con UCMs no es tan simple ni efectivo ...
 
\end_layout

\end_inset

En este capítulo se ofrecerá una introducción a los conceptos centrales
 sobre los que se ha realizado este trabajo.
 En primer lugar se define la noción de 
\emph on
Arquitectura de Software
\emph default
 en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Arquitectura-de-Software"

\end_inset

, enfatizando la importancia de su documentación dentro de la organización
 y en particular para el equipo de desarrollo.
 También se realiza un análisis de por qué se elijen los UCMs para representar
 arquitecturas.
 En la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Use-Case-Maps"

\end_inset

 se presentan los 
\emph on
Use-Case Maps
\emph default
, una notación simple y efectiva para la documentación de comportamiento
 a nivel arquitectónico.
 Luego, en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Necesidad-de-Documentación-Arquitectónica"

\end_inset

 se introduce un problema relacionado con la falta de documentación arquitectóni
ca, explicando las condiciones donde ocurre y las graves consecuencias que
 presenta para el desarrollo de software.
 Por último, en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Conclusión"

\end_inset

 y a modo de resumen, se resaltan los conceptos clave detallados en este
 capítulo.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Arquitectura-de-Software"

\end_inset

Arquitecturas de software
\end_layout

\begin_layout Standard
Si bien no existe una única definición de arquitectura de software universalment
e aceptada, generalmente todas lo hacen en función de conceptos comunes.
 En todas se encuentra la noción de descomposición de un sistema en diferentes
 partes, de relaciones existentes entre estas partes, de abstracción de
 las propiedades que no sean externamente visibles ni relevantes para la
 interacción de sus elementos.
 Adicionalmente, se sabe que existen diferentes perspectivas desde las que
 se puede observar un sistema según las propiedades de interés y que ninguna
 de estas vistas conforma la arquitectura en si.
 En su libro 
\emph on
Software Architecture in Practice
\emph default
\InsetSpace ~

\emph on

\begin_inset LatexCommand cite
key "SAIP"

\end_inset


\emph default
, Bass et.al.
 proponen una definición que abarca gran parte de las características antes
 mencionadas:
\end_layout

\begin_layout Quote

\emph on
La arquitectura de software de un programa o sistema de computación es la
 estructura o estructuras del sistema, las cuales abarcan los elementos
 de software, las propiedades externamente visibles de esos elementos, y
 las relaciones entre ellos.
\end_layout

\begin_layout Standard
Como se desprende de esta definición, una arquitectura de software puede
 abarcar
\emph on
 
\emph default
más de una estructura o vista.
 Un ejemplo que puede ilustrar esta propiedad es observar la estructura
 que presentan normalmente los proyectos de desarrollo.
 Generalmente éstos son particionados en módulos con una cierta cantidad
 de responsabilidades, que luego son asignadas a diferentes equipos para
 su de\SpecialChar \-
sa\SpecialChar \-
rro\SpecialChar \-
llo.
 Cada uno de estos módulos contiene programas y datos accesibles desde otros
 elementos, además de otros atributos que son privados.
 Éste tipo de estructura se emplea a menudo para describir un sistema y
 define principalmente cómo se divide y asigna su funcionalidad, por esta
 razón, representa una perspectiva estática.
 Por otro lado, existen estructuras que centran su atención en cómo los
 elementos interactúan en tiempo de ejecución para alcanzar la funcionalidad
 propuesta.
 Aquí el foco se pone sobre la manera en que los diferentes módulos interactúan
 para ejecutarse en diferentes procesos y como se comunican y sincronizan
 entre ellos.
 A pesar de que ambas vistas aportan información sobre la arquitectura,
 ninguna de ellas la describe en su totalidad.
 Por ejemplo, en una vista de 
\emph on
deployment
\emph default
, el sistema se describe en términos de cómo es el 
\emph on
deploy
\emph default
 sobre las distintas plataformas y cómo éstas se comunican unas con otras.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] What about vistas de deployment?
\end_layout

\begin_layout Standard
In this view, the software is described in terms of how it is deployed across
 various platforms, and how these parts communicate with each other.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La definición precedente también caracteriza a las vistas del sistema por
 estar compuestas de elementos de software, de propiedades externamente
 visibles y de relaciones entre ellos.
 Justamente por ser una abstracción de un sistema complejo, la arquitectura
 de software oculta los detalles que no afectan la manera en que los diferentes
 elementos usan, son usados por, se relacionan con o interactúan con otros
 elementos.
\end_layout

\begin_layout Standard
Una de las implicancias de la definición de arquitectura, es su omnipresencia
 en cualquier sistema de software, aunque ésta no se encuentre documentada.
 Cualquier sistema posee elementos distinguibles con propiedades y relaciones
 asociadas, sin embargo no siempre existe alguien que conozca esta arquitectura,
 de aquí que resulte muy importante su documentación.
\end_layout

\begin_layout Standard
Finalmente, de la definición se deduce que el comportamiento de los elementos
 de software también forma parte de la arquitectura.
 Lo mismo ocurre con las propiedades internas de los elementos de software,
 en donde el comportamiento relevante en este nivel es aquel que afecte
 a la forma en cómo los demás elementos tienen que ser escritos y de qué
 manera deben comunicarse con él.
\end_layout

\begin_layout Standard
Las arquitecturas de software representan las primeras decisiones de diseño
 de un sistema.
 Estas decisiones son las más difíciles de corregir durante el proceso de
 desarrollo ya que tienen un gran impacto sobre el sistema.
 A su vez, las decisiones definen restricciones de implementación en donde
 se aplica el concepto de 
\emph on
separation of concerns
\emph default
.
 Por ejemplo, si una de las decisiones es que exista una separación entre
 la presentación y modelo de un sistema, dos estructuras bien definidas
 se dividen y cada implementación puede evolucionar independientemente de
 la otra.
 Un método que usualmente se utiliza para dividir el esfuerzo es el de asignar
 diferentes grupos de desarrolladores a diferentes porciones del sistema.
\end_layout

\begin_layout Standard
Existen muchos factores que influencian la arquitectura de un sistema.
 Uno de los mas importantes son los denominados 
\emph on
stakeholders
\emph default
.
 Los 
\emph on
stakeholders
\emph default
 son las personas y organizaciones que están interesadas en la construcción
 del sistema: el cliente, usuario final, los desarrolladores, el líder del
 proyecto, etc.
 Éstos colaboran con diferentes requerimientos de los cuales algunos se
 pueden contradecir.
 Los requerimientos no sólo son funcionales ya que construir un sistema
 aceptable incluye aspectos como 
\emph on
performance
\emph default
, disponibilidad, flexibilidad, escalabilidad, seguridad, etc.
 en donde cada 
\emph on
stakeholders
\emph default
 pueden estar interesados en algunos de estos requerimientos no funcionales
 (también llamados atributos de calidad).
\end_layout

\begin_layout Standard
Los atributos de calidad y los requerimientos son ortogonales.
 Si esto no fuera así, la incorporación de una nueva funcionalidad del sistema
 podría establecer el nivel de seguridad o el de disponibilidad o el de
 
\emph on
performance
\emph default
.
 Generalmente, estilos y modelos arquitectónicos son utilizados ya que la
 mayoría de éstos se basa en los atributos de calidad.
\end_layout

\begin_layout Standard
A continuación, se presentan los estilos y modelos arquitectónicos que nos
 ayudan a describir los distintos tipos de componentes y su tipología.
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Estilos-y-Modelos"

\end_inset

Estilos\InsetSpace ~
y\InsetSpace ~
Modelos\InsetSpace ~
Arquitectónicos
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Esta definición esta incompleta.
 La parte mas importante de un estilo es que es un "paquete de decisiones
 de diseño" que prescribe los tipos y topología de componentes en una solución
 de software.
 Como resultado,un estilo favorece ciertos atributos de calidad y desfavorece
 otros.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los estilos arquitectónicos son descripciones de los distintos tipos de
 componentes y su topología.
 También incluye una descripción del patrón de datos y la interacción de
 control.
 Los estilos arquitectónicos son artefactos de ingeniería muy importantes
 porque definen soluciones de diseños que pueden ser aplicados a problemas
 recurrentes.
 Los estilos ofrecen modelos que se basan en la experiencia y en cómo fueron
 utilizados anteriormente.
 Es decir, un estilo es un "paquete de decisiones de diseño" que prescribe
 los tipos y topologías de componentes en una solución de software.
 Como resultado, un estilo favorece ciertos atributos de calidad y desfavorece
 otros.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Insertar un ejemplo de un estilo arquitectonico (para clarificar)
 y como seria la cosa entonces ....
 Esta piola utilizar un estilo que despues pueda aparecer en el Bubble,
 o en alguno de los casos de estudio, asi la cosa queda mas "cohesiva"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Garlan and Shaw [1993], Garlan et al.
 [1994], y Shaw and Clements [1997] proponen la siguiente definición de
 estilos arquitectónicos en términos de patrones de interacciones entre
 tipos de componentes:
\end_layout

\begin_layout Quote

\emph on
Un estilo arquitectónico determina el vocabulario de componentes y conectores
 que pueden ser usados en instancias de ese estilo, junto con un conjunto
 de restricciones de cómo pueden ser combinadas.
 De esta forma, se definen familias de estilos que comparten propiedades
 arquitectónicas comunes.
\end_layout

\begin_layout Standard
Por ejemplo, el estilo cliente-servidor es uno de los más comunes.
 El cliente y servidor son dos tipos de elementos, y su coordinación es
 descripta en términos de un protocolo que el servidor utiliza para comunicarse
 con cada uno de los clientes.
 El uso del término cliente-servidor implica que múltiples clientes existen,
 es decir, no es identificado el cliente por si solo.
 En la siguiente sección, se describe un estilo arquitectónico basado en
 eventos:
\end_layout

\begin_layout Description
Estilo\InsetSpace ~
Invocación\InsetSpace ~
Implícita\InsetSpace ~
(Basada\InsetSpace ~
en\InsetSpace ~
Eventos)
\end_layout

\begin_layout Standard
La idea principal del estilo de Invocación Implícita es que en vez de invocar
 directamente a una tarea, un componente puede producir uno o más eventos.
 Otros componentes en el sistema pueden registrar un evento asociando una
 tarea con un evento.
 Cuando se lanza un evento, el sistema invoca a todos las tareas que estén
 registradas a ese evento.
 Es por esto que la invocación se realiza de forma implícita.
 Para poder comprender este concepto, en la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Invocación-Implícita-vs."

\end_inset

 se muestra como funciona la invocación explícita y la implícita.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/InvocacionImplicita-Explicita.PNG
	width 70text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Invocación-Implícita-vs."

\end_inset

Invocación Implícita vs.
 Explícita
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Descripción
\end_layout

\begin_deeper
\begin_layout Itemize
En lugar de invocaciones de procedimientos explícitas o directas, un componente
 anuncia uno o más eventos y otros componentes registran el interés en un
 evento asociando un procedimiento a dicho evento.
\end_layout

\begin_deeper
\begin_layout Itemize
La ocurrencia de un evento causa la invocación “implícita”de procedimientos
 en otros módulos.
\end_layout

\begin_layout Itemize
Los componentes son los módulos cuyas interfaces ofrecen un conjunto de
 procedimientos y de eventos.
\end_layout

\begin_layout Itemize
Los conectores incluyen llamadas a procedimientos tradicionales, así como
 la ligadura de eventos con llamadas a procedimientos.
\end_layout

\end_deeper
\begin_layout Itemize
Restricciones:
\end_layout

\begin_deeper
\begin_layout Itemize
Quien anuncia el evento no conoce a qué componentes afecta éste.
\end_layout

\begin_layout Itemize
No se pueden hacer asunciones acerca del orden de procesamiento.
\end_layout

\end_deeper
\begin_layout Itemize
Ventajas
\end_layout

\begin_deeper
\begin_layout Itemize
Provee un robusto soporte para la reutilización.
\end_layout

\begin_layout Itemize
Facilita la evolución del sistema.
\end_layout

\end_deeper
\begin_layout Itemize
Desventajas
\end_layout

\begin_deeper
\begin_layout Itemize
Pérdida de control en el comportamiento del sistema.
\end_layout

\begin_layout Itemize
Problemas en el intercambio de datos.
\end_layout

\begin_layout Itemize
Es difícil asegurar la corrección global del sistema.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Uno de los aspectos más importantes de los estilos es el hecho de que éstos
 se basan en los atributos de calidad para definir sus componentes y su
 tipología.
 Ésta es la razón de por qué el arquitecto selecciona un determinado estilo
 arquitectónico.
 Algunos estilos representan soluciones para determinados problemas, otros
 sirven para sistemas de alta seguridad, otros siguen siendo usados exitosamente
 para sistemas de alta disponibilidad.
 Elegir un estilo arquitectónico es una de las primeras y más importantes
 decisiones del arquitecto.
\end_layout

\begin_layout Standard
Los estilos también pueden incluir una descripción informal en donde se
 detalla la relación costo-beneficio de aplicar el estilo relacionado con
 los atributos de calidad.
 Por ejemplo, una descripción podría ser: "Utilizar el estilo arquitectónico
 
\emph on
Pipes and Filters
\emph default
 cuando se requiera el reuso de los componentes mientras que la 
\emph on
performance
\emph default
 no es de alta prioridad".
\end_layout

\begin_layout Standard
Los modelos arquitectónicos se definen como una división de la funcionalidad
 con flujos de dato entre los distintos elementos.
 Es una descomposición estándar de un problema conocido en partes que cooperativ
amente resuelven el problema.
 Basados en la experiencia, los modelos son una característica de los dominios
 que poseen un alto grado de madurez.
 Por ejemplo, son bien conocidos los elementos estándar de un compilador:
 analizador léxico, analizador sintáctico, analizador semántico y generador
 de código intermedio, a su vez, también es conocido cómo es que estos elementos
 interactúan para realizar el objetivo que poseen en común.
\end_layout

\begin_layout Standard
Los estilos y modelos arquitectónicos no son arquitecturas.
 Son conceptos útiles para capturar elementos de una arquitectura.
 Sin embargo, sigue siendo conveniente mostrar una imagen del sistema con
 el estilo arquitectónico como parte de alguna vista.
\end_layout

\begin_layout Subsection
Importancia de las arquitecturas de software
\end_layout

\begin_layout Standard
Desde el punto de vista técnico, las arquitecturas de software toman un
 gran valor.
 Algunas de las razones de la importancia de las arquitecturas de software
 son:
\end_layout

\begin_layout Enumerate
Comunicación entre los 
\emph on
stakeholders
\emph default
: La arquitectura de software representa una abstracción común de un sistema
 y la mayoría de los 
\emph on
stakeholders
\emph default
 pueden utilizarla como medio de negociación, comprensión, consenso y comunicaci
ón.
 Por ejemplo, los usuarios están interesados el sistema esté disponible
 cuando se necesite, en cambio, los clientes están interesados en que la
 arquitectura se implemente en tiempo y forma y con el presupuesto disponible,
 por otro lado, los 
\emph on
managers
\emph default
 se interesan en si la arquitectura permite trabajar en equipo y de forma
 controlada.
 Y finalmente el arquitecto esta interesado en realizar todos estos objetivos.
\newline
La
 arquitectura provee un lenguaje común en el cuál diferentes intereses puede
 ser expresados, negociados y resueltos.
 Sin este lenguaje, es difícil entender un sistema lo suficiente como para
 poder tomar las primeras decisiones que influencien la funcionalidad y
 calidad del sistema.
\end_layout

\begin_layout Enumerate
Primeras decisiones de diseño: Las arquitecturas de software son responsables
 de las primeras decisiones de diseño sobre el sistema.
 Una implementación de un sistema respeta una arquitectura si es que cumplió
 con la estructura de las decisiones de diseño que se describieron en la
 arquitectura.
 Esto quiere decir que la implementación debe poder dividirse en los elementos
 prescriptos, los elementos deben poder interactuar entre ellos y cada elemento
 debe cumplir con las responsabilidades tal como se describió en la arquitectura.
\newline

La arquitectura no solo prescribe la estructura del sistema si no que también
 la estructura del proyecto y en algunas ocasiones, la estructura de toda
 la organización.
 Por ejemplo, si la arquitectura esta basada en un estilo de capas, se podría
 asignar una capa por desarrollador o grupo de desarrolladores.
\newline
Otra de las
 decisiones que se plantean en la arquitectura son los requerimientos no
 funcionales.
 De esta forma, la arquitectura determina los atributos de calidad del sistema.
 El la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Atributos-de-Calidad"

\end_inset

 se explica en detalle los atributos de calidad.
\end_layout

\begin_layout Enumerate
Abstracción transferible de un sistema: Una arquitectura de software constituye
 un modelo en donde se describe cómo un sistema es estructurado y cómo sus
 elementos funcionan juntos.
 Este modelo, se transfiere a lo largo de todo el sistema.
 Si el re-uso de artefactos ser realiza en una etapa temprana, mayor será
 el beneficio.
 Es decir, si re-usar código es un beneficio, re-usar componentes al nivel
 arquitectónico provee enormes beneficios.
 No sólo es el código se re-usa, también la experiencia en construir arquitectur
as con componentes que se re-usan de otras.
 Cuando las decisiones arquitectónicas son re-utilizadas a través de distintos
 sistemas, todas las consecuencias de las primeras decisiones descriptas
 en el punto anterior también son transferidas.
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Atributos-de-calidad"

\end_inset

Atributos de calidad
\end_layout

\begin_layout Standard
Usualmente, los requerimientos que se definen para un sistema no sólo son
 funcionales, sino que también se definen requerimientos no funcionales
 que se denominan Atributos de Calidad.
 Por ejemplo, un cliente podría especificar un requerimiento que defina
 que cuando se inicie una transacción, el sistema no debe demorar más de
 dos segundo en procesarla.
 Éste escenario es un requerimiento no funcional que pertenece al categoría
 
\emph on
performance
\emph default
 de los atributos de calidad.
 Los requerimientos funcionales y los atributos de calidad son ortogonales.
 Si esto no fuera así, la incorporación de una nueva funcionalidad del sistema
 podría establecer el nivel de seguridad o el de disponibilidad o el de
 
\emph on
performance
\emph default
.
 Es importante que los atributos de calidad tengan participación durante
 el diseño del sistema.
 Éstos deberían poder diseñarse y evaluarse a nivel arquitectónico.
 Si bien la arquitectura del sistema provee las bases para que los atributos
 de calidad se cumplan, esto no es suficiente ya que existen otras dependencias.
 Por ejemplo, la 
\emph on
performance
\emph default
 incluye aspectos arquitectónicos como qué responsabilidad debe ser asignada
 a cada componente y no arquitectónicos como la elección de algoritmos para
 implementar determinada responsabilidad.
 Los estilos y modelos arquitectónicos se basan principalmente en los atributos
 de calidad.
\end_layout

\begin_layout Standard
A continuación se describen algunos atributos de calidad:
\end_layout

\begin_layout Itemize

\emph on
Performance
\emph default
: Este atributo de calidad tiene que ver con los tiempos.
 Los eventos ocurren (interrupciones, mensajes, peticiones de los usuarios
 o el paso del tiempo) y el sistema debe responder a éstos.
 Es decir, la 
\emph on
performance
\emph default
 es responsable en cuánto tiempo tarda al sistema en responder a los eventos
 que ocurren.
\end_layout

\begin_layout Itemize
Modificabilidad: El atributo de calidad modificabilidad se enfoca en el
 costo que implica realizar un cambio en alguna parte del sistema.
 Por lo tanto, es necesario identificar qué partes del sistema son las que
 pueden cambiar y en qué momento (en tiempo de desarrollo, de compilación,
 de configuración o de ejecución).
\end_layout

\begin_layout Itemize
Disponibilidad: Este atributo de calidad esta asociado a las fallas del
 sistema y las consecuencias que acarrean.
 Una falla del sistema ocurre cuando el sistema no provee consistentemente
 un servicio según lo especificado.
 Por ejemplo, una vez que el sistema falla, es importante saber cuánto tiempo
 requiere reparar el error.
\end_layout

\begin_layout Itemize
Seguridad: La seguridad es una medida del sistema que permite restringir
 el uso no autorizado de determinados servicios del sistema a los usuarios.
 Un ataque al sistema es cuando se intenta romper la seguridad de este.
 Por ejemplo, un usuario no autorizado a editar datos intenta modificarlos.
\end_layout

\begin_layout Itemize
Usabilidad: La usabilidad se enfoca en medir que tan fácil es para un usuario
 realizar una tarea en el sistema.
 Por ejemplo, si un usuario desea cancelar un pedido, esta actividad no
 debería pasar por más de dos pantallas.
\end_layout

\begin_layout Standard
Los escenarios de los atributos de calidad son un requerimiento específico
 y consisten en seis partes:
\end_layout

\begin_layout Enumerate
Fuente del estimulo: Alguna entidad que genere el estimulo, por ejemplo,
 un usuario, un sistema o algún otro actor.
\end_layout

\begin_layout Enumerate
Estímulo: Es la condición que necesita ser considerada.
\end_layout

\begin_layout Enumerate
Ambiente: El estimulo ocurre bajo determinadas condiciones.
 Por ejemplo, bajo condiciones normales.
\end_layout

\begin_layout Enumerate
Artefacto: El artefacto que es estimulado.
 Podría ser todo el sistema o alguna parte de este.
\end_layout

\begin_layout Enumerate
Respuesta: La respuesta es la actividad que se debe tomar luego de que se
 produzca el estimulo.
\end_layout

\begin_layout Enumerate
Medición de la respuesta: Cuando la respuesta ocurre, esta debe ser medida
 para que el requerimiento pueda ser testeado.
\end_layout

\begin_layout Standard
La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Atributos-de-Calidad"

\end_inset

 muestra las seis partes de los escenarios de los atributos calidad.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/AtributosDeCalidad.PNG
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Atributos-de-Calidad"

\end_inset

Partes de los escenarios de los atributos calidad
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un escenario para el atributo de calidad modificabilidad podría ser el siguiente
:
\end_layout

\begin_layout Standard
"Un desarrollador (Fuente del estimulo) desea realizar un cambio el la interfaz
 de usuario para modificar el color de la pantalla (Estimulo).
 Este cambio debería realizarse en el código (Artefacto) en tiempo de diseño
 (Ambiente).
 Debería llevar menos de 3 horas (Medición de la respuesta) para realizar
 el cambio y ninguna otra funcionalidad del sistema debería modificarse
 (Respuesta)."
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Descriptiones_Arquitectónicas"

\end_inset

Descripciones arquitectónicas
\end_layout

\begin_layout Standard
La documentación de una arquitectura es una etapa crucial para el desarrollo
 de software.
 Incluso con una arquitectura excelente, si ésta no es bien entendida y
 bien comunicada --en otras palabras, bien documentada-- es muy probable
 que el proyecto falle
\begin_inset LatexCommand cite
key "CLEMENTS02"

\end_inset

.
 Si uno se toma el trabajo de crear una arquitectura robusta, 
\emph on
debe
\emph default
 describirla con suficiente detalle, sin ambigüedad y organizada de manera
 tal que los demás puedan encontrar la información que necesitan.
 Si no se logra esto, todo el esfuerzo habrá sido en vano ya que la arquitectura
 no podrá ser usada.
\end_layout

\begin_layout Standard
Como se mencionó anteriormente, uno de los principales propósitos las arquitectu
ras de software es que sirven como medio de comunicación entre los distintos
 
\emph on
stakeholders.
 
\emph default
Su documentación facilita esta comunicación.
 Por ejemplo, los desarrolladores utilizan la documentación para capturar
 restricciones (o algunas libertades) durante la implementación del sistema.
 Por otro lado, 
\emph on
managers
\emph default
 utilizan esta misma documentación para crear equipos de trabajo y asignarlos
 a los diferentes módulos que describe la arquitectura.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Me parece que esta explicacion es confusa y de muy alto nivel.Explic
ar mas concreto please ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quizás el concepto más importante asociado con la documentación de arquitecturas
 de software es el de 
\emph on
vista
\emph default
, por ejemplo, el estilo arquitectónico de Invocación Implícita descripto
 en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sub:Estilos-y-Modelos"

\end_inset

 es mostrado con la vista de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Invocación-Implícita-vs."

\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Si es que no se puso una figura para el ejemplo de estilo de
 la seccion anterior, mostrarlo aca para ejemplificar lo de vista (y obvio,
 decir este es el estilo X mostrado con la vista Y)
\end_layout

\end_inset

.
 Recordando la definición de la arquitectura definida anteriormente, vemos
 a la esta como 
\begin_inset Quotes eld
\end_inset

la estructura o estructuras del sistema, que abarcan los e\SpecialChar \-
le\SpecialChar \-
men\SpecialChar \-
tos, sus
 propiedades externamente visibles, y las relaciones entre ellos
\begin_inset Quotes erd
\end_inset

.
 Una vista es una 
\emph on
representación
\emph default
 coherente de esos los elementos importantes que constituyen un sistema,
 tal como lo son el software o el hardware, respecto a la forma en que los
 involucrados la leen y escriben.
 La vista provee el principio básico de la documentación de una arquitectura
 de software:
\end_layout

\begin_layout Quote
Documentar una arquitectura significa documentar las vistas relevantes y
 luego agregar la documentación que se aplica a más de una vista.
\end_layout

\begin_layout Standard
Éste principio es útil porque separa el problema de la documentación en
 las siguientes partes 
\begin_inset LatexCommand cite
key "CLEMENTS02"

\end_inset

:
\end_layout

\begin_layout Description
Elección\InsetSpace ~
de\InsetSpace ~
las\InsetSpace ~
vistas\InsetSpace ~
relevantes.
 La elección depende de los usos que se le espera dar a la documentación.
 A través de estas vistas se deben expresar al menos tres aspectos del sistema:
 (a) cómo está estructurado el conjunto de unidades de implementación, (b)
 cómo está estructurado el conjunto de elementos que tienen 
\emph on
comportamiento
\emph default
 e in\SpecialChar \-
teraccio\SpecialChar \-
nes en tiempo de ejecución y (c) cómo se relaciona con elementos
 de su ambiente que no son software.
\end_layout

\begin_layout Description
Documentación\InsetSpace ~
de\InsetSpace ~
una\InsetSpace ~
vista.
 Si bien no existe un 
\emph on
template
\emph default
 estándar de documentación de vistas, es esperable que contenga al menos
 la siguiente información:
\end_layout

\begin_deeper
\begin_layout Enumerate
Presentación primaria: por lo general es un gráfico; presenta los elementos
 principales y sus relaciones.
\end_layout

\begin_layout Enumerate
Catálogo de elementos: detalla los elementos y relaciones presentados en
 la presentación primaria.
\end_layout

\begin_layout Enumerate
Diagrama de contexto: muestra cómo lo reflejado en la vista se relaciona
 con su ambiente usando el vocabulario de la misma.
\end_layout

\begin_layout Enumerate
Guía de variabilidad: explica en detalle los puntos de variación que son
 parte de la arquitectura y están explicados en esta vista.
\end_layout

\begin_layout Enumerate
Razonamiento arquitectónico: explica cómo el diseño reflejado en esta vista
 llegó a ser como es.
\end_layout

\begin_layout Enumerate
Glosario de términos.
\end_layout

\begin_layout Enumerate
Otra información.
\end_layout

\end_deeper
\begin_layout Description
Documentación\InsetSpace ~
de\InsetSpace ~
comportamiento.
 Las vistas convencionales de representación arquitectónica presentan 
\emph on
información estructural
\emph default
 del sistema.
 Sin embargo, ésta información 
\emph on
no es suficiente
\emph default
 para razonar acerca de ciertas propiedades del mismo.
 Es necesario describir aspectos comportamentales mediante vistas específicas.
 Exactamente qué aspectos del comportamiento modelar va a depender del tipo
 de sistema que se está diseñando: en un sistema de tiempo real importan
 las propiedades temporales de los eventos; mientras que en un sistema bancario
 las secuencias de eventos, las transacciones atómicas y los procedimientos
 de 
\emph on
rollback
\emph default
 son lo más importante.
\end_layout

\begin_layout Description
Documentación\InsetSpace ~
de\InsetSpace ~
la\InsetSpace ~
información\InsetSpace ~
que\InsetSpace ~
se\InsetSpace ~
aplica\InsetSpace ~
a\InsetSpace ~
más\InsetSpace ~
de\InsetSpace ~
una\InsetSpace ~
vista.
 Cons\SpecialChar \-
ti\SpecialChar \-
tu\SpecialChar \-
ye el complemento de la documentación de las vistas, es decir la
 información que se aplica a más de una vista o al paquete de documentación
 en sí.
 Consiste de tres aspectos principales, el cómo, el qué y el por qué:
\end_layout

\begin_deeper
\begin_layout Enumerate
Cómo está organizada la documentación, de manera que los interesados en
 la arquitectura pueden encontrar la información que necesitan eficientemente.
\end_layout

\begin_layout Enumerate
Qué es la arquitectura: una descripción general del sistema para orientar
 al lector acerca del propósito del sistema, la forma en que las vistas
 se relacionan entre sí, una lista de elementos y dónde aparecen, y un glosario
 que se aplica a toda la arquitectura.
\end_layout

\begin_layout Enumerate
Por\InsetSpace ~
qué la arquitectura es como es: el contexto del sistema, restricciones
 externas que han sido impuestas para darle forma a la arquitectura de cierta
 manera, y el razonamiento para las decisiones de mayor granularidad y escala.
\end_layout

\end_deeper
\begin_layout Standard
La documentación de la arquitectura libera al arquitecto de tener que contestar
 cientos de preguntas acerca de ella.
 Para crear la documentación, se deben entender a todas las partes interesadas
 y cómo esperan usarla.
 Por lo tanto, todos los interesados deben ser tenidos en cuenta a la hora
 de elegir las vistas relevantes.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [andres] Como les marque en otras partes, no se vayan "derechito" a
 los UCMs, sino den algo mas de info de contexto ...
 Por favor insertar referencias, texto y hasta alguna figura de otras notaciones
 para describir arquitecturas, tipo Model 4 + 1 de Krutchen, o algunos diagramas
 de UML2 por ejemplo...
\end_layout

\end_inset

En las siguientes secciones, se describen distintas notaciones para representar
 una arquitectura de software.
 Cada una de estas notaciones muestra un aspecto de la arquitectura.
 Por ejemplo, los diagramas de componentes muestran aspectos estructurales,
 mientras que la notación UCMs se especializa en mostrar el comportamiento
 del sistema.
 
\end_layout

\begin_layout Subsection
Modelo de Vistas 4 + 1
\end_layout

\begin_layout Standard
El modelo de vistas 4 + 1 propone separar el sistema en cuatro vistas esenciales
: la lógica, la de proceso, la física y la de desarrollo.
 Luego, para contribuir con las mediciones, presenta una vista más: la de
 casos de uso que permite describir aspectos funcionales del sistema entero
 
\begin_inset Note Note
status open

\begin_layout Standard
Ref ...Kruchten
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Cada una de las cinco vistas del modelo 4 + 1 describen distintos aspectos
 del sistema mientras que intencionalmente ocultan otros.
 El propósito principal de este modelo es que define una excelente forma
 en que los 
\emph on
stakeholders
\emph default
 comprendan la arquitectura del sistema.
 Los arquitectos utilizan este modelo para entender y documentar varias
 capas de una aplicación de forma sistemática y estándar.
 Los documentos creados por el modelo son fácilmente utilizados por todos
 los miembros del equipo de desarrollo.
\end_layout

\begin_layout Standard
Las cuatro primeras vistas de modelo representan aspectos lógicos, de procesamie
nto, físicos y de desarrollo de una arquitectura.
 La quinta vista consiste en los casos de uso y los escenarios que podrían
 describir con más detalle el resto de las vistas.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Esquema-4+1"

\end_inset

 muestra un esquema con las cinco vistas del modelo.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Esquema4mas1.gif
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Esquema-4+1"

\end_inset

Esquema Modelo de Vistas 4 + 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A continuación se describen las distintas vistas que propone el modelo de
 vistas 4 + 1.
\end_layout

\begin_layout Subsubsection
Vista Lógica
\end_layout

\begin_layout Standard
La vista lógica del modelo soporta requerimientos de comportamiento y muestra
 cómo el sistema esta distribuido en un conjunto de abstracciones.
 Las clases y los objetos son los elementos mas estudiados por esta vista.
 Se pueden utilizar diagramas de clase, de colaboración y de secuencia,
 entre otros, para mostrar las relaciones entre los elementos.
 Los diagramas de clases muestran clases y sus atributos, métodos y asociaciones
 con otras clases del sistema.
\end_layout

\begin_layout Standard
Los diagramas de clases muestran una "imagen" completa del sistema.
 Por un lado, los diagramas de clase son estáticos, por lo tanto, no dicen
 nada sobre el sistema reacciona a los eventos de los usuarios.
 Por otro lado, estos diagramas son demasiado detallados como para ofrecer
 una idea general de la arquitectura de todo el sistema.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/DiagramaDeColaboracion.png
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-Colaboración"

\end_inset

Diagrama de Colaboración 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/DiagramaDeSecuencia.png
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-Secuencia"

\end_inset

Diagrama de Secuencia 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los diagramas de colaboración (o de comunicación) y de secuencia muestran
 cómo interactúan los objetos del sistema.
 Un diagrama de colaboración es una forma simple de mostrar los objetos
 del sistema y los mensajes y llamadas que pasan entre ellos.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-Colaboración"

\end_inset

 es un simple diagrama de colaboración en el que cada mensaje esta asociado
 a un número que indica el orden de la secuencia.
 Estos diagramas son muy prácticos para mostrar como los objetos colaboran
 en el sistema.
 Si se desea mostrar más detalles sobre la lógica del sistema, un diagrama
 de secuencias seria ideal (ver figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-Secuencia"

\end_inset

).
 Los diagramas de secuencia proveen mas detalles que los diagramas de colaboraci
ón pero siguen manteniendo la distancia de mostrar la arquitectura general
 de todo el sistema.
 Arquitectos y diseñadores suelen utilizar estos diagramas para refinar
 detalles el diseño.
 Por ejemplo, observando el diagrama de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-Secuencia"

\end_inset

 se podría realizar un cambio en el diseño si se desea que un nuevo objeto
 (
\family typewriter
Notifier
\family default
) responsable de notificar a cada 
\family typewriter
observer
\family default
 y que estas notificaciones corran en un proceso distinto.
\end_layout

\begin_layout Subsubsection
Vista de Desarrollo
\end_layout

\begin_layout Standard
La vista de desarrollo es usada para describir los módulos del sistema.
 Los módulos más bloques más grandes que las clases y los objetos y varían
 de acuerdo al ambiente de desarrollo.
 Los paquetes, sub-sistemas y las bibliotecas son considerados módulos.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-Paquetes"

\end_inset

 muestra como los paquetes de un sistema son anidados.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/DiagramaDePaquetes.png
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-Paquetes"

\end_inset

Diagrama de Paquetes 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
También es posible utilizar las vistas de desarrollo para estudiar la ubicación
 de los archivos del sistema y del ambiente de desarrollo.
 Adicionalmente, es una buena forma de visualizar las capas de un sistema
 si es que éste mantiene un estilo arquitectónico de capas.
 Un típico estilo arquitectónico de capas puede contener una capa para la
 presentación, otra capa de negocios y finalmente una capa de persistencia
 de datos.
\end_layout

\begin_layout Subsubsection
Vista de proceso
\end_layout

\begin_layout Standard
La vista de proceso permite describir y estudiar los procesos del sistema
 y como estos se comunican, si es que estos se comunican unos con otros.
 Una vista abstracta de los procesos y la comunicación de estos puede ayudar
 para advertir sobre errores.
 Esta vista es importante cuando el sistema posee múltiples y simultáneos
 procesos o 
\emph on
threads
\emph default
.
\end_layout

\begin_layout Standard
La vista de proceso puede descripta desde varios niveles de abstracción,
 comenzando desde la ejecución independiente de una red de comunicación
 de sistemas.
 Esta vista tiene en cuenta varios requerimientos no funcionales (atributos
 de calidad) como 
\emph on
performance
\emph default
, disponibilidad, etc.
 
\end_layout

\begin_layout Subsubsection
Vista Física
\end_layout

\begin_layout Standard
La vista física describe cómo la aplicación se instala y cómo se ejecuta
 en el una red de computadoras.
 Esta vista tiene en cuenta requerimientos no funcionales como la disponibilidad
, escalabilidad y 
\emph on
performance
\emph default
.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-Deployment"

\end_inset

 es un diagrama de 
\emph on
deployment
\emph default
 de un sistema web.
 Se tiene un nodo por cada usuario que corre el 
\emph on
browser
\emph default
 en su propia computadora.
 El sistema y la base de datos poseen sus propios nodos.
 Los nodos contienen una o mas computadoras.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/DiagramaDeDeployment.png
	width 20text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-Deployment"

\end_inset

Diagrama de 
\emph on
Deployment
\emph default
 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
La quinta vista
\end_layout

\begin_layout Standard
La quinta vista (+ 1) del modelo de vistas 4 + 1 consiste en los casos de
 uso y escenarios que podían describir con más detalle el resto de las vistas.
 Los casos de uso representan los aspectos funcionales del sistema.
 Sin embargo, en el caso del modelo vista 4 + 1, son utilizados para explicar
 la funcionalidad y las estructuras que describen las otras vistas.
 De esta forma, la vista de casos de uso consiste en diagramas de casos
 de uso y de especificaciones detalladas de las acciones y condiciones dentro
 de cada caso de uso.
\end_layout

\begin_layout Subsection
UML - Diagrama de Componentes
\end_layout

\begin_layout Standard
El principal objetivo de los diagramas de componentes es mostrar las relaciones
 estructurales entre los componentes de un sistema.
 Los componentes son considerados autónomos, encapsulando unidades entre
 un sistema o sub-sistema que provee una o más interfaces.
 La idea es que sea posible mostrar que los componentes se pueden reutilizar
 o remplazar por otros componentes de la arquitectura ya que un componente
 encapsula el comportamiento e implementa interfaces bien definidas.
 Adicionalmente, los diagramas de componentes son los más utilizados como
 medio de comunicación entre los distintos 
\emph on
stakeholders
\emph default
.
 Por ejemplo, los diagramas pueden ser presentados a los clientes ya que
 presentan un entendimiento del sistema completo en las primeras etapas
 de la ejecución de los proyectos.
 A su vez, los desarrolladores utilizan los diagramas de componentes ya
 que proveen la estructura del sistema que construirán en un alto nivel
 de abstracción.
\end_layout

\begin_layout Subsubsection
Notación
\end_layout

\begin_layout Standard
En la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:modelado-visual-componentes"

\end_inset

 se muestra una descripción básica de los diferentes elementos visuales
 que conforman la notación, junto con los conceptos asociados a cada uno
 de ellos.
 En la sección 
\family typewriter
a)
\family default
 de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:modelado-visual-componentes"

\end_inset

 se muestran distintas formas posibles de modelar un componente.
 El a sección 
\family typewriter
b)
\family default
 se muestran como se modelan las interfaces, 
\family typewriter
writeLog
\family default
 y 
\family typewriter
readLog
\family default
 son interfaces que provee el componente mientras que 
\family typewriter
dataSource
\family default
 es una interfaz que requiere.
 Finalmente, en la sección 
\family typewriter
c)
\family default
 se muestra cómo se relacionan los componentes.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/NotacionDiagramaDeComponentesUML.png
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:modelado-visual-componentes"

\end_inset

Modelado visual de los componentes en UML
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El diagrama de componentes es uno de los diagramas más importantes y es
 uno de los primero que se crean.
 Estos diagramas son invaluables porque modelan y documentan la arquitectura
 del sistema.
 Este tipo de diagrama es muy usado por los 
\emph on
stakeholders
\emph default
 para poder comprender el sistema.
 También sirve como entrada para otro tipo de diagramas como son los diagramas
 de 
\emph on
deployment
\emph default
.
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sec:Use-Case-Maps"

\end_inset

Use-Case Maps
\end_layout

\begin_layout Standard
Los 
\emph on
Use-Case Maps
\emph default
 (UCM) son una notación para diseño de alto nivel que ayuda a las personas
 tanto a expresar como a razonar acerca de los patrones de comportamiento
 de alta granularidad de un sistema 
\begin_inset LatexCommand cite
key "BUHR95"

\end_inset

.
 El nombre proviene del hecho de que son una notación visual para casos
 de uso y una extensión de ellos hacia el diseño de alto nivel.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y ...
 hay un NO son un lenguaje formal...] [andres] Esto esta confuso, y no se entiende
 a que apuntan las frases, por ejemplo palabras tipo: apropiado para especificac
ion formal (a mi me parece mas una notacion informal), decisiones deliberadament
e abiertas (cuales son, a que se refiere), y demas...
 Lo que es importante decir (y que el lector quiere sabes) es que "los UCMs
 combinan en una notacion de alto nivel el flujo global de comportamiento
 y la estructura de componentes", o algo similar ...
\end_layout

\begin_layout Standard
(si es que esto vino de alguna traduccion, revisarlo please para hacerlo
 mas entendible)
\end_layout

\end_inset

Sin embargo, el modelo no depende de la definición de casos de uso: provee
 su propia definición en sus propios términos.
\end_layout

\begin_layout Standard
Por sus cualidades, los UCMs son la notación elegida para representar las
 vistas comportamentales de las arquitecturas reconstruidas.
 Éstos combinan, en una notación de alto nivel, el flujo global del comportamien
to y la estructura de componentes del sistema.
 Los UCMs no son un lenguaje apropiado para especificación formal de comportamie
nto, ya que deliberadamente dejan algunas decisiones de diseño abiertas
 para ser tomadas durante el diseño detallado.
 Los UCM son solamente una notación para razonar y explicar el comportamiento
 de un sistema.
 Es importante de tener esto presente ya que es fácil caer en la trampa
 de buscar o colocar más información de la que corresponde encontrar en
 ellos.
\end_layout

\begin_layout Subsubsection
Notación básica e interpretación
\end_layout

\begin_layout Standard
A continuación se da una breve descripción de los diferentes elementos visuales
 que conforman la notación, junto con los conceptos asociados a cada uno
 de ellos.
 La idea principal detrás de los UCMs es la de modelar los casos de uso
 mediante secuencias causales (en adelante, 
\emph on
paths
\emph default
) a través de estructuras organizacionales, de esta manera combinando vistas
 estructurales y comportamentales de la arquitectura del sistema.
 Los UCMs tienen cuatro elementos principales: responsabilidades, paths,
 componentes y acoplamientos entre paths.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/responsibility.png
	scale 50

\end_inset

\InsetSpace ~
Responsabilidades.
 Expresan las funciones de las que cada componente es responsable.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/path.png
	scale 50

\end_inset

\InsetSpace ~
Paths.
 Trazan la progresión de causas y efectos entre responsabilidades.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/component.png
	scale 50

\end_inset

\InsetSpace ~
Componentes.
 Actúan como contenedores de responsabilidades.
\end_layout

\begin_layout Description
Acoplamientos.
 Sirven para conectar paths y así lograr patrones de mayor granularidad.
\end_layout

\begin_deeper
\begin_layout Description
\begin_inset Graphics
	filename img/andFork.png
	scale 50

\end_inset

\InsetSpace ~

\emph on
And\InsetSpace ~
Forks
\emph default
.
 Indican la bifurcación en dos 
\emph on
paths
\emph default
 concurrentes.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/andJoin.png
	scale 50

\end_inset

\InsetSpace ~

\emph on
And\InsetSpace ~
Joins
\emph default
.
 Indican la unión de dos 
\emph on
paths
\emph default
 concurrentes.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/orFork.png
	scale 50

\end_inset

\InsetSpace ~

\emph on
Or\InsetSpace ~
Forks
\emph default
.
 Indican el fin de un segmento causal común entre dos 
\emph on
paths
\emph default
.
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename img/orJoin.png
	scale 50

\end_inset

\InsetSpace ~

\emph on
Or\InsetSpace ~
Joins
\emph default
.
 Indican el comienzo de un segmento causal común entre dos 
\emph on
paths
\emph default
.
\end_layout

\end_deeper
\begin_layout Subsubsection
\begin_inset LatexCommand label
name "sub:Ejemplo-UCM"

\end_inset

Ejemplo
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableSample.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-de-UCM"

\end_inset

Ejemplo de UCM
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Ejemplo-de-UCM"

\end_inset

 muestra un ejemplo de UCMs, donde hay un simple escenario donde una modificació
n en el modelo requiere de la notificación a la interfase de usuario y a
 un 
\emph on
logger
\emph default
.
 El sistema está organizado alrededor de un patrón de diseño 
\emph on
Observer-Observable
\emph default
 
\begin_inset LatexCommand cite
key "gamma93design"

\end_inset

, en el cual el componente 
\emph on
Observable 
\emph default
y los componentes 
\emph on
Observers
\emph default
 están desacoplados.
 El ejemplo instancia el patron de la siguiente forma: el componente 
\emph on
UserModelObservable
\emph default
 representa el rol del 
\emph on
Observable
\emph default
 mientras que los componentes 
\emph on
UserInterfaceViewObserver
\emph default
 y de 
\emph on
UserLoggerObserver
\emph default
 son los 
\emph on
Observers
\emph default
.
 El componente 
\emph on
Main
\emph default
 es responsable de realizar los cambios al modelo.
 
\end_layout

\begin_layout Standard
La primer responsabilidad que se activa es 
\emph on
changeDataModel
\emph default
 y efectúa un cambio en el modelo.
 Luego la responsabilidad 
\emph on
notifyObservers
\emph default
 en el componente 
\emph on
UserModelObservable
\emph default
 es activada y envía una notificación de cambio a todos los 
\emph on
Observers
\emph default
.
 Ésto causa la activación de la respons
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Hacer referencia a cada parte de la notacion(es decir, nombre de los roles
 y porque son asi ..
 como userModel, userInterfaceView...etc...)..
 el amarillo es un poco fuerte..
 para el resto de los colores..
 por ahi ponerlos sin color de fondo a los comentarios 
\end_layout

\begin_layout Standard
El ejemplo parece demasiado simple..falta algun componente que efectue el
 inicio del cambio..
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] LAs figuras tiene que aparece lo mas cerca de la ref en el texto cuando
 generen el pdf..
 vi que hay bastante diferencia entre el parrafo que la referencia y donde
 aparece la figura...
\end_layout

\end_inset

abilidad 
\emph on
update
\emph default
 de los componentes 
\emph on
UserInterfaceViewObserver
\emph default
 y de 
\emph on
UserLoggerObserver
\emph default
 respectivamente.
\end_layout

\begin_layout Standard
Entre las múltiples representaciones gráficas posibles, una de las descripciones
 arquitectónicas elegidas para representar la arquitectura reconstruida
 de un sistema es la de UCMs, en especial, para representar el comportamiento
 
\begin_inset LatexCommand cite
key "BUHR95"

\end_inset

.
 A diferencia de otras descripciones arquitectónicas (basadas principalmente
 en mostrar la estructura de sistemas), este tipo de notaciones ayuda a
 las personas a razonar acerca del comportamiento del sistema.
 Otra de las razones principales de la elección de esta notación se basa
 en que permite la especificación conjunta de los principales aspectos arquitect
ónicos independientemente de la tecnología en la cual el sistema fue implementad
o.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Conclusión"

\end_inset

Resumen y discusión 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Este parrafo podria ir a la intro..
 esta bien escrito...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En este capítulo se introdujo el concepto de arquitectura de software, una
 disciplina que cumple un rol central en la toma de decisiones de diseño
 y en la comunicación entre todos los participantes del desarrollo de un
 producto de software.
 Como vehículo de comunicación, su documentación es fundamental, pues la
 falta de ella, o peor aún, el descuido al producirla y mantenerla, anulan
 o revierten todos los beneficios que el desarrollo centrado en la arquitectura
 puede aportar.
\end_layout

\begin_layout Standard
Posteriormente se presentaron distintas notaciones que usualmente se utilizan
 para representar arquitecturas de software: El modelo 4 + 1, los diagramas
 de componentes de UML y la notación Use Case Maps (UCMs).
 La notación de UCMs, un modelo para la descripción de patrones de comportamient
o y algunos aspectos estructurales en un alto nivel de abs\SpecialChar \-
trac\SpecialChar \-
ción y granularida
d.
 Esta notación es especialmente útil para la documentación de comportamiento
 a nivel arquitectónico, ya que permite expresar, analizar y comunicar las
 trazas causa-efecto que proyectan los casos de uso sobre el sistema.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]Este parrafo, y en especial la ultima parte, es un poco criptico/confuso,
 mejorar lo de "contextualmente irrelevantes"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En último lugar se ofreció una breve descripción al problema de la escasa
 documentación arquitectónica evidenciando su necesidad.
 Muchos sistemas de software carecen de documentación arquitectónica.
 En otros casos, debido a la evolución natural de un sistema de software,
 es muy probable que la arquitectura documentada y su implementación pierdan
 consistencia, lo que puede perjudicar todos los beneficios del desarrollo
 centrado en la arquitectura.
 Éste problema ha motivado la creación de herramientas que, mediante diversos
 enfoques, intentan reconstruir representaciones arquitectónicas útiles
 para documentar la arquitectura.
 El capítulo siguiente se centra precisamente en estas herramientas.
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Trabajos-relacionados"

\end_inset

Trabajos relacionados
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Esto podria ir en el contexto..o juntar ambas secciones..
\end_layout

\end_inset

El problema de la falta de documentación arquitectónica o incluso su desactualiz
ación, como así también la re-ingeniería y la falta de sincronización entre
 arquitectura e implementación constituyen los principales motivadores de
 este trabajo.
\begin_inset Note Note
status open

\begin_layout Standard
Y concluir el contexto con los trabajos relaciones que fueron la base de
 la motivacion de este trabajo..
 porque las limitaciones encontrdas en los enfoques actuales proveniente
 del analisis de los trabajos relacionados tambien es parte de la motivacion
 de este trabajo..
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En este capítulo se brinda una visión mas amplia sobre los distintos aportes
 existentes relacionados con la reconstrucción de arquitecturas, destacando
 los rasgos principales de cada enfoque.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
X Muchos enfoques de reconstrucción de arquitecturas y herramientas para
 apoyar dichos enfoques han sido cubiertos en la literatura.
 !!! no se entiende!!
\end_layout

\end_inset

La mayoría de los enfoques y herramientas para reconstrucción de arquitecturas
 están basados en un ciclo "extraer-abstraer-presentar", en el cuál el sistema
 es analizado con el propósito de popular un repositorio, que luego es consultad
o para poder construir representaciones abstractas del sistema que son presentad
as en forma interactiva y adecuada al ingeniero de software.
 Tilley et.
 al 
\begin_inset LatexCommand cite
key "Tilley1996"

\end_inset

 describe el enfoque extraer-abstraer-presentar con mayor detalle, refiriéndose
 a los pasos de recolección de información, inferencia de conocimiento,
 y presentación de la información.
\end_layout

\begin_layout Standard
En la siguiente sección se resumirán aquellos trabajos que tratan la reconstrucc
ión de arquitecturas de software y se discutirán los enfoques tomados por
 ellos.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Aportes-científicos-relacionados"

\end_inset

Aportes relacionados
\end_layout

\begin_layout Standard
La problemática de descubrir el modelo arquitectónico de un sistema completament
e implementado ha sido abordado de diversas maneras.
 Entre ellos se encuentran enfoques de reconstruccion manuales apoyados
 con herramientas de visualización o de extraccion de informacion, aquellos
 que implementan lenguajes de consultas para escribir pautas para construir
 clusteres o agregaciones automáticamente, y tambien aquellos que implementan
 técnicas diversas como mineria de datos ("
\emph on
data mining
\emph default
"), lenguajes de descripcion arquitectónica (ADLs), redes de Petri o matrices
 de dependencias (DSM).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
X Esta clasificacion es de ustedes o la sacaron de algun lado.??
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Utilización de otras técnicaCUales?? en que categoria caen..
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Standard
Estan clasificando desde el inicio entre estructura y comportamiento y ahora
 las clasifican de otra manera...
\end_layout

\begin_layout Standard
por lo menos una distincion deberia ir a ca..
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
For each tool/approach:
\end_layout

\begin_layout Standard
* what it does input language(s) (e.g., is it source code only or does it
 include things like makefiles?) 
\end_layout

\begin_layout Standard
* output 
\end_layout

\begin_layout Standard
** what views does it (help) build; code/module views or runtime/C&C views?
 
\end_layout

\begin_layout Standard
** what are the elements and relationships of these views 
\end_layout

\begin_layout Standard
** can the output be externalized (other than screen shots)? any flexibility/cus
tomizability in format? 
\end_layout

\begin_layout Standard
* does it support abstraction (i.e., the developer can define architectural
 concepts and their mapping to code constructs)? 
\end_layout

\begin_layout Standard
* use examples
\end_layout

\begin_layout Standard
**published case studies 
\end_layout

\begin_layout Standard
**anything that hints at scope capabilities or usability 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph

\emph on
Portable Bookshelf
\emph default
 (PBS)
\end_layout

\begin_layout Standard

\emph on
Portable Bookshelf 
\emph default
(PBS) es una herramienta usada para generar una biblioteca de software (
\emph on
bookshelf
\emph default
) 
\begin_inset LatexCommand cite
key "Finnigan97"

\end_inset

.
 La información contenida en la biblioteca incluye código fuente como también
 así cualquier otra documentación sobre el sistema como pueden ser casos
 de test, análisis de 
\emph on
performance
\emph default
, planes futuros, diagramas arquitectónicos e información sobre la historia
 del proyecto.
 
\end_layout

\begin_layout Standard
El Software Bookshelf se accede por medio de un conjunto de páginas Web.
 Hay una página para cada uno de los subsistemas que componen el sistema
 evaluado.
 Cada una de estas páginas son a veces llamadas estantes (
\emph on
shelves
\emph default
).
 Las mismas están organizadas de manera jerarquica, lo que refleja la descomposi
ción del sistema en subsistemas.
 A su vez cada página esta vinculada a las páginas de los subsistemas y
 muestran un diagrama de arquitectura llamado "paisaje" de su subsistema,
 y que esta vinculado al código fuente y a la documentación de los subsistemas.
 La figura 
\begin_inset LatexCommand ref
reference "fig:PBS-Example."

\end_inset

 muestra un "paisaje" de un sistema ejemplo [referencia a la pagina : http://swa
g.uwaterloo.ca/pbs/examples/C488/V1/index.html].
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename img/PBS_Example.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:PBS-Example."

\end_inset

Ejemplo de PBS analizando el compilador c488.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
PBS esta compuesto por una serie de herramientas que ayudan en la contrucción
 de 
\emph on
"Bookshelves"
\emph default
:
\end_layout

\begin_layout Standard
Extractores: Los exrtactores parsean el código fuente y generan lo hechos
 correspondientes.
 Los hechos facilitan la construcción del grafo de dependencias.
 Existen extractores para algunos lenguajes como c y pascal.
\end_layout

\begin_layout Standard
Manipuladores de hechos: Los hechos producidos por los extractores (o por
 alguna otra fuente, incluida la preparación manual) son efectivamente una
 base de datos, la cual puede ser manipulada.
 Una herramienta llamada Grok opera sobre hechos excritos en RSF y es usado
 para leer los hechos y crear los hechos (sub grafos) para cada subsistema.
 
\end_layout

\begin_layout Standard
Disennnnador de diagramas: Los grafos tienen atributos que determinan el
 "layout" del mismo.
 Estos dan la posición, tamannnno y colores de los grafos para poder dibujarlos
 como diagramas.
 La herramienta llamada Layouter lee los hechos que representan el grafo
 y les agrega atributos de layout.
\end_layout

\begin_layout Standard
Visualizador de diagramas: Hay una herramienta llamada LS (Landscape) Viewer
 que lee grafos consus atributos de layout y lo muestra como un diagrama
 en la pantalla.
\end_layout

\begin_layout Standard
Cada vez que el sistema es "built", hechos relevantes (como llamadas a procedimi
entos y referencias a datos) son extraidas de éste.
 Mediante la comparación con los hechos anteriores con los nuevos, se detectan
 nuevos archivos, llamados "huerfanos".
 Un algoritmo los asigna automáticamente a un subsistema y tambien provee
 de información de layout para la actualización de los diagramas.
\end_layout

\begin_layout Paragraph
Rigi
\end_layout

\begin_layout Standard
Rigi es una herramienta visual e interactiva diseñada para ayudarle a comprender
 mejor y re-documentar un sistema de software
\begin_inset LatexCommand cite
key "RIGI2002"

\end_inset

.
 En Rigi, los artefactos están almacenados en un repositorio subyacente
 y manipulados a través de de una herramienta llamada 
\emph on
rigiedit
\emph default
, que provee la edición, la manipulación y capacidades de exploración.
 Rigi también incluye parsers que extraen los artefactos del sistema de
 software.
 Un modelo de dominio especifica los tipos de entidad y las relaciones de
 interés.
 El flujo de entrada alimenta 
\emph on
rigiedit
\emph default
 el cual representa visualmente el gráfico inicial.
 
\end_layout

\begin_layout Standard
Para gestionar la complejidad del, 
\emph on
rigiedit
\emph default
 permite seleccionar, filtrar, diseñar y modificar el gráfico para identificar
 los subsistemas pertinentes (automática o manualmente colapsando artefactos
 relacionados en subsistemas).
 Estos subsistemas suelen representar conceptos tales como tipos de datos
 abstractos
\end_layout

\begin_layout Standard
El nuevo gráfico creado es más simple, está organizado jerárquicamente,
 se puede navegar, analizar y presentar utilizando diversos layouts de forma
 automática o guiada por el usuario.
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-Rigi"

\end_inset

 muestra la secuencia de pasos desde que el grafo inicial es armado hasta
 la vista final, con subsistemas colapsados y diagramados jerárquicamente.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename img/RIGI_sample.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-Rigi"

\end_inset

Ejemplo Rigi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El principal aporte de esta herramienta son los 
\emph on
parsers
\emph default
 para extraer la información de varios lenguajes en un formato propio, Rigi
 Standard Format (RSF) los cuales han sido usados extensamente por otras
 herramientas de reconstrucción como Dali y SHriMP.
\end_layout

\begin_layout Paragraph
SHriMP
\end_layout

\begin_layout Standard
SHriMP (Simple Hierarchical Multi-Perspective) es un sistema de visualización
 y navegación de la información 
\begin_inset LatexCommand cite
key "Storey2001,Shrimp2002"

\end_inset

.
 SHriMP utiliza grafos anidados para presentar la información que está jerárquic
amente organizada.
 Introduce el concepto de vistas "anidadas-intercambiables" permitiendo
 a los usuarios a explorar múltiples perspectivas de la información en diferente
s niveles de abstracción.
 
\end_layout

\begin_layout Standard
Este enfoque presta especial atencion a la "metafora" visual utilizada para
 explorar e investigar el código, por ejemplo, utilizando distitnos tipos
 de vistas jerarquicas y distintos tipos de zoom (normal, semantico, fish_eye).
 Cuando es usado para reconstrucción, la herramienta puede asistir al usuario
 en generar vistas arquitectónicas de alto nivel agrupando manualmente elementos
 en un grafo.
 La herramienta toma como entrada archivos RSF (Rigi Standard Format).
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-SHriMP"

\end_inset

 muestra la herramienta en acción.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename img/SHriMP_sample.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-SHriMP"

\end_inset

Ejemplo SHriMP.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Mitre
\end_layout

\begin_layout Standard
ManSart (MITRE Software Architecture Recovery Tool.
 ManSART reconoce caracteristicas arquitectónicas en el código fuente mediante
 el uso de una libreria de "reconocedores".
 Características arquitectónicas se consideran aquellas partes que constituyen
 los estilos arquitectónicos que a su vez definen los principios organizacionale
s que guían a los programadores en el desarrollo de código.
 Ejemplos de estilos arquitectónicos son "task spawning", pipe and filter,
 tipos abstractos de datos y repositorios.
 (re escribir) ManSART esta construido en base a mecanismos de análisis
 de código fuente.
 El proceso de reconstrucción pasa secuencialmente por tres etapas: reconocimien
to, manipulación y presentación.
 Al comenzar el análisis se genera un conjunto de vistas iniciales del sistema.
 Despues de parsear el código llevandolo a una representación arbol de análisis
 sintáctico (AST), los "reconocedores" detectan las características arquitectóni
cas llevandolas a vistas que corresponden a varios estilos arquitectónicos.
 Estos reconocedores usan tres niveles de representacion: AST, reconocimiento
 de caracteristicas y reconocimiento de estilos arquitectónicos.
 El primero se usa como base de los demas.
 El segundo, se basa en un conjunto de patrones que emplean modelos específicos
 del lenguaje y del sistema operativo para reconocer porciones de código
 que forman partes de implementaciones de estilos arquitectónicos.
 Este nivel de reconocimiento se hace sobre AST y abstracciones de los flujos
 de datos y de control.
 Por ultimo, el nivel de reconocimiento de estilos arquitectónicos agrupa
 aquellas características reconocidas en el nivel anterior para reconocer
 un estilo arquitectónico.
 La herramienta tiene una poderosa interfaz gráfica que permite la edicion
 y manipulación manual de las vistas generadas.
\end_layout

\begin_layout Paragraph
AMR (
\emph on
Architecture Reconstruction Method
\emph default
) - Dali 
\end_layout

\begin_layout Standard
ARM es un método de reconstrucción de arquitecturas semi-automático el cual
 puede ser usado para asistir en la recuperación de arquitecturas para sistemas
 que son diseñados e implementados usando patrones 
\begin_inset LatexCommand cite
key "GUO99"

\end_inset

.
 ARM consiste de cuatro fases principales: 
\end_layout

\begin_layout Enumerate
Desarrollo de un plan para reconocer patrones concretos, 
\end_layout

\begin_layout Enumerate
extracción de un modelo a partir del código fuente, 
\end_layout

\begin_layout Enumerate
detección y evaluación de instancias de patrones y 
\end_layout

\begin_layout Enumerate
reconstrucción y análisis de la arquitectura.
 
\end_layout

\begin_layout Standard
El mecanismo es simple, reglas que definen patrones son transformadas en
 consultas que serán aplicadas automáticamente para detectar instancias
 de dichos patrones en el modelo.
 Refinando dichas consultas de patrones se puede mejorar la precisión en
 la detección de patrones.
\end_layout

\begin_layout Standard
Dali es la herramienta desarrollada para ejercitar el metodo descripto anteriorm
ente.
 Es una colección de he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
tas en la forma de workbench.
 Entre estas he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
tas se destacan Rigi y PostgreSQL como repositorio
 de la aplicación.
 Rigi provee la manipulación y visualización de las vistas generadas y la
 extensión que aporta Dali a Rigi provee la habilidad de definir y aplicar
 patrones de consultas sobre los datos para generar vistas arquitectónicas
 del sistema.
 La información es extraída del código fuente utilizando una he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
ta
 de análisis y luego cargadas en Dali.
 Esta información es almacenada en la base de datos PostgreSQL y visualizada
 en Rigi.
 Las consultas son escritas en combinación de SQL y Perl con el propósito
 de generar abstracciones de la información.
 
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Arquitectura Dali"

\end_inset

 muestra como es la arquitectura de Dali.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/dali workbech.PNG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Arquitectura Dali"

\end_inset

Arquitectura Dali
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Riva 
\end_layout

\begin_layout Standard
Claudio Riva y Yang Yaojin desarrollaron un proceso de reconstrucción de
 arquitecturas y apoyado por varias herramientas y lenguajes (Rigi, scripts
 Perl, Prolog).
 El proceso consta de cuatro pasos, que se aplican iterativamente con el
 fin de extraer vistas cada vez más centradas en la arquitectura de un sistema.
 Los cuatro pasos son: 
\end_layout

\begin_layout Standard
1.
 Definición de conceptos importantes de arquitectura basandose en la documentaci
ón y en el conocimiento de los desarrolladores.
 
\end_layout

\begin_layout Standard
2.
 Recopilación de datos, en la que un modelo del sistema es construido en
 términos de los conceptos definidos en el paso 1.
 
\end_layout

\begin_layout Standard
3.
 Abstracción, en la que el modelo es enriquecido con abstracciones (espec'ificas
 del dominio) que conducen a una vista de mas alto nivel del sistema.
\end_layout

\begin_layout Standard
4.
 Presentación de la arquitectura reconstruida en varios formatos, como gráficos,
 diagramas UML, y graficos de secuencia de mensajes, teniendo en cuenta
 la vista arquitect'onica necesaria (lógica, de procesos, física, de desarrollo).
 La extracción del modelo desde el código fuente es apoyado por analizadores
 de código fuente.
 Las abstracciones se calculan utilizando reglas Prolog.
 La presentación de los resultados se realiza a través de Rigi 
\begin_inset LatexCommand cite
key "Riva2000"

\end_inset

.
\end_layout

\begin_layout Paragraph
DiscoTect
\end_layout

\begin_layout Standard
Este enfoque se basa en el mapeo de eventos de bajo nivel del sistema a
 operaciones arquitectónicas abstractas; interpretadas luego por un motor
 especial que ﬁnalmente construye la estructura arquitectónica del sistema
 en tiempo de ejecución como una descripción ACME 
\begin_inset LatexCommand cite
key "ACME"

\end_inset

.
 La idea principal de este trabajo es traducir estilos de implementación
 a estilos arquitectónicos.
 La traducción se deﬁne conceptualmente como una red de Petri coloreada
 
\begin_inset LatexCommand cite
key "JENSON94"

\end_inset

, empleada durante la ejecución para interpretar los eventos de bajo nivel
 y traducirlos cuando corresponda a eventos arquitectónicos, como por ejemplo:
 creación de componentes, establecimiento de conexiones entre ellos, etc.
 Los eventos de bajo nivel son instrucciones Java ejecutadas sobre una máquina
 virtual y se obtienen instrumentando el programa mediante AspectJ 
\begin_inset LatexCommand cite
key "AOP01"

\end_inset

.
 La arquitectura de la herramienta DiscoTect puede observarse en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Arquitectura-DiscoTect"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/discotectArch.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Arquitectura-DiscoTect"

\end_inset

Arquitectura de la herramienta DiscoTect
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La red de Petri coloreada se obtiene como resultado de la compilación de
 una especiﬁcación escrita en un lenguaje especial llamado DiscoStep.
 DiscoStep fue diseñado para traducir la ejecución de instrucciones Java
 a eventos arquitectónicamente signiﬁcativos, considerando que la aridad
 de esta relación entre ambos tipos es n-m y que normalmente los eventos
 de alto nivel pueden ocurrir simultáneamente cuando el sistema bajo análisis
 posee varios procesos o hilos de ejecución concurrentes.
 Para que esta especiﬁcación sea efectiva, el programador debe seguir estrictame
nte los estilos de implementación que permitirán construir correctamente
 la red de Petri coloreada.
 Por ejemplo, si el sistema respeta el estilo arquitectónico cliente-servidor
 
\begin_inset LatexCommand cite
key "BUSCHMANN96"

\end_inset

, el programador deberá codiﬁcar las clases Java signiﬁcativas para este
 estilo como “cliente”, “servidor” y “conexión cliente-servidor” con alguna
 convención que ayude a la red de Petri a detectar estos eventos.
 Si la especiﬁcación DiscoStep espera que el servidor sea representado por
 un 
\emph on
socket
\emph default
 TCP con el suﬁjo “ServerSocket”, el programador deberá seguir este estándar
 para que el mecanismo sea efectivo.
 Los autores de esta herramienta aseguran bajo la condición de que las implement
aciones respeten siempre los mismos estilos, que DiscoTect puede monitorear
 diferentes sistemas sin que sea necesario modiﬁcar la especiﬁcación del
 mapeo entre eventos de bajo nivel y eventos de alto nivel, es decir, sin
 cambiar el código DiscoStep.
 Aunque este enfoque es interesante para visualizar la evolución de una
 arquitectura durante la ejecución de su implementación, es importante hacer
 notar que esta evolución se representa en términos estructurales de la
 arquitectura, en otras palabras, como los componentes y sus conectores
 se reconﬁguran entre si de acuerdo a las distintas situaciones que pueden
 ocurrir en el sistema.
 Los autores de DiscoTect han reportado dos casos de estudio de sistemas
 legados, en los que recuperaron tanto un estilo 
\emph on
pipe-and-ﬁlter
\emph default
 como uno cliente-servidor.
 La herramienta todavía necesita ser evaluada con estilos arquitectónicos
 más complejos, donde los mapeos a código no son necesariamente directos.
 
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-DiscoTect"

\end_inset

 muetra un ejemplo de arquitectura recuperada con DiscoTect.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename img/discotectExample.PNG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-DiscoTect"

\end_inset

Ejemplo DiscoTect
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Focus
\end_layout

\begin_layout Standard
Focus 
\begin_inset LatexCommand cite
key "MEDVIDOVIC06"

\end_inset

 propone un enfoque en el cual su objetivo es extraer una descripción estructura
l de la arquitectura en función de la información provista por su implementación
 y el desarrollador.
 El código fuente de una aplicación es analizado estáticamente para obtener
 un diagrama de clases UML y luego las clases interrelacionadas son agrupadas
 en componentes.
 Los mapeos deﬁnen a los componentes como un grupo de clases relacionadas.
 El proceso de 
\emph on
clustering
\emph default
 para determinar los componentes utiliza diferentes políticas, principalmente
 basadas en las relaciones de dependencia entre clases Java.
 Los casos de uso son especiﬁcados por el arquitecto y luego chequeados
 parcialmente en base a la inspección de código fuente.
 Como desventajas, se puede mencionar la escasa automatización (por ejemplo,
 las abstracciones deben ser realizadas por el usuario) y nuevamente, la
 falta de soporte para aspectos comportamentales de la arquitectura como
 es el caso de las representaciones UCM.
\end_layout

\begin_layout Standard
Focus
\begin_inset LatexCommand cite
key "MEDVIDOVIC06"

\end_inset

 es el fruto de un enfoque basado en ingeniería reversa.
 Su objetivo es extraer una descripción estructural de la arquitectura en
 función de la información provista por su implementación y el desarrollador.
 El código fuente de una aplicación es analizado estáticamente para obtener
 un diagrama de clases UML y luego las clases interrelacionadas son agrupadas
 en componentes.
 Este enfoque mantiene los mapeos entre arquitectura e implementaci´on durante
 la evoluci´on apli- cando el proceso de descubrimiento incrementalmente
 sobre las porciones de código fuente modiﬁcadas.
 Los mapeos deﬁnen a los componentes como un grupo de clases relacionadas.
 El proceso de clustering para determinar los componentes utiliza diferentes
 políticas, principalmente basadas en las relaciones de dependencia entre
 clases Java.
 Los casos de uso son especiﬁcados por el arquitecto y luego chequeados
 parcialmente en base a la inspección de código fuente.
 La Figura MMMASMDMMAD ilustra las principales actividades ordenadas parcialment
e realizadas por Focus para recuperar una arquitectura.
 El enfoque es interesante para propagar cambios desde la implementación
 hacia la arquitectura.
 La virtud principal, radica en reﬁnar progresivamente la vista arquitectónica
 en función de los cambios sucesivos del código, en lugar de intentar recuperarl
a íntegramente con un único análisis exhaustivo.
 Como desventajas, se puede mencionar la escasa automatización (por ejemplo,
 las abstracciones deben ser realizadas por el usuario) y nuevamente, la
 falta de soporte para aspectos comportamentales de la arquitectura como
 es el caso de las representaciones UCM.
\end_layout

\begin_layout Paragraph
KLOCwork’s Architecture Excavation method (KAE)
\end_layout

\begin_layout Standard
KAE es un enfoque que aborda la especiﬁcación UCM y emplea mecanismos de
 ingeniería reversa (Amyot et.
 al.
 
\begin_inset LatexCommand cite
key "AMYOT-SAM02"

\end_inset

), extrae escenarios UCM a partir del análisis estático de código C++.
 Su ﬁnalidad es ayudar al nuevo desarrollador a comprender la arquitectura
 “escondida” detrás de una implementación preexistente.
 
\end_layout

\begin_layout Standard
KAE utiliza una técnica híbrida basada en entrevistas (
\emph on
interviews
\emph default
) y etiquetado (
\emph on
tagging
\emph default
).
 Las entrevistas permiten obtener escenarios iniciales en base a charlas
 con de\SpecialChar \-
sa\SpecialChar \-
rro\SpecialChar \-
lla\SpecialChar \-
do\SpecialChar \-
res involucrados y también mediante la inspección del código,
 por esta razón, esta técnica es completamente manual.
 El etiquetado, también de carácter manual, es un proceso donde el desarrollador
 asocia etiquetas semánticas a diferentes porciones del código fuente; más
 tarde estas etiquetas representarán responsabilidades de distintos componentes
 de la arquitectura.
 KAE aproxima los casos de uso iniciales, en forma de trayectorias a través
 de las diferentes etiquetas colocadas en el código fuente.
 
\end_layout

\begin_layout Standard
La herramienta ofrece un compilador para generar un modelo estructural rudimenta
rio de la arquitectura.
 Este modelo será transformado i\SpecialChar \-
te\SpecialChar \-
ra\SpecialChar \-
ti\SpecialChar \-
va\SpecialChar \-
men\SpecialChar \-
te para incrementar el nivel
 de abstracción y para eliminar cualquier dependencia intercomponente accidental.
 La estructura estática de la arquitectura es representada por medio de
 diagramas de paquete UML: los paquetes simbolizan componentes y las dependencia
s entre ellos, sus conexiones.
 Las conexiones entre componentes se detectan analizando las dependencias
 entre clases C++ pertenecientes a diferentes paquetes.
 La abs\SpecialChar \-
trac\SpecialChar \-
ción sub\SpecialChar \-
si\SpecialChar \-
guien\SpecialChar \-
te del modelo queda a cargo del usuario, quien
 tiene a su disposición para este propósito, dos operaciones: agregación
 y ajuste.
 La agregación permite seleccionar distintos bloques y agruparlos creando
 un nuevo nivel en la jerarquía.
 
\end_layout

\begin_layout Standard
El ajuste es otra operación visual donde se mueven bloques para eliminar
 dependencias entre paquetes de niveles mas altos que fueron introducidos
 por emplazamientos accidentales de funcionalidad a nivel de archivo.
 Como las etiquetas se aplicaron antes al código fuente y éste ya ha sido
 abstraído en componentes, la herramienta ahora es capaz de generar Use
 Case Maps como trayectorias a través de las distintas etiquetas colocadas
 en distintos puntos dentro de los paquetes (que ahora son vistos como component
es).
 
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-KAE"

\end_inset

 es un ejemplo de un UCM recuperado con KAE.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename img/KAEScreenshot.PNG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-KAE"

\end_inset

Ejemplo KAE
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aunque éste es uno de los pocos enfoques que apunda a recontruir aspectos
 de comportamiento, se realizan demasiadas tareas manuales y otras tantas
 aplicando simpliﬁcaciones gruesas, que introducen errores extra, como es
 el caso de suponer que existe una división de componentes que coincide
 perfectamente con la estructura jerárquica de paquetes del proyecto, o
 crear trayectorias UCM en base al análisis estático del código, cuando
 en realidad la especiﬁcación es inherentemente comportamental.
 Además, es el usuario quien determina en todo momento cuáles son las responsabi
lidades y las trayectorias de los distintos escenarios, limitando considerableme
nte la extracción de información.
\end_layout

\begin_layout Subsubsection
Lattix LDM
\end_layout

\begin_layout Standard
Lattix LDM™ ataca los factores de comunicación, visualización, análisis
 y gestión de las arquitecturas mediante una técnica distinta a las descriptas
 anteriormente.
 Lattix afirma que el manejo de las dependencia entre los módulos es crítico
 para la gestión de proyectos de software.
\end_layout

\begin_layout Standard
Lattix aplica técnicas DSM para llevar a cabo su análisis.
 Dependency Structure Matrix (DSM) es un enfoque para manejar la complejidad
 de un sistema haciendo foco en las interdependencias y los flujos de informació
n dentro y entre los diferentes dominios.
 
\end_layout

\begin_layout Standard
DSM permite a los desarrolladores comunicar la arquitectura de productos
 complejos.
 Es tambien una herramienta que permite a los managers entender el impacto
 de futuras revisiones y evaluar los riesgos asociados con las tareas de
 desarrollo.
 Lattix LDM realiza un análisis de dependencias a partir de la estructura
 de paquetes del sistema en el caso de java, namespaces en .Net y en la estructur
a del sistema de archivos para el caso de C/C++.
\end_layout

\begin_layout Standard
Esta aplicación esta destinada a ser parte del proceso de desarrollo.
 Ataca el problema de la erosion de la arquitectura, permite mantener actualizad
a la información arquitectónica con respecto a la implementacíon.
 
\end_layout

\begin_layout Standard
La forma de visualizacíon de la arquitectura utilizando DSM tiene beneficios
 en comparación con otras métodos como UML.
 Por ejemplo, la figura 
\begin_inset LatexCommand ref
reference "fig:Comparación-Ant"

\end_inset

 muestra el modelo UML de Ant, una herramienta para hacer builds de aplicaciones.
 En ella se puede ver el primer problema: la escalabilidad.
 Mientras UML es exelente para mostrar las relaciones entre clases, grandes
 proyectos rápidamente rebalsan este tipo de representaciones gráficas al
 querer representar todo el sistema.
 Además es muy dificil mantener este modelo actulizado a medida que el código
 cambia.
 Por último, es imposible detectar referencias cruzadas en este tipo de
 modelos.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename img/antExample.png
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Comparación-Ant"

\end_inset

Comparación UML y DSM: Ant.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Structure 101
\end_layout

\begin_layout Standard
Structure101, desarrollado por Headway Software Technologies, es una herramienta
 versatil de análisis estátco de código orientada al análisis de estructura
 (disenno, arquitectura y packaging) del codigo java, C/C++ y Ada.
 Structure 101 evalua el código desde varias perspectivas.
 Dispone de una perspectiva cualitativa, en la que mejora el entendimiento
 de la estructura del código.
 Tiene una perspectiva gráfica, en la que se pueden construir diagramas
 la organizacion y las estructuras referenciadas dentro de un bloque de
 código la figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-Structure-101"

\end_inset

 muestra un ejemplo.
 Cuenta asimismo con una perspectiva cuantitativa en la que evalua numericamente
 la complejidad del codigo y de esa manera prove metricas.
 Por ultimo, cuenta con una perspectiva historica, en la que revela cambios
 en la estructura del codigo.
 Al igual que Lattix utiliza DSM para visualizar las dependencias.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/structure101_sample.png
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-Structure-101"

\end_inset

Ejemplo Structure 101
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Resumen de características principales
\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="7">
<features rotate="true">
<column alignment="center" valignment="middle" leftline="true" width="12text%">
<column alignment="center" valignment="middle" leftline="true" width="15text%">
<column alignment="center" valignment="middle" leftline="true" width="10text%">
<column alignment="center" valignment="middle" leftline="true" width="15text%">
<column alignment="center" valignment="middle" leftline="true" width="11text%">
<column alignment="center" valignment="middle" leftline="true" rightline="true" width="15text%">
<column alignment="center" valignment="middle" rightline="true" width="13text%">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\align center

\series bold
Nombre
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Y estructura y comportamiento???
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Motivación
\end_layout

\begin_layout Standard
(Reconstrucción, Conformance, Comunicación)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\align center

\series bold
Tipo de análisis
\end_layout

\begin_layout Standard
(incremental/no incrementa)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\align center

\series bold
Análisis implementación
\end_layout

\begin_layout Standard
(análisis estático: codigo fuente; dinamico: trazas de ejecución)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Lenguaje arquitectónico 
\series default
(notación de la arq recuperada)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Soporte para varias fuentes de datos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Estructura / Comportamiento
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
PBS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Carga manual de la informacion que no sea código.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Rigi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No incremental.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático (dinamico, si se carga la información de trazas en formato RSF)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Si, se cargan manualmente en formato RSF.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Shrimp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No incremental.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No hace análisis es una herramienta de visualización.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
"boxes and lines"
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Si, se cargan los datos en formato RSF.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Mitre
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reconstrucción- Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
UML
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" newpage="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Dali
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reconstrucción- Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No en forma automática.
 Se tendrian que incorporar los datos a Dali en formato RSF.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estrutura
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Riva
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reconstrucción - Comunicación
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No en forma automática.
 Se tendrian que incorporar los datos a en forma de hechos Prolog.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DiscoTect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reconstrucción-Conformance
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
dinámico.
\end_layout

\begin_layout Standard
Traducción eventos de implementación, eventos arquitectónicos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ACME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Focus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reconstrucción
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático.
 Clustering clases, análisis incremental asistido por el usuario
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
UML
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
KAE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reconstrucción
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Incremental 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático (informaci'on de como se comporta el sistema es realizado mediante
 entrevistas - subjetivo)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
UML-UCM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura/Comportamiento.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Lattix LDM™
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Conformance - Reconstrucción
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DSM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Structure 101
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Conformance - Reconstrucción
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No incremental
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
estático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Dependency Graphs-DSM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Estructura
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Características-principales-de"

\end_inset

Características principales de los distintos enfoques
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las propiedades de cada enfoque resumidas en esta sección son las siguientes:
\end_layout

\begin_layout Itemize
Motivación: Esta propiedad se refiere al fin que tiene dicha herramienta/enfoque.
 Si apunta a solucionar los problemas de erosión arquitectónica o a la reconstru
cción de la arquitectura y a su comunicación.
\end_layout

\begin_layout Itemize
Tipo de análisis: Tipo de análisis se refiere si el análisis que realiza
 la herramienta es incremental, elevando cada vez mas el nivel de detalle
 o abstracción.
 O es no incremental y el análisis se realiza de una sola vez.
\end_layout

\begin_layout Itemize
Tipo de Analisis de la implementacíon (Estático/Dinámico): Si se consideran
 para el análisis el codigo fuente, ya sea codigo fuente o código compilado,
 el tipo de análisis es estático.
 Si por el contrario se consideran las trazas de ejecución, recolectadas
 con el sistema en ejecución, el análisis es dinámico.
 Como se ve, esta caracter'istica est'a fuertemente relacionada con el tipo
 de entrada que la herramienta/enfoque considera.
\end_layout

\begin_layout Itemize
Lenguaje arquitectónico: Lenguaje arquitectónico de las vistas generadas.
 Ejemplos son UML, UCMs, DSM etc.
\end_layout

\begin_layout Itemize
Soporte para varias fuentes de datos: Es posible incorporar datos de otras
 fuentes como documentación, experiencia de los arquitectos etc?
\end_layout

\begin_layout Itemize
Estructura / Comportamiuento: Esta propiedad refleja el aspecto de la arquitectu
ra recuperada.
 Si apunta a recuperar aspectos estructurales (estructura de los modulos
 y sus dependencias) o comportamentales (interoperabilidad de los módulos
 bajo ciertos escenarios de ejecución).
\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Standard
X Analisis de la categorizacion??
\end_layout

\end_inset


\end_layout

\begin_layout Section
Análisis y Conclusiones 
\end_layout

\begin_layout Standard
En este capítulo se han presentado los trabajos relacionados más importantes
 que tratan la reconstrucción de arquitecturas.
\end_layout

\begin_layout Standard
Como vimos, la mayoría de los enfoques actuales de reconstrucción de arquitectur
as se basan en el análisis del código fuente del sistema.
 Este tipo de técnicas trabajan adecuadamente si la implementación del sistema
 se encuentra organizada en patrones tanto de codificación como de modularizació
n.
 Sin embargo, estas técnicas se ven limitadas cuando las estructuras del
 sistema son conocidas en tiempo de ejecución.
 Es decir, cuando la determinación del componente responsable de un aspecto
 en particular es realizada en tiempo de ejecución (por ejemplo, clases
 cargadas dinámicamente en los sistemas orientados a objetos).
 En efecto, determinar la configuración arquitectónica real de un sistema
 usando análisis estático es, en general, indecidible.
 Por ejemplo suponer que existe una division de componentes que coincide
 perfectamente con la estructura jerárquica de paquetes de proyectos es
 generar una simplificación muy gruesa, que introduce errores extra.
 Lo mismo ocurre al basar el 
\emph on
clustering
\emph default
 en relaciones de dependencia entre clases.
 Si bien son enfoques correctos no son determinantes en la reconstruccion
 total y es necesario refinar y complementar con otras técnicas.
\end_layout

\begin_layout Standard
Además, ninguno de estos enfoques ha considerado las extracciones de 
\emph on
paths
\emph default
 de ejecución para generar diagramas tales como los UCMs, solo KAE genera
 este tipo de diagramas pero con el defecto de hacerlo a partir de un análisis
 estructural cuando la representación es inherentemente comportamental.
 DiscoTech utiliza información dinámica, pero genera vistas estructurales
 de la arquitectura.
 
\end_layout

\begin_layout Standard
Un aspecto debil, ya no de los enfoques sino de las aplicaciónes que los
 implementan, es que muy pocas tienen incorporadas las herramientas de extracció
n de información.
 Otro aspecto a destacar que está fuertemente relacionado con el anterior
 es que demasiadas tareas se hacen de forma manual.
 Ya sea el parseo del código fuente, como la instrumentación de dicho código
 son tareas manuales o bien realizadas por otras aplicaciónes cuyos resultados
 hay que agregarlos manualmente a la herramienta de análisis.
 Sería deseable que solamente la información que debe ser interpretada por
 el ojo experto sea incorporada manualmente.
\end_layout

\begin_layout Standard
Cabe destacar varias características interesantes de los enfoques analizados
 que determinaron algunos de los objetivos y características deseables al
 plantear el desarrollo del enfoque 
\emph on
DRArch
\emph default
.
 El enfoque Botton-Up y Top-Down propuesto en Mitre es interesante desde
 el punto de vista de la flexibilidad del análisis al poder seguir cualquiera
 de las dos estrategias.
 El uso de programación lógica para realizar las inferencias es mucho mas
 atractivo e intuitivo que utilizar, como lo hace Dali, una combinación
 de SQL y Perl para la inferencia y la generación de nuevos hechos.
 El uso de programación lógica se enfoca en "qué" recuperar y no "cómo"
 hacerlo.
 Utilizar convenciones de nombres es una alternativa interesante siempre
 y cuando no sea "la única alternativa" (DiscoText).
 Es decir que el análisis no se base en convenciones sino que aproveche
 sus beneficios ya que es una herramienta poderosa que incorpora en la fase
 de extracción, el conocimiento del arquitecto sobre el código implementado.
 Por último el método propuesto por el SEI, AMR es un mecanismo simple que
 sienta las bases del análisis y permite refinar y aumentar la precisión
 de los elementos recuperados.
\end_layout

\begin_layout Standard
Resumiendo, la gran mayoria de los enfoques apuntan a aspectos estructurales
 y el uso de análisis estático para cumplir con este objetivo.
 Cabe destacar la falta del modelado de aspectos comportamentales y el uso
 de notación arquitectónica para describir la arquitectura recuperada.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Falta una vuelta de rosca al ultimo parrafo.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
X Es decir, alguno considera comportamiento??
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:El-enfoque-DRArch"

\end_inset

Enfoque 
\emph on
DRArch
\end_layout

\begin_layout Standard
En este capítulo se presenta el enfoque 
\emph on
DRArch
\emph default
, que propone la creación de una he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
ta de soporte para la reconstrucción
 de arquitecturas de software, usando para ello información estática (código
 fuente) y dinámica (
\emph on
logs
\emph default
 de ejecución) para lograr una representación arquitectónica por medio de
 diagramas de componentes y de UCMs.
\end_layout

\begin_layout Standard
El objetivo principal de 
\emph on
DRArch
\emph default
 es realizar un análisis de toda la información relevante que se pueda recolecta
r de un sistema, generando como salida una representación arquitectónica.
 Como bien se detalló en el capítulo anterior, existen actualmente varios
 enfoques basados en reconstrucción de arquitecturas para tratar el problema
 que causa la falta de documentación arquitectónica.
 Si bien no se centran específicamente en la reconstrucción de comportamiento,
 el análisis detallado de cada uno nos permitió detectar aspectos que colaboran
 en los mecanismos y abstracciones aplicables al caso de UCMs.
\end_layout

\begin_layout Standard
Otro aspecto importante es que se tenga en cuenta la información que aporten
 aquellas personas que tengan conocimientos sobre el sistema durante el
 proceso de reconstrucción de la arquitectura.
 Por lo general, esta información es la mas difícil de incorporar ya que
 la semántica no es siempre la misma.
 Por ejemplo, un desarrollador sabe que existe una convención en donde todas
 las clases que tengan en su nombre el sufijo 
\emph on
Task
\emph default
, representan tareas del sistema, y se desea que ese conocimiento se incorpore
 en el proceso de reconstrucción.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Este parrafo y el anterior van en el resumen de la seccion anterior...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El resto del capítulo se encuentra organizado de la siguiente forma.
 En la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Análisis"

\end_inset

 se presenta un breve 
\emph on
análisis
\emph default
 del problema y de los trabajos relacionados que dieron origen al conjunto
 de requerimientos para la creación de 
\emph on
DRArch
\emph default
.
 Luego, en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Ejemplo:-Observer-Observable"

\end_inset

 se muestra un ejemplo concreto para poder comprender el funcionamiento
 de 
\emph on
DRArch
\emph default
.
 La sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "des:Modelo-conceptual"

\end_inset

 presenta el 
\emph on
modelo conceptual
\emph default
 de 
\emph on
DRArch
\emph default
, junto con una breve descripción de cada uno de los elementos que interactúan
 para alcanzar la funcionalidad propuesta.
 Finalmente, en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Conclusiones-Cap4"

\end_inset

 se presentan las conclusiones del capítulo.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Análisis"

\end_inset

Enfoque 
\emph on
DRArch
\end_layout

\begin_layout Standard
El enfoque permite recuperar de forma flexible arquitecturas de sistemas
 de software.
 El proceso de reconstrucción consiste en recolectar información de distintas
 fuentes.
 Por ejemplo, código fuente, logs de ejecución, experiencia de los expertos
 del sistema, etc.
 Esta información se consolida en una representación para poder relacionar
 la información de forma sencilla e intuitiva.
 Esta representación se realiza utilizando programación lógica.
 Luego, por medio de un mecanismo de consultas, se analiza la información
 disponible para generar sugerencias al usuario sobre el modelo arquitectónico
 a reconstruir.
 Las sugerencias son afirmaciones que el arquitecto debe aceptar o rechazar.
 Este proceso ser repite con el fin de ir refinando de forma incremental
 el modelo arquitectónico.
 El modelo que se va construyendo se transforma diagramas de componentes
 y de UCMs que representan aspectos estructurales y comportamentales del
 sistema en un alto nivel de abstracción.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Aca hay que entrar con explicar el enfoque que se aborda ...
 
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset LatexCommand label
name "des:Modelo-conceptual"

\end_inset

Modelo\InsetSpace ~
conceptual
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
[Y ...
 mejorar la hipotesis]
\end_layout

\begin_layout Standard
ALGO QUE SE UTILICE COMO HIPOTESIS...
 ALGO COMO la hipotesis de esta tesis esta fundamentada en utilizacion del
 conocimiento de los patrones arquitectonicos de un sistema para la reconstrucci
on de los diferentes componentes de un sistema.
\end_layout

\begin_layout Standard
Remarcar tambien que van a reconstruir un Object-oriented implementation..
 no cualquier implementacion...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La hipótesis de esta tesis esta fundamentada en la utilización del conocimiento
 de los patrones arquitectónicos para la reconstrucción de los diferentes
 componentes de un sistema.
 Para esto, asumimos que los sistemas a reconstruir estén implementados
 con el paradigma de programación orientada a objetos.
\end_layout

\begin_layout Standard
Para lograr la funcionalidad propuesta, 
\emph on
DRArch 
\emph default
sigue un proceso iterativo en el cuál el arquitecto interactúa en pequeñas
 decisiones para ir especificando incrementalmente el mo\SpecialChar \-
de\SpecialChar \-
lo arquitectónico
 del sistema.
 Dicho modelo esta representado por una base de conocimiento lo suficientemente
 flexible como para poder realizar consultas complejas de forma simple.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] ACA DEBERIA IR UNA FIGURA ESQUEMATICA DEL ENFOQUE
\end_layout

\end_inset

 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Proceso-DRArch"

\end_inset

 muestra como funciona el proceso 
\emph on
DRArch
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/procesoDrarch.jpg
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Proceso-DRArch"

\end_inset

Proceso 
\emph on

\begin_inset Note Note
status collapsed

\begin_layout Standard

\emph on
DRArch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las iteraciones están representadas por las fases, las cuales realizan actualiza
ciones al modelo arquitectónico.
 De esta forma, el punto de comienzo de este proceso es la ejecución de
 la fase de recolección de información.
 A partir del código fuente recuperamos la información estática y mediante
 el análisis del sistema en ejecución extraemos la información dinámica
 que complementa el análisis estático.
 Tanto la información estática como la dinámica que fueron recolectadas
 en las primeras fases, es estilizada por el resto de las fases ya que es
 considerada como información base.
 
\end_layout

\begin_layout Standard
Luego de la fase de recolección de información empiezan las fases de especializa
ción, las cuales van iterativa e incrementalmente modificando el modelo
 arquitectónico elevando en cada fase el nivel de abstracción y detalle.
 En estas fases, la herramienta sugiere un conjunto de modificaciones (hechos)
 a la descripción del modelo arquitectónico.
 Estas modificaciones representan cambios a diferentes partes de la representaci
ón actual del sistema que pueden involucrar tanto modificaciones de estructura
 como de escenario de comportamiento.
 A partir de estas sugerencias, el arquitecto decide cual de estas modificacione
s representan fielmente los conceptos arquitectónicos que se está intentando
 reconstruir como así también descartar todas las sugerencias porque no
 aportan información relevante al análisis.
 Adicionalmente, el arquitecto puede refinar la especificación representada
 por los diferentes diagramas aumentando el nivel de detalle, incorporando
 modificaciones o elementos que pueden aportar mayor nivel de detalle en
 sucesivas fases que utilizan el modelo transformado por la fase en curso.
\end_layout

\begin_layout Standard
Una forma de aumentar la especialización del análisis es la definición de
 una fase por aspecto del sistema.
 Así se podrían reutilizar dichas fases para cada aspecto evaluado.
 En cada nuevo escenario se va incrementando el nivel de detalle aportado
 por cada una de estas, descubriendo así relaciones que tal vez en análisis
 anteriores (escenarios diferentes) no fueron descubiertos.
 Al termino de cada fase, se generan representaciones gráficas del modelo
 arquitectónico las cuales cubren dos aspectos fundamentales de la arquitectura
 del sistema: estructura (diagramas de Componentes) y comportamiento (UCMs).
\end_layout

\begin_layout Standard
De esta manera, el proceso de recuperación será una tare
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Dentro del proceso faltan marcar las etapas de analisis estático y dinamico
\end_layout

\end_inset

a donde el enfoque sugerirá un conjunto de transformaciones arquitectónicas
 y el arquitecto del sistema analizará y decidirá cuales de estas transformacion
es es la más adecuada.
\end_layout

\begin_layout Standard
La descripción del proceso define seis partes principales del enfoque: el
 análisis estático, análisis dinámico, un modelo de reglas, la identificación
 de estructuras arquitectónicas, el manejo de las alternativas arquitectónicas
 y la generación de vistas.
 En la figura\InsetSpace ~
 se muestra un diagrama esquemático
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Esta imagen no aporta mucho..
 sobretodo porque no estan especidicadas las diferentes partes del enfoque
 con el proceso de reconstruccion...Una unificacion de ambas figuras mas un
 poco mas de trabajo seria lo ideall...
\end_layout

\end_inset

 de las partes del enfoque.
\end_layout

\begin_layout Standard
Con el objetivo de poder comprender el enfoque pragmáticamente, en la siguiente
 sub-sección se presenta un ejemplo simple de una pieza de un sistema, en
 donde se utiliza el patrón de diseño 
\emph on
Observer-Observable
\emph default
.
 El resto de las 
\emph on
sub
\emph default
-secciones describen cada una de las partes del enfoque que se muestran
 en el diagrama esquemático de la figura\InsetSpace ~
 haciendo referencia o agregando
 mas detalles al ejemplo.
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sec:Ejemplo:-Observer-Observable"

\end_inset

Ejemplo: Observer-Observable
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
En algun lado hablaron que tambien usaban un diagrama de componentes..
 si lo hacen tienen que mencionarlo aca tambien describiendo el ejemplo
 tambien utilizando dicho lenguaje..
\end_layout

\end_inset

Como se mencionó antes, una de las decisiones principales del enfoque 
\emph on
DRArch
\emph default
 ha sido centrarse en la reconstrucción de las vistas comportamentales de
 una arquitectura, en par\SpecialChar \-
ti\SpecialChar \-
cu\SpecialChar \-
lar, especificadas como UCMs.
 Para ayudar a comprender el enfoque que se explica en este capítulo, volvemos
 al ejemplo de la Sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sub:Ejemplo-UCM"

\end_inset

, basado en un patrón 
\emph on
Observer-Observable
\emph default
 
\begin_inset LatexCommand cite
key "gamma93design"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Las diferentes partes del ejemplo tienen que ser explicadas a lo largo de
 la secciones..
 es decir..
 cuando hablan de analisis de codigo...
 introducen la implementacion...
 y el componente estructural..
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y...hace falta mostrar los eventos que tira el Flabto???]
\end_layout

\begin_layout Standard
y luego en la seccion de dinamico presentan los eventos de ejecucion y el
 UCM.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Seria deseable que el ejemplo muestre dos ciclos de recuperacion..
 
\end_layout

\begin_layout Standard
podria mostrarse primero que identifca MVC como estilo arquitectónico principal
 y luego observer-observable como refinamiento de la comunicaciones Modelo-Vista
 Modelo-Controlador
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El patrón 
\emph on
Observer-Observable
\emph default
 se aplica en el contexto de aplicaciones interactivas que demandan un alto
 grado de interacción con el usuario.
 Estos sistemas normalmente requieren un alto grado de flexibilidad, en
 especial sobre la interfaz de usuario, que debe adaptarse a las necesidades,
 muchas veces conflictivas, de los diferentes usuarios.
 En particular, 
\emph on
Observer-Observable
\emph default
 apunta a satisfacer las siguientes necesidades:
\end_layout

\begin_layout Itemize
La misma información debe ser presentada de manera diferente
\end_layout

\begin_layout Itemize
La representación gráfica y el comportamiento de la aplicación debe reflejar
 la ma\SpecialChar \-
ni\SpecialChar \-
pu\SpecialChar \-
la\SpecialChar \-
ción de datos inmediatamente
\end_layout

\begin_layout Itemize
Cambios en la interfaz de usuario deben ser fáciles de introducir, incluso,
 en tiempo de ejecución
\end_layout

\begin_layout Itemize
El núcleo de la aplicación (
\emph on
Observable
\emph default
) debe verse inalterado por el cambio de estilos o interfaces gráficas
\end_layout

\begin_layout Standard
En el estilo 
\emph on
Observer-Observable
\emph default
 puro, normalmente el 
\emph on
Observable
\emph default
 representa los datos a ser mostrados, y el 
\emph on
Observer
\emph default
 (la vista) es responsable de reflejarlos visualmente al usuario.
\end_layout

\begin_layout Standard
Como primer paso, el arquitecto debe definir qué reglas se van a incluir
 en la fase que se quiere ejecutar.
 Cada fase debería tener un objetivo claro, por ejemplo, una fase podría
 enfocarse en descubrir si existen implementaciones del patrón 
\emph on
Observer-Observable
\emph default
 o de algún otro patrón de diseño.
\end_layout

\begin_layout Subsection
Análisis de información de artefactos de código fuente
\end_layout

\begin_layout Standard
Se debe realizar un análisis de los artefactos relacionados con el código
 fuente para poder capturar los aspectos estructurales del sistema.
 Dicho análisis requiere que el código fuente sea fácilmente navegable para
 poder ir recolectando información relevante.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Justificacion de la eleccion de Prolog..
 
\end_layout

\end_inset

Con el objetivo de poder manipular la información estática de forma flexible,
 el código fuente es representado por medio de un lenguaje de programación
 lógico al estilo 
\emph on
ProLog
\emph default
.
 El lenguaje de programación 
\emph on
ProLog
\emph default
 está basado en la lógica de predicados, un paradigma diferente a los lenguajes
 de más amplio uso en la actualidad, principalmente basados en la programación
 estructurada y la programación orientada a objetos.
 
\emph on
ProLog
\emph default
 brinda posibilidades más potentes y eficientes en la representación y automatiz
ación de técnicas basadas en el conocimiento.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Ejemplo con la traduccion...y la forma de analisis..
\end_layout

\end_inset

De esta forma, se representan artefactos del código fuente (clases, variables,
 paquetes, etc.) sobre una base de conocimiento.
 Por ejemplo, una la clase 
\family typewriter
UserModel
\family default
 que contiene un método 
\family typewriter
setName
\family default
 se representa con con los siguientes hechos: 
\end_layout

\begin_layout Itemize

\family typewriter
class(UserModel)
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
method(setName).
\end_layout

\begin_layout Itemize

\family typewriter
hasMethod(UserModel, setName).
\end_layout

\begin_layout Standard
Esto nos permite mantener un contexto en el cual sea posible encontrar informaci
ón relacionada de forma sencilla ya que buscando directamente en el código
 fuente resultaría casi imposible.
\end_layout

\begin_layout Standard
Esta transformación es realizada al comienzo del proceso de reconstrucción
 por medio de un parser que recorre el AST de cada archivo fuente.
 Una vez que el código fuente esta representado en forma de hechos, es posible
 realizar consultas para obtener información de forma simple y flexible.
 La flexibilidad de este enfoque permite explorar un gran abanico de relaciones
 y consultas diferentes.
\end_layout

\begin_layout Standard
Por ejemplo, si se considera un escenario en donde un desarrollador quiere
 reutilizar una parte en particular del código de una aplicación porque
 contiene funcionalidad que necesita en otra aplicación que esta desarrollando,
 dicho desarrollador debería realizar una búsqueda por todo el código fuente
 para poder capturar las partes del código que necesita.
 Inspeccionar directamente en el código fuente sería muy tedioso y llevaría
 mucho tiempo, pero si el código fuente esta representado en forma de hechos
 
\emph on
ProLog
\emph default
, seria sencillo realizar algunas consultas para identificar partes del
 código.
\end_layout

\begin_layout Standard
Siguiendo con el ejemplo mostrado anteriormente, en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-clases-UML-para-el-ejemplo-Observer-Observable"

\end_inset

 se presenta un diagrama de clases UML en donde una aplicación sencilla
 utiliza el patrón 
\emph on
Observer-Observable
\emph default
 y en Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-componentes"

\end_inset

 se presenta un diagrama con los dos componentes principales de este patrón
 arquitectónico, detallando en cada uno de ellos las responsabilidades asociadas
:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/observerObservableClassDiagram.JPG
	scale 80

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-clases-UML-para-el-ejemplo-Observer-Observable"

\end_inset

Diagrama de clases UML para el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableComponentDiagram.png
	width 90text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-componentes"

\end_inset

Diagrama de componentes para el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description

\emph on
Observable
\emph default
 Representa los datos y la funcionalidad principal de la aplicación.
 Provee un mecanismo para registrar los observadores.
 De este modo, permite la notificación de los cambios sufridos manteniendo
 la independencia del modelo con sus diferentes vistas.
\end_layout

\begin_layout Description

\emph on
Observer
\emph default
 Provee información al usuario de manera visual y obtiene información del
 usuario mediante eventos (por ejemplo, 
\emph on
clicks
\emph default
 o movimientos de 
\emph on
mouse
\emph default
, teclas, etc.).
 Obtiene sus datos del modelo.
\end_layout

\begin_layout Standard
Las relaciones entre el componente 
\family typewriter
UserModelObservable
\family default
 y los componentes 
\family typewriter
User\SpecialChar \-
Interface\SpecialChar \-
Observer
\family default
 y 
\family typewriter
User\SpecialChar \-
Logger\SpecialChar \-
Observer
\family default
 denotan que existe un mecanismo de notificación entre estos componentes.
\end_layout

\begin_layout Standard
Antes de proseguir con el ejemplo 
\emph on
Observer-Observable
\emph default
 es importante introducir el concepto de mapeo entre la documentación arquitectó
nica y su correspondiente implementación.
\end_layout

\begin_layout Standard
Como se explicó en la sección 
\begin_inset LatexCommand ref
reference "sub:Ejemplo-UCM"

\end_inset

, el comportamiento especificado a nivel arquitectónico toma distancia de
 los detalles de interacción como las llamadas o mensajes entre componentes.
 En el lenguaje UCM, el comportamiento se representa en términos secuencias
 causa-efecto entre 
\emph on
responsabilidades
\emph default
 de los componentes.
 Las 
\emph on
responsabilidades
\emph default
 pueden ser de mayor gra\SpecialChar \-
nu\SpecialChar \-
la\SpecialChar \-
ri\SpecialChar \-
dad que las llamadas y mensajes para reducir
 el nivel de compromiso con los detalles, por este motivo, una 
\emph on
responsabilidad
\emph default
 (función de la que es responsable un componente) puede ser materializada
 por varios métodos e incluso clases de objeto a nivel implementación.
 Por otro lado, una misma clase o un método particular de ésta puede contribuir
 con la materialización de diferentes 
\emph on
responsabilidades
\emph default
.
\end_layout

\begin_layout Standard
En otras palabras, existe una correspondencia de aridad 
\family typewriter
n:m
\family default
 entre una unidad de comportamiento a nivel arquitectónico, como lo es una
 
\emph on
responsabilidad
\emph default
 UCM, y una unidad de comportamiento a nivel implementación, como lo son
 los métodos de una clase.
 Tal relación se denomina mapeo 
\emph on
responsabilidad
\emph default
 - 
\emph on
código
\emph default
.
 El mapeo permite la trazabilidad entre la 
\emph on
res\SpecialChar \-
pon\SpecialChar \-
sa\SpecialChar \-
bi\SpecialChar \-
li\SpecialChar \-
dad
\emph default
 UCM de un componente y su implementación.
\end_layout

\begin_layout Standard
En la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Mapeos-clase-componente"

\end_inset

 y la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Mapeos-método-responsabilidad"

\end_inset

 se muestra la correspondencia de la documentación arquitectónica del caso
 de referencia y su implementación en Java mediante tales mapeos.
 Si bien en este ejemplo las correspondencias clase-componente y método-responsa
bilidad son directas, es posible especificar casos más complejos.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableMappingClass.jpg
	lyxscale 50
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Mapeos-clase-componente"

\end_inset

Mapeos clase - componente
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableMappingMethod.jpg
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Mapeos-método-responsabilidad"

\end_inset

Mapeos método - responsabilidad
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Algunos hechos 
\emph on
Prolog
\emph default
 de la tabla\InsetSpace ~
 muestran cómo es representada la información mostrada en el
 ejemplo (clases, interfaces, propiedades, mapeos, etc.).
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Puede ir una tabla con las diferentes reglas...
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="1">
<features>
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Hechos Prolog 
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
class(UserModel).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
class(UserInterface).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
class(UserLog).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
interface(Observable).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
method(update).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
child(UserModel, update).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
package(drarch.observer).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
package(drarch.observable).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
modifier(UserModel, public).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
returns(update, void).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
field(name).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
child(UserModel, name).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
child(drarch.observer, UserModel).
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
implements(Observable, UserInterface).
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Hechos-Prolog-pare"

\end_inset

Hechos 
\emph on
Prolog
\emph default
 pare el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Análisis dinámico
\end_layout

\begin_layout Standard
Al igual que la información estática, la información dinámica es representada
 en forma de hechos al estilo 
\emph on
ProLog
\emph default
 y sobre la misma base del conocimiento.
 Para obtener dicha información, primero se debe instrumentar la aplicación
 para poder generar logs de ejecución.
 Luego, es necesario realizar un análisis de los 
\emph on
logs
\emph default
 de ejecución del sistema.
 Los 
\emph on
logs
\emph default
 de ejecución representan las trazas reales de ejecución de la aplicación
 en su estado actual.
 Contienen información de bajo nivel, como llamadas a métodos, threads,
 creaciones de objetos, etc.
\end_layout

\begin_layout Standard
En el ejemplo 
\emph on
Observer-Observable
\emph default
 sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Ejemplo:-Observer-Observable"

\end_inset

, el flujo de eventos que genera la ejecución de la aplicación queda reflejado
 en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Ejemplo-Observer-Observable-UCM"

\end_inset

 .
 Este caso se produce cuando algún dato del modelo es modificado.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableSample.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-Observer-Observable-UCM"

\end_inset

Ejemplo 
\emph on
Observer-Observable
\emph default
 de UCM
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para generar de los 
\emph on
logs
\emph default
 de ejecución, es necesario instrumentar la aplicación y realizar ejecuciones
 sobre casos de uso que reflejen el comportamiento del sistema.
 En este punto es imprescindible la intervención manual del arquitecto ya
 que es necesario guiar la ejecución de la aplicación, interactuando con
 ella de manera que se ejercite los casos de uso en donde los artefactos
 que se quieren reconstruir tengan participación dentro de la ejecución.
\end_layout

\begin_layout Standard
Los hechos generados por el análisis dinámico, se almacenan en la base de
 conocimientos junto con el resto de la información para que las consultas
 que se realicen puedan relacionar tanto información estática como dinámica.
 Adicionalmente, es posible relacionar información del modelo que incrementalmen
te se está generando y la información aportada por experiencia y el conocimiento
 de las personas involucradas en el proceso de reconstrucción.
\end_layout

\begin_layout Standard
En el ejemplo de la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Ejemplo:-Observer-Observable"

\end_inset

, el análisis del log tiene como salida todas las llamadas a métodos formando
 
\emph on
paths
\emph default
 de ejecución.
 La ejecución del método 
\family typewriter
notifyAllObservers
\family default
 queda representado de la siguiente forma:  
\family typewriter
executedMethod(1, UserModel.notifyAllObservers, void, null).
\family default
En donde el primer argumento es el orden de ejecución, el segundo, el método
 ejecutado, el tercero el tipo de retorno y el cuarto, el valor de retorno.
\end_layout

\begin_layout Subsection
Reglas para la identificación de artefactos arquitectónicos
\end_layout

\begin_layout Standard
Las iteraciones están representadas por las fases las cuales realizan actualizac
iones al modelo arquitectónico.
 Cada fase recibe como entrada un 
\emph on
snapshot
\emph default
 del modelo recuperado por fases anteriores y produce como salida una evolución
 del modelo de entrada en base a las transformaciones aplicadas durante
 la ejecución de la fase.
 De esta forma una fase se convierte en un componente customizable y reutilizabl
e el cual es independiente del modelo arquitectónico de entrada.
\end_layout

\begin_layout Standard
La ejecución de cada fase es a su vez, es un proceso interactivo.
 Cada fase contiene un conjunto de reglas las cuales determinan las transformaci
ones al modelo.
 Estas transformaciones permitirán al arquitecto relacionar elementos arquitectó
nicos (ej.: componentes, relaciones entre componentes, etc.) a diferentes
 estructuras de código (ej.: clases, métodos, etc).
 Cada regla consta de tres partes: 
\end_layout

\begin_layout Enumerate
una consulta sobre la base de conocimiento; 
\end_layout

\begin_layout Enumerate
una sugerencia, construida a partir de cada uno de los resultados de la
 consulta;
\end_layout

\begin_layout Enumerate
una serie de hechos (
\emph on
facts
\emph default
), los cuales representan las transformaciones a la base de conocimiento.
\end_layout

\begin_layout Subsubsection
Especificando reglas
\end_layout

\begin_layout Standard
El enfoque provee un conjunto de reglas basadas en patrones de diseño y
 en un análisis realizado sobre diversos sistemas.
 De esta forma, se intentó detectar cuales son los re\SpecialChar \-
que\SpecialChar \-
ri\SpecialChar \-
mien\SpecialChar \-
tos que debe
 cumplir un sistema para que se justifique la presencia de un determinado
 artefacto arquitectónico.
 Por ejemplo, una regla puede detectar la presencia de un componente del
 tipo 
\emph on
Observer
\emph default
 y su justificación sería que existe una clase que implementa la interface
 
\emph on
Observer
\emph default
.
\end_layout

\begin_layout Standard
Adicionalmente, las reglas pueden ser especificadas por el arquitecto que
 realiza el proceso de reconstrucción.
 Las reglas incorporadas por el arquitecto pueden ser utilizadas en cualquiera
 de las fase del proceso de reconstrucción.
\end_layout

\begin_layout Subsection
Identificación de estructuras arquitectónicas
\end_layout

\begin_layout Standard
En el ejemplo 
\emph on
Observer-Observable
\emph default
, las reglas que identifican estructuras arquitectónicas son simples.
 Por ejemplo, una clase que implementa la interface 
\emph on
Observer
\emph default
 se mapea a un componente arquitectónico.
 Si bien esto se define como una regla, durante el proceso de reconstrucción
 esta regla se presenta como sugerencia y es responsabilidad del arquitecto
 aceptar o refutar la generación un nuevo componente.
 
\end_layout

\begin_layout Standard
El conjunto de reglas que se seleccionaron para reconstruir el sistema de
 ejemplo 
\emph on
Observer-Observable
\emph default
 no fue casual.
 Previamente se ejecutó una fase con un conjunto de reglas capaces de detectar
 estilos arquitectónicos.
 Esto permitió detectar el estilo MVC (
\emph on
Model View Controler
\emph default
) y así poder seleccionar conjuntos de reglas relacionadas con ese estilo.
\end_layout

\begin_layout Standard
En el estilo MVC puro, normalmente el modelo representa los datos a ser
 mostrados, la vista es responsable de reflejarlos visualmente al usuario
 y el controlador es responsable de administrar las entradas del usuario,
 realizando cambios en el modelo cuando corresponda y refrescando a la vista.
 En muchas implementaciones, las interfaces de los modelos son diseñados
 específicamente para la vista.
 Cuando la vista se dibuja, se comunica fuertemente con el modelo.
 Es por esta razón que se seleccionan reglas relacionadas con el patrón
 
\emph on
Observer-Observable
\emph default
 cuando el estilo arquitectónico MVC es detectado.
\end_layout

\begin_layout Standard
A su vez, es posible construir reglas mas complejas que ayuden a identificar
 estructuras arquitectónicas relacionando distintos tipos de información.
 Para ello es necesario conocer cuales son los aspectos a tener en cuenta
 a la hora de reconocer dichas estructuras.
 Durante el proceso de diseño se toman decisiones importantes que persistirán
 a lo largo de todo el ciclo de vida del sistema.
 Decisiones como por ejemplo de que manera agrupar los componentes en paquetes,
 que patrones de diseño utilizar para realizar un modulo específico o más
 simples como por ejemplo que visibilidad darle a determinadas clases dentro
 de un paquete.
 Todos estos elementos o practicas son comunes a todos los sistemas y las
 mismas pueden ser aprovechadas para realizar ingeniería reversa sobre un
 sistema.
 Las siguientes secciones describirán algunos de los enfoques considerados
 en 
\emph on
DRArch
\emph default
 a la hora de definir reglas que asistan en la detección de estructuras
 arquitectónicas:
\end_layout

\begin_layout Subsubsection
Estructura De Paquetes 
\end_layout

\begin_layout Standard
Cualquier sistema grande se debe dividir en unidades más pequeñas, de modo
 que las personas puedan trabajar con una cantidad de información limitada,
 a la vez y de modo que los equipos de trabajo no interfieran con el trabajo
 de los otros.
 Un paquete es una parte de un modelo.
 Cada parte del modelo debe pertenecer a un paquete.
 Pero para ser funcional, la asignación debe seguir un cierto principio
 racional, tal como funcionalidad común, implementación relacionada y punto
 de vista común.
 UML no impone una regla para componer los paquetes.
 Los paquetes ofrecen un mecanismo general para la organización de los modelos/s
ubsistemas agrupando elementos de modelado.
 Cada paquete corresponde a un sub\SpecialChar \-
mo\SpecialChar \-
de\SpecialChar \-
lo (subsistema) del modelo (sistema).
 Los paquetes son unidades de organización jerárquica de uso general de
 los modelos de UML.
 Pueden ser utilizados para el almacenamiento, el control de acceso, la
 gestión de la configuración y la construcción de bibliotecas que contengan
 fragmentos reutilizables del modelo.
 Un paquete puede contener otros paquetes, sin límite de anidamiento pero
 cada elemento pertenece a (está definido en) sólo un paquete.
 Los paquetes contienen elementos del modelo al más alto nivel tales como
 clases y sus relaciones, máquinas de estado, diagramas de casos de uso,
 interacciones y colaboraciones; atributos, operaciones, estados, líneas
 de vida y mensajes están contenidos en otros elementos y no aparecen como
 contenido directo de los paquetes.
 Una clase de un paquete puede aparecer en otro paquete por la importación
 a través de una relación de dependencia entre paquetes.
 Todas las clases no son necesariamente visibles desde el exterior del paquete,
 es decir, un paquete encapsula a la vez que agrupa.
 En general, un paquete no puede tener acceso al contenido de otro paquete.
 Los paquetes son opacos, a menos que sean abiertos por una dependencia
 de acceso o de importación.
 La dependencia de acceso indica que el contenido del paquete del proveedor
 puede aparecer en referencias efectuadas por los elementos del paquete
 cliente.
 En general, un paquete puede ver solamente los elementos de otros paquetes
 que tienen visibilidad pública.
 Los elementos con visibilidad protegida pueden ser vistos únicamente por
 los paquetes que son descendientes del paquete contenedor de dichos elementos.
 Los elementos con visibilidad privada sólo son vistos por su paquete contenedor
 y anidados.
 La visibilidad también se aplica a las clases.
 El permiso de acceso y visibilidad son necesarios para hacer referencia
 a un elemento.
 La dependencia de acceso no modifica el espacio de nombres del cliente
 no crea las referencias automáticamente, simplemente concede permiso para
 establecer referencias.
 La dependencia de importación se utiliza para agregar nombres al espacio
 de nombres del paquete del cliente como sinónimos de los caminos completos.
\end_layout

\begin_layout Subsubsection
Reconocimiento de componentes de utilidad 
\end_layout

\begin_layout Standard
\align block
Cuando se busca reconocer componentes basado en eventos arquitectónicos
 de bajo nivel, es interesante también filtrar o excluir del análisis aquellos
 que no aportan valor agregado al análisis.
 En la literatura, estos elementos son conocidos como componentes de utilidad.
 Dichos componentes determinan detalles de implementación de bajo nivel.
 Hamou et.
 al.
 
\begin_inset LatexCommand cite
key "Abdelwahab"

\end_inset

 definen un componente de utilidad como cualquier elemento de un programa
 diseñado por conveniencia del diseñador o el programador con la intensión
 de ser accedido desde múltiples lugares dentro de cierto ámbito (
\emph on
scope
\emph default
) dentro del programa.
 Con el propósito de detectar componentes de utilidad, los autores desarrollaron
 un algoritmo basado en un análisis
\emph on
 fan-in
\emph default
.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
\align block
[Y] Este algoritmo...explora el grafo de dependencias...
 
\end_layout

\end_inset

 Este algoritmo explora del grafo de dependencias de clases construido en
 base al análisis estático del sistema y se encarga de individualizar aquellas
 clases que tienen un gran número de arcos entrantes (muchas clases dependientes
).
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
\align block
[Y] y se encarga de individualizar aquellas clases que tienen un gran número
 de arcos entrantes (muchas clases dependientes) puede ir despues..
\end_layout

\end_inset

El grafo de dependencias de clases es un grafo dirigido donde los nodos
 son las clases del sistema y los arcos representan las relaciones entre
 las clases.
 Por ejemplo, si agregamos una nueva clase llamada 
\family typewriter
Helper
\family default
 al ejemplo 
\emph on
Observer-Observable
\emph default
 y suponemos que la mayoría de estas clases utiliza por algún motivo la
 nueva, un posible componente de utilidad seria estaría representado por
 la clase 
\family typewriter
Helper
\family default
.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Grafo-de-dependencias Utilidad"

\end_inset

 muestra un grafo dependencias en donde se puede observar esta situación.
\end_layout

\begin_layout Standard
\align block
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/GrafoObserverObservable.png
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Grafo-de-dependencias Utilidad"

\end_inset

Grafo de dependencias que muestra un componente utilidad y clase de entrada
 al módulo.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] [nico] explicar la imagen desde el ejemplo
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Para determinar si una clase es considerada una utilidad, se propone la
 siguiente medición:
\end_layout

\begin_layout Standard
Dada una clase 
\family typewriter
C
\family default
 y los siguientes conjuntos:
\end_layout

\begin_layout Itemize

\family typewriter
S
\family default
: Conjunto de clases consideradas en el análisis.
\end_layout

\begin_layout Itemize

\family typewriter
IN
\family default
: Un subconjunto de S que consiste en las clases que dependen de C (
\emph on
fan-in
\emph default
).
\end_layout

\begin_layout Standard
Se define la medición de utilidad 
\family typewriter
U
\family default
 de la clase 
\family typewriter
C
\family default
 como:
\end_layout

\begin_layout Standard
\align center

\family typewriter
U = |IN| / (|S|-1)
\end_layout

\begin_layout Standard
El conjunto 
\family typewriter
S
\family default
 es usado para representar el 
\emph on
scope
\emph default
 considerado en el análisis de 
\family typewriter
U
\family default
.
 Por ejemplo, si se están buscando utilidades a nivel de sistema, 
\family typewriter
S
\family default
 contendrá todas las clases del sistema.
 Por el contrario, si la búsqueda está restringida a un paquete en particular,
 entonces 
\family typewriter
S
\family default
 contendrá solo las clases de dicho paquete.
\end_layout

\begin_layout Standard
Los valores de 
\family typewriter
U
\family default
 varían de 0 a 1 en donde 0 indica que la clase no tiene arcos de entrada.
 Este dato es de mucha utilidad, por ejemplo cuando se esta evaluando un
 módulo específico, esta clase determina el punto de acceso a dicho módulo.
 Si en cambio evaluamos el sistema entero, dicha clase es el punto de entrada
 al sistema o es una clase que nunca se invoca.
 Notar que las dependencias de dicha clase sobre sí misma no están consideradas
 lo que explica el valor 
\family typewriter
|S| -1
\family default
.
\end_layout

\begin_layout Standard
Dada esta medición y el grafo de dependencias, el algoritmo de detección
 de componentes de utilidad es sencillo.
 La descripción de éste, se muestra en el Algoritmo\InsetSpace ~

\begin_inset LatexCommand ref
reference "alg:Algoritmo-de-utilidad"

\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Mejorar la descripcion del algoritmo y 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard

\series bold
utility
\series default
(S)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
for
\series default
 class 
\series bold
in
\series default
 S
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
u = calculateUtility(class, S)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
if
\series default
 u > UMBRAL
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
solution.add(class)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end if
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard

\series bold
\InsetSpace ~
\InsetSpace ~
return 
\series default
solution
\end_layout

\begin_layout Standard

\series bold
end run-phase
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Algoritmo-de-utilidad"

\end_inset

Algoritmo de detección de componentes de utilidad.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
mostrar mediante un ejemplo..
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Crear un conjunto resultado (vacio).
\end_layout

\begin_layout Enumerate
Para cada clase C del conjunto S, calcular U.
\end_layout

\begin_layout Enumerate
Identificar las class que tienen un valor U mayor o igual a un valor umbral
\begin_inset LatexCommand cite
key "Abdelwahab"

\end_inset

 y agregarla al conjunto solución.
\end_layout

\begin_layout Enumerate
Las clases contenidas en el conjunto solución son cadidatas a ser clases
 de utilidad.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Identificación de componentes basado en acoplamiento
\end_layout

\begin_layout Standard
Utilizando un enfoque similar al descripto anteriormente es posible llevar
 un medida de acoplamiento entre clases.
 Se define acoplamiento como el grado en que un componente esta conectado
 a otros componentes del sistema, es decir, su 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] su 
\end_layout

\end_inset

grado de dependencia que tiene.
 Todo buen diseño de componentes está o debería estar pensado de tal forma
 que sus componentes sean cohesivos y con bajo acoplamiento con los demás
 componentes.
 De esta forma es posible detectar componentes agrupando en 
\emph on
clusters
\emph default
 aquellas clases que tengan una fuerte interacción con sus clases vecinas.
 Por ejemplo, si el caso del 
\emph on
Observer-Observable
\emph default
 se describe mediante un grafo de dependencias como muestra la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Grafo-de-dependencias-acoplamiento"

\end_inset

, se pueden distinguir estas propiedades.
 Es decir, el acoplamiento del conjunto de clases que relacionadas con el
 modelo (conjunto 
\family typewriter
A
\family default
 de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Grafo-de-dependencias-acoplamiento"

\end_inset

) podrían conformar un componente mientras que el conjunto de clases relacionada
s con la presentación (conjunto 
\family typewriter
B
\family default
 de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Grafo-de-dependencias-acoplamiento"

\end_inset

) podrían conformar otro componente distinto.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] explicar un poco mas la imagen
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/GrafoAcoplamientoObserverObservable.png
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Grafo-de-dependencias-acoplamiento"

\end_inset

Grafo de dependencias en el que se observan el grado de acoplamiento entre
 los componentes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Varios son los tipos de dependencia entre clases que determinan el grado
 de acoplamiento entre componentes.
 Por ejemplo:
\end_layout

\begin_layout Itemize
Referencia entre componentes: el componente A invoca al componente B.
\end_layout

\begin_layout Itemize
Cantidad de datos intercambiados entre componentes: El componente A pasa
 como parámetro a otro B un vector, una matriz, una variable, etc.
\end_layout

\begin_layout Itemize
Decisiones de control que un componente realiza sobre otro: El componente
 A pasa un valor de control al componente B.
 El valor de la variable determina el comportamiento del componente B.
\end_layout

\begin_layout Itemize
El grado de la complejidad de la interfaz de los componentes.
\end_layout

\begin_layout Standard
Como base fundamental para medir el acoplamiento dentro de un módulo se
 tomaron no solamente las medidas de 
\emph on
fan-in
\emph default
 sino también las de 
\emph on
fan-out
\emph default
 (valores altos determinan una alta dependencia con el ext
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] t
\end_layout

\end_inset

erior) conseguidas a través de la evaluación del grafo de dependencias.
\end_layout

\begin_layout Standard
El algoritmo propuesto selecciona un conjunto de clases a analizar 
\family typewriter
S
\family default
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] que es S?? aca tambien gráfico que describa el procedimiento en base
 a un ejemplo 
\end_layout

\end_inset

como espacio de solución, el cual contiene todas las clases bajo análisis.
 Comienza el procesamiento eligiendo una clase de dicho espacio, posiblemente
 la que mayor 
\emph on
fan-out
\emph default
 tenga y se la agrega a un espacio de solución (
\emph on
cluster
\emph default
) 
\family typewriter
C1
\family default
.
 Se agregan luego las clases vecinas a esta a una lista de elementos a evaluar
 dentro del espacio 
\family typewriter
C1
\family default
.
 Se recorre dicha lista y se van agregando dichas estas clases al 
\emph on
cluster
\emph default
 siempre que su incorporación no lleve el grado de acoplamiento del todo
 el 
\emph on
cluster
\emph default
 por debajo de un valor umbral .
 Si se acepta dicha clase, las clases vecinas son incorporadas a la lista
 de elementos candidatos y se continua el análisis hasta que no haya elementos
 en esta lista.
 En este momento se coloca a 
\family typewriter
C1
\family default
 como componente candidato y se continua el análisis para todas aquellas
 clases del espacio S original.
\end_layout

\begin_layout Standard
Al termino de la ejecución del algoritmo se dispone de un conjunto de 
\emph on
clusters
\emph default
 
\family typewriter
Ci
\family default
, los cuales representan componentes cuyo valores de acoplamiento están
 por encima del valor umbral seleccionado.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard

\series bold
component-recognizer
\series default
(S: conjunto de clases a analizar)
\end_layout

\begin_layout Standard

\series bold
List
\series default
 solution_clusters = new 
\series bold
List()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
fore 
\series default
class c 
\series bold
in
\series default
 S
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
Cluster
\series default
 Ci = new 
\series bold
Cluster()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
Ci.add(c)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
remove c from S
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
List
\series default
 neightboards = new 
\series bold
List
\series default
()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
neightboards.add(c.neightboards())
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
for 
\series default
n 
\series bold
in
\series default
 neightboards 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
if
\series default
 ( agregar n a Ci no baja el acoplamiento) 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
Ci.add(n)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
remove n from S
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
neightboards.add(n.neightboards())
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end if
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
solution_clusters.add(Ci)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard

\series bold
end component-recognizer
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Algoritmo para la detección de componentes basado en el grado de acoplamiento.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
Hot Spot
\emph default
 y 
\emph on
Frameworks
\end_layout

\begin_layout Standard
El concepto principal del diseño de 
\emph on
frameworks 
\emph default
se basa en separar aquellos aspectos que son invariantes en un dominio de
 aplicación de aquellos 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] se basa en separar aquellos aspectos que son invariantes ...en un dominio
 de aplicación de aquellos que...
\end_layout

\end_inset

 otros que varían a lo largo de las aplicaciones y que deben mantenerse
 flexibles y customizables (
\emph on
hot spots
\emph default
).
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Ambos tipos de spots son soportados mediante los conceptos herencia y ..
 en lenguajes orientados a objetos..
 A partir de estos conceptos....los frameworks defininen metodos templates y
 hooks....
 FIJARSE DE CONECTAR MEJOR LOS PARRAFOS..
 
\end_layout

\end_inset

Los conceptos de herencia y 
\emph on
binding
\emph default
 dinámico son las claves para llevar a cabo esto en lenguajes orientados
 a objetos.
 A partir de estos conceptos los 
\emph on
frameworks
\emph default
 proveen su flexibilidad definiendo métodos 
\emph on
templates
\emph default
 y 
\emph on
hooks
\emph default
.
 Los métodos 
\emph on
template
\emph default
 son implementados basados sobre los métodos 
\emph on
hook
\emph default
.
 Un método 
\emph on
hook
\emph default
 en un método elemental en el contexto en el que el 
\emph on
hook
\emph default
 particular es usado (este puede ser tanto un método abstracto, un método
 regular u otro método 
\emph on
template
\emph default
).
 
\end_layout

\begin_layout Standard
Generalmente, los métodos 
\emph on
template
\emph default
 son usados para implementar los 
\emph on
frozen spots
\emph default
 en un 
\emph on
framework
\emph default
, y los métodos 
\emph on
hook
\emph default
 los 
\emph on
hot spots
\emph default
.
 Los 
\emph on
frozen spots
\emph default
 son aspectos que son invariantes a lo largo de las aplicaciones en el dominio,
 posiblemente representando comportamiento abstracto, flujos de control
 genéricos y relaciones comunes entre objetos.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/HookTemplateObserverObservable.png
	width 40theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Hooks-y-Templates"

\end_inset


\emph on
Hooks
\emph default
 y
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Adaptar la figura al ejemplo conductor..
\end_layout

\end_inset

 
\emph on
Templates 
\emph default
en el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para poder comprender este concepto, se modificó la clase 
\family typewriter
UserLogger
\family default
 del ejemplo 
\emph on
Observer-Observable
\emph default
 de la siguiente forma.
 Se declaró un nuevo método abstracto llamado 
\family typewriter
writeLog(String message)
\family default
 el cual es invocado por el método 
\family typewriter
update
\family default
.
 Así el método 
\family typewriter
update
\family default
 se convierte en un método 
\emph on
template
\emph default
 mientras que el método 
\family typewriter
writeLog
\family default
 es un método 
\emph on
hook
\emph default
 (ver figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Hooks-y-Templates"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
agregar el diagrama de clases que muestre este concepto
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En base a esto, decidimos utilizar esta estrategia para identificar componentes
 arquitectónicos.
 En primer lugar identificamos los métodos 
\emph on
hook
\emph default
, y a partir de esto se abren dos posibilidades.
 
\end_layout

\begin_layout Itemize
La primera, si la clase 
\emph on
hook
\emph default
 posee el método 
\emph on
template
\emph default
, de esta forma se busca quién invoca al método 
\emph on
template
\emph default
.
 Y se procede a lo mismo que la anterior: se seleccionan como posibles component
es y se recupera la relación (Sección A de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Hot-Spot-y-Frameworks"

\end_inset

).
 Haciendo referencia al ejemplo 
\emph on
Observer-Observable
\emph default
, la clase 
\emph on
hook
\emph default
 
\family typewriter
UserLogger
\family default
 posee el método 
\emph on
template
\emph default
 
\family typewriter
update
\family default
 y éste último es invocado por la clase 
\family typewriter
Observable
\family default
.
\end_layout

\begin_layout Itemize
La segunda, si el método 
\emph on
hook
\emph default
 es invocado desde otra jerarquía, es decir, la clase que invoca el método
 
\emph on
hook
\emph default
 no es subclase de la clase que declara el método template que lo invoca.
 Se seleccionan dichas clases como posibles componentes, y se recupera también
 la relación, en la que la clase 
\emph on
hook
\emph default
 provee un servicio y la clase 
\emph on
template
\emph default
 lo consume (Sección B de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Hot-Spot-y-Frameworks"

\end_inset

).
 Para describir esta situación desde el ejemplo 
\emph on
Observer-Observable
\emph default
, se incorporó una nueva clase llamada 
\family typewriter
LogEvent
\family default
.
 Esta clase posee una propiedad privada del tipo 
\family typewriter
UserLogger
\family default
 y un método trace que invoca al método 
\emph on
hook
\emph default
 
\family typewriter
writeLog
\family default
 perteneciente al 
\family typewriter
UserLogger
\family default
.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y ...agregar el diagrama de clases para que se entienda un poco mas] 
\end_layout

\begin_layout Standard
Ejemplo conductor..
 para explicar..
\end_layout

\begin_layout Standard
Cada parte debe ir construyendo una porcion de la arquitectura final..
 hasta terminar la explicacion del enfoque
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/HotspotObserverObservable.png
	width 50theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard

\emph on
\begin_inset LatexCommand label
name "fig:Hot-Spot-y-Frameworks"

\end_inset

Hot Spot
\emph default
 y 
\emph on
Frameworks.
 
\emph default
Ejemplo
\emph on
 Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Manipulación de alternativas arquitectónicas
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
queda descolgada de la linea general..
 hay saltos..
 referir al proceso gereral..
 algo como ..
 una vez realizado ....
 DrArch utiliza un conjunto de reglas...
 para proponer alternativas .
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una vez realizada la recolección de información, 
\emph on
DRArch
\emph default
 utiliza un conjunto de reglas para proponer alternativas arquitectónicas.
 La forma en la que las alternativas se presentan es por medio la ejecución
 de reglas, ya que tienen como resultado una lista de sugerencias.
 Estas sugerencias proponen cambios al modelo arquitectónico y deben ser
 aceptadas o rechazadas por el arquitecto.
 Esto permite que las actualizaciones arquitectónicas sean controladas.
 
\end_layout

\begin_layout Standard
Una sugerencia es el resultado de evaluar una de las reglas disponibles
 sobre la base del conocimiento.
 La importancia de estas decisiones de diseño varía para cada sistema de
 software y está dada en función de los interesados en el sistema, sus preocupac
iones, y sus necesidades específicas.
 Por ejemplo, es posible que una sugerencia proponga la creación de uno
 de los componentes mas importantes del sistema, pero el arquitecto no desea
 mostrar ese componente en la vista que esta trabajando, ya que no esta
 interesado en ese aspecto del sistema.
 En ese caso, el arquitecto decide rechazar la sugerencia y continuar analizando
 el resto de las sugerencias.
\end_layout

\begin_layout Standard
De esta forma, aceptar o rechazar una sugerencia se convierte en una decisión
 de la arquitectura.
 Las decisiones de la arquitectura se concentran en lo que es esencial en
 un sistema.
 Estas elecciones pueden incluir estructura, organización, funcionalidad,
 comportamiento, o más propiedades no funcionales como la usabilidad, flexibilid
ad, seguridad, etc.
\end_layout

\begin_layout Subsection
Generación de Vistas
\end_layout

\begin_layout Standard
Al termino de cada fase, se cuenta cuenta con una representación gráfica
 del modelo arquitectónico la cual cubre dos aspectos fundamentales de la
 arquitectura del sistema: estructura y comportamiento.
 Las sugerencias aceptadas de las reglas que fueron ejecutadas, agregaron
 hechos a la base de conocimiento.
 Los hechos agregados representas aspectos del sistema de alto nivel, y
 son interpretados como tales para generar vistas que permitan mostrar la
 arquitectura del sistema.
 Cuando un conjunto de reglas finaliza su ejecución, se generan diagramas
 de componentes y de UCMs con su correspondiente mapeo al código fuente.
 Estos diagramas están representados en 
\emph on
FLAbot
\emph default
.
 
\end_layout

\begin_layout Standard
Modelar o capturar las decisiones de diseño arquitectónico está estrechamente
 ligado con la visualización arquitectónica y con la forma en que las decisiones
 de diseño son representadas y manipuladas por los interesados.
 Cada visualización tiene diferentes ventajas y desventajas que un arquitecto
 debe considerar.
\end_layout

\begin_layout Standard
Una vez que la vista es generada, el arquitecto pude realizar modificaciones
 sobre los diagramas.
 Las modificaciones realizadas son sincronizadas con la base de conocimiento
 para reflejar los cambios.
\end_layout

\begin_layout Standard
Es importante destacar que los componentes pueden estar mapeados al código
 fuente de forma explícita.
 Es decir, existe una relación que vincula a la clase 
\family typewriter
UserInterface
\family default
 con el componente 
\family typewriter
UserInterfaceObserver
\family default
 de la figuras 
\begin_inset LatexCommand ref
reference "fig:Diagrama-de-clases-UML-para-el-ejemplo-Observer-Observable"

\end_inset

 y 
\begin_inset LatexCommand ref
reference "fig:Diagrama-de-componentes-de-los-Observers"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y]
\end_layout

\begin_layout Standard
Llevar esta seccion y distribuirla en la implementacion..
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Conclusiones-Cap4"

\end_inset

Conclusiones
\end_layout

\begin_layout Standard
En este capitulo se presentó el enfoque 
\emph on
DRArch
\emph default
, que permite obtener vistas arquitectónicas de un sistema a partir de un
 proceso guiado por el arquitecto.
 Este proceso intenta utilizar la mayor cantidad de información que sea
 posible y sus principales fuentes son: el código, la trazas de ejecución
 y la ex\SpecialChar \-
pe\SpecialChar \-
rien\SpecialChar \-
cia de las personas involucradas en el sistema.
\end_layout

\begin_layout Standard
El proceso de reconstrucción es controlado por el arquitecto en todo momento.
 Su modelo flexible de generación de reglas permite al arquitecto tener
 el control de cuándo y cómo actualizar el modelo arquitectónico.
\end_layout

\begin_layout Standard
Por otro lado, 
\emph on
DRArch
\emph default
 no impone restricciones de un lenguaje específico en el que este implementado
 el sistema a analizar.
 El hecho de transformar la información del sistema a una base de conocimientos
 permite la aplicación del enfoque en muchos sistemas existentes.
\end_layout

\begin_layout Standard
Debemos admitir que no existe la magia.
 Es imposible, desde nuestro punto de vista, que una herramienta pueda recuperar
, sin ayuda alguna, el diseño arquitectónico de un sistema.
 Se necesita del conocimiento del dominio de la aplicación y fundamentalmente
 de la ex\SpecialChar \-
pe\SpecialChar \-
rien\SpecialChar \-
cia del usuario.
 Utilizando el enfoque 
\emph on
DRArch
\emph default
, es posible alcanzar una aproximación de la arquitectura.
 Uno de los aspectos más fuerte del enfoque es que permite especificar cualquier
 tipo de información del sistema para luego ser procesada (consultas a través
 de reglas) y relacionar cualquier tipo de información.
\end_layout

\begin_layout Standard
Adicionalmente, es posible extender la funcionalidad para que la enfoque
 brinde soporte para algunos de los siguientes ítems: 
\end_layout

\begin_layout Itemize
Identificar patrones de diseño.
 
\end_layout

\begin_layout Itemize
Definir un conjunto de reglas que verifiquen si el diseño propuesto se correspon
de con la implementación.
 
\end_layout

\begin_layout Itemize
Detectar anti-patrones.
\end_layout

\begin_layout Standard
En el siguiente capítulo se muestran en detalle algunos aspectos de la implement
ación.
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Implementación"

\end_inset

Diseño e implementación
\end_layout

\begin_layout Standard
El presente capítulo está dedicado a la descripción del diseño e implementación
 de 
\emph on
DRArch
\emph default
.
 Para ello, su estructura y funcionamiento serán descriptos mediante diagramas
 de paquetes y de descomposición de módulos a nivel arquitectónico y, a
 nivel de diseño detallado, mediante diagramas de clases y de interacción
 en notación UML (
\emph on
Uniﬁed Modeling Language
\emph default
) 
\begin_inset LatexCommand cite
key "BURKHARDT97"

\end_inset

, presentando los aspectos más importantes de su implementación.
 A su vez, a medida que se describen los componentes, se muestra cómo hace
 la herramienta 
\emph on
DRArch
\emph default
 para satisfacer las necesidades del enfoque mencionado, siguiendo el ejemplo
 de la sección 
\begin_inset LatexCommand ref
reference "sec:Ejemplo"

\end_inset

.
 El recorrido mencionado en este apartado es un ejemplo simple de una iteración
 en donde se puede observar la intervención del arquitecto en el momento
 de tomar las decisiones que modifican el modelo arquitectónico.
\end_layout

\begin_layout Standard
El capitulo inicia describiendo la arquitectura general de 
\emph on
DRArch
\emph default
 en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Arquitectura"

\end_inset

.
 Continua con una descripción de cada uno de los componentes más importanes
 de la arquitectura.
 En las secciones\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Query-Engine"

\end_inset

, 
\begin_inset LatexCommand ref
reference "sec:Rule-Model"

\end_inset

, 
\begin_inset LatexCommand ref
reference "sec:Phase-Engine"

\end_inset

 y 
\begin_inset LatexCommand ref
reference "sec:TraceLog-Analyzer"

\end_inset

 se explican en detalle cómo fueron diseñados e implementados los componentes
 
\emph on
Query Engine
\emph default
, 
\emph on
Rule Model, Phase Engine, 
\emph default
y 
\emph on
TraceLog Analyzer
\emph default
, respectivamente.
 Finalmente, en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Conclusiones"

\end_inset

 se presentan las conclusiones del capítulo.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Arquitectura"

\end_inset

Arquitectura
\begin_inset Note Note
status open

\begin_layout Standard
tendrian que tener una seccion donde explican las decisiones de diseño para
 cada subcomponente..
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
DRArch
\emph default
 fue implementado como un plug-in de la plataforma Eclipse, aprovechando
 su arquitectura extensible, su modelo para análisis estático de código
 fuente Java y su framework de interfaz de usuario.
 Otro factor que influenció la decisión es la tendencia creciente en el
 uso de Eclipse como herramiento para el desarrollo de software.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
aprovechando su arquitectura extensible, su modelo para análisis estático
 de código fuente Java y su framework de interfaz de usuario.
 
\begin_inset Note Note
status open

\begin_layout Standard
Otra factor que influenció la decisión es la tendencia creciente en el uso
 de eclipse como herramiento para el desarrollo de software.
\end_layout

\end_inset

Esto iria despues..
 de la explicacion de eclipse..
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Standard
En vez de esto..
 tendrian que poner algo como ..
 para el soporte de edicion de diagramas se integró DrArch a FLABot...
 La manipulacion de la informacion estatica de codigo fue implementada sobre
 JQuery...
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para el soporte de edición de diagramas se integró 
\emph on
DRArch
\emph default
 a 
\emph on
FLABot
\emph default
, permitiendo aprovechar el editor gráﬁco de UCMs.
 Además se utilizó el instrumentador de 
\emph on
bytecode
\emph default
 del proyecto 
\emph on
FLABot
\emph default
, ya que también fue implementado como plug-in.
 La manipulación de la información estática de código fue implementada sobre
 
\emph on
JQuery
\emph default
.
 Si bien 
\emph on
JQuery
\emph default
 también ha sido desarrollado como plug-in, en este trabajo se utilizo a
 modo de librería.
 El diseño de 
\emph on
DRArch
\emph default
 está muy inﬂuenciado por la arquitectura ya deﬁnida por 
\emph on
Eclipse
\emph default
.
 Esencialmente, 
\emph on
Eclipse
\emph default
 (ver Apéndice\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Plataforma-Eclipse"

\end_inset

) es una plataforma diseñada para construir herramientas de desarrollo.
 Si bien la plataforma por sí misma no provee mucha funcionalidad al usuario
 ﬁnal, facilita el rápido desarrollo de herramientas con características
 integradas.
 Así, la organización de estas herramientas alrededor de un espacio de trabajo
 común es un principio de diseño central, tanto para Eclipse como para 
\emph on
DRArch
\emph default
.
 En el caso particular de este trabajo, es necesario un cierto nivel de
 integración para aprovechar los componentes existentes de 
\emph on
FLABot
\emph default
 y la infraestructura básica de Eclipse.
 Por estas razones, la arquitectura de 
\emph on
FLABot
\emph default
 ha sido organizada mayormente alrededor de un estilo 
\emph on
data-centered
\emph default
 (centrado en los datos).
 La imposición de este estilo ayuda a soportar los niveles de integración
 antes mencionados y además permite una evolución casi independiente de
 las herramientas.
\end_layout

\begin_layout Standard
La funcionalidad propia de 
\emph on
DRArch
\emph default
 se encuentra organizada alrededor del modelo arquitectónico 
\emph on
BlackBoard
\emph default
, en el cual una base de conocimientos común
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] podrian ponerle un mejor nombre ;-) como base de conocimiento ..
 o algo asi..
\end_layout

\end_inset

 es iterativamente actualizada por fuentes de conocimiento especializadas
 (los especialistas), comenzando con la especificación de un problema y
 culminando con la solución.
 Cada fuente de conocimiento actualiza la base de conocimiento con una solución
 parcial cuando sus requisitos coinciden con el estado de la base de conocimient
o.
 De esta forma los especialistas trabajan juntos en la resolución del problema.
 El modelo 
\emph on
BlackBoard
\emph default
 fue originalmente designado para manejar problemas complejos y mal definidos.
 Los sistemas basados en este modelo están principalmente enfocados en la
 inteligencia artificial.
\end_layout

\begin_layout Standard
En la base de conocimiento las fuentes de conocimiento son ejecutadas automática
mente cuando sus precondiciones coinciden con el estado de la base de conocimien
to y el estado de este es actualizado con las transformaciones propias de
 cada fuente.
 Dado que proceso de recuperación arquitectónica descripto por 
\emph on
DRArch
\emph default
 es un proceso guiado, es el arquitecto el responsable de seleccionar qué
 fuente de conocimiento se va a ejecutar y de decidir cuáles son las transformac
iones que actualizaran el estado del modelo arquitectónico bajo análisis.
 Por esta razón, en la implementación del modelo 
\emph on
BlackBoard
\emph default
 utilizada en esta herramienta, será el arquitecto el encargado de seleccionar
 el orden de ejecución de las transformaciones.
 La base de conocimiento esta determinada por una base de hechos lógicos
 estilo Prolog la cual, como se dijo anteriormente, es cargada en una fase
 inicial de recolección de información estática (código fuente) y dinámica
 (logs de ejecución).
 Las fuentes de conocimiento encargadas de evaluar el estado de la base
 de conocimiento y actualizarlo, están materializados mediante un modelo
 de reglas.
 Éstas reglas están definidas a partir de una consulta, que evalúa el estado
 del repositorio en busca de algún patrón; una sugerencia, la que será presentad
a al arquitecto para cada uno de los resultados de la consulta; y una serie
 de hechos que determinan la actualización del repositorio y por ende la
 transformación del modelo arquitectónico bajo reconstrucción.
\end_layout

\begin_layout Standard
Por último, el modelo de fases determina la operatibilidad de la herramienta.
 Es el componente orquestador responsable de guiar el proceso y coordinar
 la interoperabilidad entre los módulos.
\end_layout

\begin_layout Standard
En la figura 
\begin_inset LatexCommand ref
reference "fig:Diagrama de Paquetes"

\end_inset

 se describen los componentes principales de la herramienta.
 A continuación se provee una descripción de las responsabilidades de cada
 uno.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Package Domain Model.png
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama de Paquetes"

\end_inset

Diagrama de paquetes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Query-Engine"

\end_inset

Query Engine
\end_layout

\begin_layout Standard
Este componente tiene como principal responsabilidad la ejecución de las
 consultas sobre la base de conocimiento y la gestión de esta.
\end_layout

\begin_layout Standard
Forma parte de este componente el motor de consultas y la base de conocimiento.
 Ambas entidades están construidas sobre el plug-in 
\emph on
JQuery
\emph default
 
\begin_inset LatexCommand ref
reference "sec:JQuery"

\end_inset

.
 
\end_layout

\begin_layout Standard

\emph on
JQuery
\emph default
 esta basado en 
\emph on
TyRuBa
\emph default
 que es un lenguaje de programación lógica implementado en Java.
 De esta forma 
\emph on
JQuery
\emph default
 provee a 
\emph on
DRArch
\emph default
 de tres componentes fundamentales: el motor de inferencias, el lenguaje
 de consultas que se ulitizarán en las reglas y la implementación de la
 base de conocimiento sobre la que se realizarán dichas consultas.
 Cada uno de estos componentes han sido abstraídos desacoplándolos de su
 implementación permitiendo que, con mínimo esfuerzo, dichas implementaciones
 puedan variar o evolucionar independientemente.
\end_layout

\begin_layout Subsubsection
KnowledgeBase
\end_layout

\begin_layout Standard
La base de conocimiento consta de dos partes.
 La primera esta basada en los hechos generados durante la fase de recolección
 de la información y la segunda consiste en todos lo hechos generados por
 las ejecuciones de las reglas 
\emph on
DRArch
\emph default
 los cuales se agrupan por fases de ejecución.
 Estos últimos se han hecho persistentes en un archivo de texto con el propósito
 de reutilizar el resultado del análisis realizado en fases subsiguientes.
\end_layout

\begin_layout Standard
De esta forma la base de conocimiento evaluada en cada fase esta compuesta
 por la base de conocimiento (generada por el parseo del código fuente)
 y por todos los archivos de hechos lógicos que se agreguen a la fase.
\end_layout

\begin_layout Standard
En el análisis estático, una porción del código fuente correspondiente al
 ejemplo 
\emph on
Observer-Observable
\emph default
, se transforma a la representación que se detalla en la figura 
\begin_inset LatexCommand ref
reference "fig:Ejemplo-de-la-representación-del-código-fuente"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/java2jquery.jpg
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Ejemplo-de-la-representación-del-código-fuente"

\end_inset

Ejemplo de la representación del código fuente
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Rule-Model"

\end_inset

Rule Model
\end_layout

\begin_layout Standard
El modelo de reglas esta formado principalmente por cuatro entidades: 
\family typewriter
Rule
\family default
, 
\family typewriter
Query
\family default
, 
\family typewriter
SuggestTemplate
\family default
 y 
\family typewriter
FactTemplates
\family default
.
 Una regla 
\family typewriter
Rule
\family default
 es la entidad mas importante de este componente porque determina la unidad
 funcional de la herramienta.
 Una regla, esta determinada por un 
\family typewriter
Query
\family default
, un 
\family typewriter
SuggestTemplate
\family default
 y un conjunto de 
\family typewriter
FactTemplates
\family default
.
 Un 
\family typewriter
Query
\family default
, a su vez, esta compuesto por una sentencia en formato ProLog que será
 utilizada para realizar una consulta sobre la base de conocimiento y un
 conjunto de variables de interés.
 Estas variables son parte de la consulta.
\end_layout

\begin_layout Standard
Cada 
\family typewriter
SuggestTemplate
\family default
 es una cadena de caracteres con 
\emph on
wildcard
\emph default
 que serán reemplazados por cada uno de los resultados de la consulta.
 Generalmente cada 
\emph on
wildcard
\emph default
 se corresponde con una variable de la consulta.
 Luego de la ejecución, el resultado de la consulta queda determinado por
 los valores de las variables de interés.
 Para cada uno de estos resultados se genera una sugerencia reemplazando
 cada 
\emph on
wildcard
\emph default
 con su correspondiente variable.
\end_layout

\begin_layout Standard
Por ultimo cada 
\family typewriter
FactTemplate
\family default
 del conjunto esta construido de la misma forma que los templates de sugerencias.
 Luego que las sugerencias hayan sido aceptadas se procede a instanciar
 un conjunto de hechos con los correspondientes valores para cada una de
 las sugerencias aceptadas.
 La figura 
\begin_inset LatexCommand ref
reference "fig:Modelo-de-reglas"

\end_inset

 muestra la relación entre estas entidades.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ruleModel.png
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Modelo-de-reglas"

\end_inset

Modelo de reglas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Básicamente el modelo de reglas es una estructura de datos, la cual es necesario
 persistir, visualizar y editar de forma gráfica y amigable para el usuario.
 Se eligió para su implementación el framework EMF de Eclipse.
 EMF es un framework de modelado y generación de código para generar aplicacione
s basadas en un modelo de datos estructurado.
 A partir de la especificación de un modelo descripto en XMI, EMF provee
 las herramientas para producir un conjunto de clases Java para el modelo,
 junto con un conjunto de clases 
\emph on
adapters
\emph default
 que permiten la visualización y edición del mismo.
\end_layout

\begin_layout Standard
Como se mencionó anteriormente, es necesario que un conjunto de reglas pueda
 ser reutilizado y ejecutado varias veces y sobre distintas instancias de
 la base de conocimiento.
 Por esta razón es necesario persistir las reglas creadas para su posterior
 utilización y/o edición.
 Utilizando las capacidades del framework EMF, se logró la persistencia
 del modelo como así también la creación de un editor propio de la herramienta
 
\emph on
DRArch
\emph default
 que hace realmente sencilla la edición y visualización de los datos.
\end_layout

\begin_layout Standard
La herramienta 
\emph on
DRArch
\emph default
 presenta una interface de usuario para la especificación de reglas (crear,
 editar y borrar reglas).
 En la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Especificando-Reglas"

\end_inset

 se muestra un 
\emph on
screenshot
\emph default
 de la pantalla con las tres partes mas importantes de la especificación
 de una regla: la consulta, la sugerencia que genera la ejecución de la
 consulta, y los hechos que se deben agregar a la base de conocimientos
 en el caso de que el arquitecto decida aceptar la sugerencia durante el
 proceso de reconstrucción.
 En la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:JQuery"

\end_inset

 del apéndice se encuentra un catálogo completo de los hechos disponibles
 junto con una descripción (en la herramienta es posible acceder a dicho
 catálogo a través de la ayuda).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableRule.jpg
	scale 80

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Especificando-Reglas"

\end_inset

Especificación de una regla para el ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Phase-Engine"

\end_inset

Phase Engine
\end_layout

\begin_layout Standard
Este componente es el encargado de la coordinación y mediación entre los
 componentes descriptos anteriormente.
 Como se menciono en capítulos anteriores, el enfoque 
\emph on
DRArch
\emph default
 posee las propiedades de ser interactivo, iterativo e incremental.
 
\end_layout

\begin_layout Standard
La primera de estas características se da al brindarle al arquitecto el
 control total de lo que se evalúa, tomando todas las decisiones aceptando
 o rechazando las sugerencias propuestas por la herramienta.
 Para satisfacer las demás características se implementó un mecanismo de
 fases iterativas que permite la composición de los resultados de las evaluacion
es realizadas en iteraciones previas.
 
\end_layout

\begin_layout Subsubsection*
Fase
\end_layout

\begin_layout Standard
Una fase tiene como entrada un 
\emph on
working set 
\emph default
(modulo de código que será analizado), una serie de reglas que serán evaluadas
 sobre ese módulo y los archivos de hechos que vayan a componer la base
 de conocimiento para la fase en cuestión.
 El resultado de ejecutar una fase son dos artefactos: un archivo de hechos
 que fueron producto de la ejecución de cada regla de la fase y un archivo
 
\emph on
FLABot
\emph default
 con la representación gráfica del modelo arquitectónico recuperado.
\end_layout

\begin_layout Standard
Alternativamente se puede enriquecer la base de conocimientos de la fase,
 incorporando un archivo 
\emph on
FLABot
\emph default
 con un modelo arquitectónico definido y transformar la información del
 modelo arquitectónico del archivo a hechos lógicos.
\end_layout

\begin_layout Standard
La entidad 
\family typewriter
PhaseManager
\family default
 es la encargada de lanzar la ejecución de una fase.
 En ese momento se comienzan a ejecutar una por una las reglas que forman
 parte de la fase.
 Al finalizar la ejecución de cada regla, desde la capa de presentación
 se le piden al 
\family typewriter
PhaseManager
\family default
 dichas sugerencias para ser presentadas al usuario.
 Allí se pasa el control al usuario, quien es responsable de decidir que
 sugerencias acepta y disparar la ejecución de la próxima regla.
 Antes de ejecutar la siguiente regla de la fase, la entidad 
\family typewriter
PhaseManager
\family default
 le pide a la entidad 
\family typewriter
RuleManger
\family default
 que transforme las sugerencias en hechos concretos y luego agrega dichos
 hechos a la base de conocimientos.
 Luego, le da la orden a la entidad 
\family typewriter
DiagramManager
\family default
 que genere los diagramas.
 Finalmente con los nuevos hechos en la base de conocimiento y el diagrama
 generado se dispara la ejecución de la nueva regla.
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Phase-model"

\end_inset

 muestra la estructura del modelo de ejecución de fases.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/stepEngine.png
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Phase-model"

\end_inset

Modelo de fases
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Existen dos tipos de fases: las interactivas y las no interactivas.
 Las fases interactivas son aquellas que al finalizar la ejecución de cada
 regla se presentan las sugerencias al usuario para que este las acepte
 o las rechace.
 Las no interactivas en cambio, automáticamente aceptan todas las sugerencias
 y retorna el control al usuario una vez completada la fase.
 De esta forma se da la posibilidad de automatizar aquellas fases que contengan
 reglas con sugerencias que siempre serán aceptadas.
 Por ejemplo, es posible definir reglas que enriquezcan el análisis estático
 de código fuente provisto por 
\emph on
JQuery
\emph default
 y utilizar dichas reglas en la fase inicial de recolección de información.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard

\series bold
run-phase
\series default
(phase: Phase)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
for
\series default
 rule 
\series bold
in
\series default
 phase
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
suggestions = rule.execute()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
for
\series default
 suggestion 
\series bold
in
\series default
 suggestions
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
if
\series default
 suggestion.isAccepted()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
knowledgeBase.add(suggestion.getFacts())
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
loadModel()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
updateDiagram()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end if
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard

\series bold
end run-phase
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Algoritmo-ejecución-de-fases"

\end_inset

Algoritmo de ejecución del modelo Fases
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La ejecución de cada fase se decribe en el Algorítmo\InsetSpace ~

\begin_inset LatexCommand ref
reference "alg:Algoritmo-ejecución-de-fases"

\end_inset

, en donde cada una de éstas obtiene la primer regla y la ejecuta.
 Luego muestra las sugerencias y si el arquitecto aceptas, agrega los nuevos
 hechos a la base de conocimiento.
 Posteriormente carga el nuevo modelo, actualiza los diagramas, y vuelve
 a ejecutar la siguieten regla.
 Esto se repite hasta que no queden más reglas.
\end_layout

\begin_layout Standard
Para reflejar la toma de decisiones y poder
\series bold
 
\series default
manipular las propuestas arquitectónicas, la herramienta expone dicha funcionali
dad por medio de 
\emph on
chekboxes
\emph default
 que indican si la sugerencia se acepta o se rechaza.
 Siguiendo con el ejemplo del 
\emph on
Observer-Observable
\emph default
, en la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Vista-de-sugerencias"

\end_inset

 se muestra la vista de sugerencias para la regla que detecta componentes
 
\emph on
Observer.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/DrarchSuggestView.jpg
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Vista-de-sugerencias"

\end_inset

Vista de sugerencias
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las iteraciones terminan cuando ya no quedan más reglas dentro de la fase
 que actualmente se esté ejecutando.
\end_layout

\begin_layout Subsubsection*
RuleManager
\end_layout

\begin_layout Standard
La entidad 
\family typewriter
RuleManager
\family default
 es responsable de la ejecución de las reglas y de interpretar los resultados
 para armar las sugerencias, así como también de crear para cada sugerencia
 aceptada el conjunto de hechos correspondiente según lo define el modelo
 de reglas.
 También es responsable de incorporar estos a la base de conocimiento.
 La ejecución de las consultas como se dijo anteriormente está a cargo de
 la entidad 
\family typewriter
QueryEngine
\family default
.
\end_layout

\begin_layout Standard
La Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Rule-Manager"

\end_inset

 muestra la estructura de este componente y su interacción con el 
\family typewriter
QueryEngine
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename img/ruleEngine.png
	width 70theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Rule-Manager"

\end_inset

Rule Manager
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
DiagramManager
\end_layout

\begin_layout Standard
La entidad 
\family typewriter
DiagramManager
\family default
 esta encargada de traducir la información contenida en la base de conocimiento
 a los modelos de diagramas de 
\emph on
DRArch
\emph default
 (componentes y UCMs).
 Ejecuta una serie de consultas a la base de conocimiento mediante 
\family typewriter
QueryEngine
\family default
 para obtener la información arquitectónica con la que construirá el modelo.
 Luego es llevado al modelo 
\emph on
FLABot
\emph default
 y se delega a esta herramienta el renderizado de los diagramas.
 
\end_layout

\begin_layout Standard
La Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Phase-Management-Interaction"

\end_inset

 y la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-secuencias"

\end_inset

 muestran los distintos componentes y sus relaciones.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Phase Interaction.png
	width 90text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Phase-Management-Interaction"

\end_inset

Diagrama de interacciones entre los componentes 
\emph on
DRArch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Sequence Diagram.png
	width 50pheight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-secuencias"

\end_inset

Diagrama de secuencia entre los componentes 
\emph on
DRArch
\emph default
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es decir, la entidad es responsable de la generación de vistas.
 Si las sugerencias de la regla especificada en el ejemplo\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Especificando-Reglas"

\end_inset

 son aceptadas, el proceso de reconstrucción genera el diagrama de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-componentes-de-los-Observers"

\end_inset

.
 A su vez, una vez que se termine la actualización de las vistas, el arquitecto
 tiene la posibilidad de modificar los diagramas desde el editor gráfico.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserversComponentDiagram.jpg
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-componentes-de-los-Observers"

\end_inset

Diagrama de componentes de los 
\emph on
Observers
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:TraceLog-Analyzer"

\end_inset

TraceLog Analyzer
\end_layout

\begin_layout Standard
Como se expuso brevemente en el capítulo anterior, es necesario registrar
 los eventos de bajo nivel que ocurren en la aplicación mientras el usuario
 la ejercita con los casos de uso correspondientes.
 Para ello se utilizó la infraestructura de instrumentación de código de
 
\emph on
FLABot
\emph default
 (apéndice\InsetSpace ~

\begin_inset LatexCommand ref
reference "cha:Eclipse-FLABot-y-JQuery"

\end_inset

, sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:FLABot"

\end_inset

), ya que ésta define un punto de extensión para la configuración de los
 eventos que deben ser registrados en tiempo de ejecución.
\end_layout

\begin_layout Standard
Básicamente, para la ejecución de una aplicación instrumentada es necesario
 (a) crear una nueva configuración de ejecución en Eclipse (
\emph on
launch configuration
\emph default
, Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "cap:Launch-config"

\end_inset

) y (b) iniciar la ejecución de esta configuración.
 
\emph on
FLABot
\emph default
 permite la es\SpecialChar \-
pe\SpecialChar \-
cia\SpecialChar \-
li\SpecialChar \-
za\SpecialChar \-
ción de la funcionalidad del módulo de instrumentación
 mediante el punto de extensión 
\emph on

\begin_inset Quotes eld
\end_inset

org.isistan.flabot.contextProvider
\begin_inset Quotes erd
\end_inset


\emph default
, que consiste en la definición de dos interfaces abstractas: 
\emph on
AbstractConfigurationTab
\emph default
 y 
\emph on
FlabotFileContextProvider
\emph default
, responsables de los puntos (a) y (b) respectivamente\SpecialChar \@.
 Las implementaciones
 de la primera interfaz se encargan de permitir al usuario configurar de
 manera gráfica la información necesaria para la creación del log de ejecución
 (ubicación del archivo de sa\SpecialChar \-
li\SpecialChar \-
da, tipos de eventos a registrar, profundidad
 de la inspección, etc.), mientras que las de la segunda interfaz proveen
 esta información al módulo de instrumentación.
 La relación entre 
\emph on
DRArch
\emph default
 y 
\emph on
FLABot
\emph default
 por medio de puntos de extensión se resume en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Relación-entre-DRArch"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/RunFlabotCollecting.png
	lyxscale 80
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Configuración-de-ejecución"

\end_inset

Configuración de ejecución en Eclipse
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/TraceLogConfigurationClassDiagram.PNG
	width 45page%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Relación-entre-DRArch"

\end_inset

Relación entre 
\emph on
DRArch
\emph default
 y 
\emph on
FLABot
\emph default
 mediante puntos de extensión
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una vez definida la extensión, la interacción entre 
\emph on
FLABot
\emph default
 y 
\emph on
DRArch
\emph default
 es relativamente simple.
 El arquitecto debe configurar la ejecución de la aplicación a instrumentar
 desde una interfaz de usuario de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Configuración-de-ejecución"

\end_inset

.
 Algunas de estas configuraciones son:
\end_layout

\begin_layout Enumerate
La aplicación a ser instrumentada.
\end_layout

\begin_layout Enumerate
El archivo de salida (
\emph on
nombre_del_archivo.tracelog
\emph default
).
\end_layout

\begin_layout Enumerate
El modelo 
\emph on
FLABot
\emph default
 que contiene la información de qué es lo que se va a instrumentar.
 Este modelo es generado por 
\emph on
DRArch.
\end_layout

\begin_layout Enumerate
El nivel de profundidad en el que se va a guardar la información.
 Cuanto mas profundidad, más información tendrá el log.
\end_layout

\begin_layout Standard
Una vez que fue creado un log de ejecución para un caso de uso en particular,
 
\emph on
Log Analyzer
\emph default
 se encarga de interpretar los eventos de bajo nivel contenidos en el log
 para transformarlos en hechos al estilo 
\emph on
ProLog
\emph default
.
 El proceso de transformación sigue un algoritmo simple: el componente utiliza
 la información de mapeo entre responsabilidades y métodos recorriendo el
 log de ejecución y tomando sus entradas (ejecuciones de métodos) una a
 una.
 Este proceso se muestra en el Algoritmo\InsetSpace ~

\begin_inset LatexCommand ref
reference "alg:Algoritmo-Log-Analyzer"

\end_inset

.
 Este algoritmo también se encarga de generar los hechos del estilo 
\family typewriter
snapshot
\family default
, encargados de guardar la información relacionada con el estado del sistema
 en el momento que se ejecuto una responsabilidad.
 Guardar toda la información del estado del sistema en el momento en el
 que se ejecuta cada responsabilidad es costoso debido a que la información
 aumenta exponencialmente y puede traer problemas de referencia cíclica.
 Por esta razón se define la profundidad del análisis como parámetro de
 configuración de la ejecución del log (parámetro 
\emph on
Level of Depth Log
\emph default
 de la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Configuración-del-log"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard

\series bold
log-analyzer
\series default
(log: Log, mappings: Mappings)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
factList = new List
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
for
\series default
 entradaLog 
\series bold
in
\series default
 log
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
responsabilidades = mappings.getResponsibilities(entradaLog)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
materializaciones = responsabilidades.getExecutions()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
for
\series default
 materialization 
\series bold
in
\series default
 materializaciones
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
execId = materialization.getTags().get("executionId")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
exitValue = materialization.getTags().get("value")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
arguments[] = materialization.getTags().get("arguments")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
behavior = materialization.getTags().get("behavior")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
methodName = behavior.getTags() .get("name")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
className = behavior.getTags().get("declaringClass")
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
factsList.add(predicateFactory.createExecutedMethodValue(
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
className + "." + methodName, execId, exitValue, arguments[]))
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
snapshotFacts(materialization)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
end for
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\series bold
return
\series default
 factList
\end_layout

\begin_layout Standard

\series bold
end log-analyzer
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:Algoritmo-Log-Analyzer"

\end_inset

Algoritmo Log Analyzer
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los hechos generados por este componente son almacenados en la base de datos
 del conocimiento junto con el resto de la información.
 De esta forma, quedaría disponible la posibilidad de relacionar información
 tanto estática como dinámica.
\end_layout

\begin_layout Standard
Como resumen del análisis dinámico, el 
\emph on
log
\emph default
 de ejecución generado por la combinación de las he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
tas 
\emph on
DRArch
\emph default
 y 
\emph on
FLAbot
\emph default
, es analizado por el componente TraceLog Analizer para generar los hechos
 ProLog correspondientes al 
\emph on
log
\emph default
 de ejecución.
 De esta forma, en la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Observer-Observable-TraceLog"

\end_inset

 se muestran los hechos correspondientes al ejemplo 
\emph on
Observer-Observable
\emph default
 que se generan luego de analizar el 
\emph on
log
\emph default
 de ejecución.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ObserverObservableTraceLog.jpg
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Observer-Observable-TraceLog"

\end_inset

Transformación del 
\emph on
log
\emph default
 de ejecución del ejemplo 
\emph on
Observer-Observable
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Conclusiones"

\end_inset

Conclusiones
\end_layout

\begin_layout Standard
En éste capítulo se describieron los aspectos más importantes acerca de
 la arquitectura, diseño detallado e implementación de 
\emph on
DRArch
\emph default
.
 La herramienta requiere la colaboración de componentes pertenecientes a
 otros sistemas, mas específicamente 
\emph on
Eclipse
\emph default
, 
\emph on
FLABot
\emph default
 y 
\emph on
JQuery
\emph default
.
 
\end_layout

\begin_layout Standard

\emph on
Eclipse
\emph default
 fue seleccionado principalmente por ser el entorno de desarrollo Java más
 popular en la actualidad y además, por brindar una arquitectura preparada
 para la integración de herramientas mediante extensiones.
 En segundo lugar, 
\emph on
Eclipse
\emph default
 ofrece un metamodelo del lenguaje Java idóneo para la manipulación de informaci
ón de código fuente.
 
\end_layout

\begin_layout Standard

\emph on
JQuery
\emph default
 es quien utiliza las ventajas de Eclipse sobre el metamodelo del lenguaje
 Java para realizar la transformación del código fuente a una representación
 de hechos al estilo 
\emph on
ProLog
\emph default
.
 
\end_layout

\begin_layout Standard

\emph on
FLABot
\emph default
, por otro lado, se emplea por dos razones centrales: ofrece un editor UCM
 con soporte para mapeo responsabilidad-código y además incluye soporte
 para instrumentar aplicaciones.
 El motor de instrumentación de aplicaciones 
\emph on
FLABot
\emph default
 genera un log de bajo nivel que es procesado por el componente 
\emph on
TraceLog Analyzer
\emph default
 para realizar una transformación de la información en hechos al estilo
 
\emph on
ProLog
\emph default
.
\end_layout

\begin_layout Standard
A diferencia de algunos de los enfoques mencionados en el capítulo 
\begin_inset LatexCommand ref
reference "cha:Trabajos-relacionados"

\end_inset

, los cuales siguen el mismo patrón de extraer, abstraer y presentar y que
 utilizan una base de datos relacional para almacenar las representaciones
 intermedias del modelo arquitectónico, 
\emph on
DRArch
\emph default
 utiliza el motor de consultas y la base de datos lógica provista por 
\emph on
JQuery
\emph default
.
 Esta decisión se basa en que al momento de realizar una consulta en un
 lenguaje lógico, se consulta por el qué y no por el cómo es el caso de
 los enfoques relacionales Esto hace que hace más sencillo y natural al
 arquitecto formular sus propias reglas.
 Para tal propósito se creó un editor utilizando las ventajas que ofrece
 SWT, un 
\emph on
toolkit
\emph default
 de elementos gráficos diseñados para ser portables y aprovechar las capacidades
 de los sistemas operativos sobre los que se ejecuta.
\end_layout

\begin_layout Standard
De esta forma al estar todo lo necesario integrado en el ambiente de desarrollo,
 si el arquitecto pretende incorporar la tarea de reconstrucción a su rutina,
 podrá hacerlo incluyendo únicamente el plug-in 
\emph on
DRArch
\emph default
 y sus dependencias, es decir: 
\emph on
FLABot
\emph default
 y 
\emph on
JQuery
\emph default
.
\end_layout

\begin_layout Standard
En el próximo capítulo se analizará el desempeño de 
\emph on
DRArch
\emph default
 ante un sistema real en desarrollo: 
\emph on
G2
\emph default
.
 Tales casos de estudio permitirán evaluar mejor la conveniencia de las
 decisiones de diseño explicadas en este capítulo.
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Casos-de-Estudio"

\end_inset

Casos de estudio
\end_layout

\begin_layout Standard
Este capítulo describe una serie de casos de estudio que realizamos para
 verificar si las suposiciones hechas a nivel conceptual pueden ser corroboradas
 en la práctica.
 Los casos de estudio presentados aquí apuntan primero a demostrar que el
 enfoque 
\emph on
DRArch
\emph default
 puede ser aplicable a la reconstrucción arquitectónica de un sistema, y
 segundo, a ilustrar cómo se usó la herramienta en diferentes proyectos
 para poder investigar los puntos fuertes y débiles del enfoque.
 En particular, en este capítulo se pretende analizar la utilidad y efectividad
 de la herramienta frente a un sistema real ya implementado.
 En cada caso de estudio se presenta (a) un detalle de la arquitectura del
 sistema --necesaria para realizar comparaciones--, (b) un resumen de las
 fases ejecutadas --describiendo la naturaleza de las reglas-- y (c) las
 vistas mas relevantes que se obtuvieron durante la ejecución del proceso
 de reconstrucción --importante para realizar la comparación con la arquitectura
 presentada en el punto (a)--.
\end_layout

\begin_layout Standard
La selección de los casos de estudio estuvo organizada de acuerdo con una
 estrategia incremental.
 Inicialmente, se probó la herramienta con ejemplos simples como los presentados
 en los capítulos anteriores.
 Ésto permitió ajustar el funcionamiento del prototipo hasta obtener resultados
 aceptables.
 Una vez alcanzada una versión re\SpecialChar \-
la\SpecialChar \-
ti\SpecialChar \-
va\SpecialChar \-
men\SpecialChar \-
te estable del prototipo, se realizó
 la reconstrucción de un proyecto de prueba llamado Market, y luego, se
 paso a reconstruir un proyecto comercial de tamaño mediano, llamado 
\emph on
G2
\emph default
.
 En esta etapa, se probó el desempeño de la herramienta frente a un sistema
 real.
 Ambos proyectos utilizan un framework basado en invocaciones implícitas
 llamado Bubble\InsetSpace ~

\begin_inset LatexCommand cite
key "CAMPO02"

\end_inset

.
\end_layout

\begin_layout Standard
El capítulo se encuentra organizado de la siguiente manera.
 Primero se presenta el caso de estudio Market en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Market"

\end_inset

.
 Luego se presenta un caso para el sistema 
\emph on
G2
\emph default
 en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:G2"

\end_inset

.
 Para ambos casos de estudio, se muestra la arquitectura originalmente propuesta.
 Finalmente, en la sección\InsetSpace ~

\begin_inset LatexCommand ref
reference "sec:Análisis-de-resultados"

\end_inset

, se comparan los resultados de ambos mediante un breve análisis.
\end_layout

\begin_layout Description
Suposiciones
\end_layout

\begin_layout Standard
Si bien los casos de uso se basan en un mismo estilo arquitectónico subyacente
 (framework de invocación implícita), esto no implica que la herramienta
 
\emph on
DRArch
\emph default
 sea eficiente sólo con este típo de estilos arquitectónicos, si no que
 soporta una gran variedad.
\end_layout

\begin_layout Standard
Por otro lado, la documentación original de los sistemas que se utilizaron
 para realizar los experimentos, casi no se tuvo en cuenta para realizar
 la reconstrucción.
 Sin embargo, luego de obtener los resultados, la documentación original
 se utilizó para realizar comparaciónes y así poder medir la eficiencia
 de la herramienta.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
2- Los casos de estudio, como estan presentados, no muestran mucha informacion
 de como se fueron reconstruyendo las vistas, que limitaciones hubo, que
 cosas el tool pudo reconstruir y cuales no, ...
 ...Algunos cabos "sueltos" mientras leia respecto a esto: 
\end_layout

\begin_layout Standard
[Y] a) no ayuda mucho el hecho de que los 2 casos de estudio se basen en
 el mismo estilo arquitectonico subyacente (Bubble), ya que hay que hacer
 el analisis si lo recuperado es porque esta el Bubble de base y DArch trabaja
 bien para Bubble, o se puede aplicar a otros tipos de arquitecturas.
 O sea, no estoy diciendo que haya que cambiar los casos de estudio, pero
 si hacer las salvedades, suposiciones y analisis del caso 
\end_layout

\begin_layout Standard
[Y] b) no entendi que muestran las metricas que toman para evaluar cosas
 de los casos de estudio.
 Dado que las metricas me suenan fuertemente inspiradas en el paper de ArchSync,
 no se hasta que punto el "contexto " del ArchSync es extrapolable al DArch,
\end_layout

\begin_layout Standard
[Y] c) otra cosa que hay que discutir en los casos de estudio es como se
 uso la documentacion original de cada caso de estudio.
 Una opcion es: casi no se uso, y luego de realizar la recuperacion se realizo
 una comparacion entre lo recuperado y lo que decia la documentacion inicial.
 Otra opcion es: se uso la documentacion inicial como una forma de explorar
 mejor el codigo realizar una mejora substancial en la documentacion o entendimi
ento de la arquitectura.
 Either option, se tiene que discutir 
\end_layout

\begin_layout Standard
d) un posible trabajo que yo agregaria en los casos de estudio es recuperar
 las mismas arquitecturas (Market y G2) con otro tool, ej con Shrimp/Creole,
 y hacer una comparacion de cuales son los puentos fuertes y debiles de
 ese tool, y como DArch mejora eso (especialmente la parte dinamica, interactivi
dad, bla bla)
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Market"

\end_inset

Market
\end_layout

\begin_layout Standard
Market es un sistema donde compradores (
\emph on
buyers
\emph default
) y vendedores (
\emph on
sellers
\emph default
) son libres de realizar transacciones.
 De esta forma, el mercado es un contenedor de agentes en donde compradores
 y vendedores son simples agentes (
\emph on
agents
\emph default
).
 Todos los agentes pueden realizar un conjunto de tareas (
\emph on
tasks
\emph default
).
 Una tarea esta compuesta por uno o mas procedimientos.
 Las tareas se disparan con condiciones predefinidas, y pueden estar relacionada
s al estado interno del agente o a un evento 
\begin_inset LatexCommand cite
key "Drogoul92"

\end_inset

.
 Para realizar este comportamiento, Market utiliza un framework basado en
 invocación implícita llamado Bubble\InsetSpace ~

\begin_inset LatexCommand cite
key "CAMPO02"

\end_inset

, donde los componentes principales son: agentes, tareas, sensores y eventos.
 Los agentes representan entidades del dominio y para separa el estado de
 las acciones, se utiliza la noción de tareas.
 La interacción entre los agentes, llamados 
\emph on
bubbles
\emph default
, es realizada a través de eventos que ellos mismos producen y reciben.
 Los agentes están asociados a sensores (como filtros) que son registrados
 para activarse con determinados eventos o grupos de eventos 
\begin_inset LatexCommand cite
key "Andres2001"

\end_inset

.
 La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-clases-Bubble"

\end_inset

 muestra un diagrama de clases del framework Bubble con las principales
 clases pintadas con color azul y la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Modelo-arquitectónico-del-Bubble"

\end_inset

 muestra un diagrama del modelo arquitectónico del 
\emph on
fremework
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/BubbleCoreClassDiagram.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-clases-Bubble"

\end_inset

Diagrama de clases del framework Bubble.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/BubbleModeloConceptual.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Modelo-arquitectónico-del-Bubble"

\end_inset

Modelo arquitectónico del framework Bubble.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
La instanciación del framework Bubble que realiza Market esta materializada
 con las siguientes clases:
\end_layout

\begin_layout Itemize
Tareas:
\end_layout

\begin_deeper
\begin_layout Itemize
BidTask
\end_layout

\begin_layout Itemize
BuyTask
\end_layout

\begin_layout Itemize
InitializeTimerTask
\end_layout

\begin_layout Itemize
ProcessOrderTask
\end_layout

\begin_layout Itemize
RequestTask
\end_layout

\begin_layout Itemize
SellTask
\end_layout

\begin_layout Itemize
TimerTask
\end_layout

\end_deeper
\begin_layout Itemize
Agentes
\end_layout

\begin_deeper
\begin_layout Itemize
Customer
\end_layout

\begin_layout Itemize
Dealer
\end_layout

\begin_layout Itemize
Timer
\end_layout

\end_deeper
\begin_layout Itemize
Eventos
\end_layout

\begin_deeper
\begin_layout Itemize
MarketAgentEvent
\end_layout

\end_deeper
\begin_layout Itemize
Sensores
\end_layout

\begin_deeper
\begin_layout Itemize
CustomerSensor
\end_layout

\begin_layout Itemize
DealerSensor
\end_layout

\begin_layout Itemize
TimerSensor
\end_layout

\end_deeper
\begin_layout Standard
La documentación de la arquitectura del Market provee un conjunto de UCMs
 que nos permiten entender el comportamiento del sistema.
 Con el objetivo de poder hacer comparaciones con los resultados obtenidos
 con el 
\emph on
DRArch
\emph default
, en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Market-UCMs"

\end_inset

 se muestran algunos de estos UCMs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/MarketDiagramasUCM.png
	width 50theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Market-UCMs"

\end_inset

Diagramas UCMs para el proyecto Market
\emph on
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Caso 1
\end_layout

\begin_layout Standard
Con el objetivo de poder reconstruir uno de los aspectos más importantes
 de la arquitectura del sistema Market, en este caso de estudio se utilizó
 la herramienta 
\emph on
DRArch
\emph default
 teniendo en cuenta de que la funcionalidad del sistema esta organizada
 en 
\emph on
tareas.
\end_layout

\begin_layout Subsubsection
Fase de recolección de información
\end_layout

\begin_layout Standard
Como primera fase, se debe seleccionar el código fuente que se va a incluir
 en el análisis.
 En este caso, utilizaremos todo el código fuente disponible del sistema
 Market.
 Luego, se debe incluir la información dinámica, y para esto, se debe ejecutar
 un caso de uso que represente la funcionalidad principal del sistema.
 
\end_layout

\begin_layout Standard
Un caso de uso típico para este sistema es el de realizar una oferta (
\emph on
bidding
\emph default
).
 Debido a que la aplicación es un un ejemplo para utilizar el framework
 Bubble, hay un único punto de entrada al sistema que ejecuta todos los
 casos de uso sin interface de gráfica (modo consola) y sin necesidad de
 utilizar datos de entrada.
 En la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Configuración-del-log"

\end_inset

 se muestra la configuración necesaria para generar el log de ejecución.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/EclipseRunFlabotConfiguration.png
	width 60theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Configuración-del-log"

\end_inset

Configuración para la generación del log de ejecución en 
\emph on
Eclipse
\emph default
 utilizando 
\emph on
FLAbot.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Luego de generar el log, 
\emph on
DRArch
\emph default
 traduce automáticamente la información del log a la base de conocimientos
 para que se pueda tener en cuenta en el análisis.
\end_layout

\begin_layout Subsubsection
Fase de estructura de paquetes
\end_layout

\begin_layout Standard
Basado en el supuesto de que cualquier sistema se debe dividir en unidades
 más pequeñas, esta fase intenta identificar esas unidades con el objetivo
 de acotar el análisis y hacer foco en las unidades de mayor relevancia.
 Las reglas que componen esta fase son simples (del estilo 
\family typewriter
package(?P)
\family default
) ya que proponen la división de unidades basándose en la estructura de
 paquetes que presenta el código fuente.
 De esta forma, se identificaron tres unidades distintas: 
\family typewriter
bubble.core
\family default
, 
\family typewriter
distribution
\family default
 y 
\family typewriter
market
\family default
.
 
\end_layout

\begin_layout Subsubsection
\begin_inset LatexCommand label
name "sub:Fase-de-invocación-implicita"

\end_inset

Fase de invocación implícita
\end_layout

\begin_layout Standard
Esta fase esta compuesta por reglas cuyo propósito es descubrir componentes
 y relaciones que puedan ser parte de un framework basado en invocaciones
 implícitas, es decir, detectar los puntos de extención para el manejo de
 eventos, tareas, agentes, etc.
 Con la división de unidades realizada en la fase anterior, se decidió correr
 esta fase únicamente a los artefactos de código fuente ubicados dentro
 del paquete 
\family typewriter
bubble.core
\family default
, ya que por su nombre y por las clases que lo contienen, se presenta como
 candidato para alojar los componentes principales del framework.
 Las reglas más importantes presentadas por la herramienta 
\emph on
DRArch
\emph default
 se agrupan en las siguientes categorías:
\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
tareas: Este conjunto de reglas tiene como objetivo materializar
 artefactos del código fuente a componentes que representen una tarea.
 Las consultas buscan clases que tengan un nombres clave (
\family typewriter
Task
\family default
, 
\family typewriter
Tarea
\family default
, etc.), que contengan métodos 
\emph on
hook
\emph default
 o abstractos, que alguno de estos métodos sea tenga el nombre 
\family typewriter
run
\family default
, etc.
\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
manejadores\InsetSpace ~
de\InsetSpace ~
eventos: Es complicado reconstruir este tipo de
 componentes, generalmente, son clases que implementan alguna clase con
 el nombre 
\family typewriter
Event\SpecialChar \-
Handler
\family default
, con algún método que tenga como argumento un evento, así como también
 propiedades privadas del tipo listas que contengan eventos.
 Esto se presenta como su\SpecialChar \-
ge\SpecialChar \-
ren\SpecialChar \-
cias y es el arquitecto que debe corroborar
 este tipo de supuestos, aceptando o rechazando cada sugerencia.
\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
del\InsetSpace ~
agente: Como dijimos anteriormente, los agentes representan
 entidades del sistema, y este conjunto de reglas intenta descubrir el conjunto
 de clases que se materializan con un componente agente.
\end_layout

\begin_layout Standard
El resultado obtenido luego de la ejecución de esta fase es un conjunto
 de diagramas y los más importantes se muestran en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Resultado-de-la-fase-de-invocacion-implicita-market"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/BubbleDiagramasDrarch.png
	width 55theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Resultado-de-la-fase-de-invocacion-implicita-market"

\end_inset

Resultado de la fase de Invocación Implícita
\emph on
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fase de materialización de invocación implícita
\end_layout

\begin_layout Standard
A diferencia de la fase anterior, esta fase esta compuesta por reglas cuyo
 propósito es descubrir componentes y relaciones que estén materializados
 con invocaciones implícitas, es decir, implementaciones de manejo de eventos,
 tareas, etc.
 De esta forma, se agruparon las reglas más importantes presentadas por
 la herramienta 
\emph on
DRArch
\emph default
 en las siguientes categorías:
\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
tareas: Este conjunto de reglas tiene como objetivo materializar
 artefactos del código fuente a componentes que representen una tarea.
 Algunas consultas sugieren ma\SpecialChar \-
te\SpecialChar \-
ria\SpecialChar \-
li\SpecialChar \-
zar componentes con las clases que
 extienden de alguna clase 
\family typewriter
Task
\family default
 que contenga un método 
\family typewriter
run()
\family default
 implementado.
\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
manejadores\InsetSpace ~
de\InsetSpace ~
eventos: Este conjunto de reglas tiene como objetivo
 materializar artefactos del código fuente a componentes que representen
 a contenedores de eventos.
\end_layout

\begin_layout Itemize
Detección\InsetSpace ~
de\InsetSpace ~
Agentes: Las consultas que pertenecen a las reglas de este conjunto
 sugieren que las clases que extienden de la clase 
\family typewriter
Agent
\family default
 sean componentes.
\end_layout

\begin_layout Standard
Uno de los diagramas generados luego de la ejecución de esta fase se muestra
 en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Resultado-de-la-fase-de-materializacion-i-e-market"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/MarketDiagramasDrarch.png
	width 55theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Resultado-de-la-fase-de-materializacion-i-e-market"

\end_inset

Resultado de la fase de Materialización de Invocación Implícita
\emph on
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fase de instanciación
\end_layout

\begin_layout Standard
Al termino de la ejecución de esta fase se obtuvieron aquellos componentes
 comprometidos con la ejecución del caso de uso que forman parte de la instancia
ción del framework Bubble para el dominio del Market.
 Las consultas realizadas en esta fase están muy relacionadas al caso de
 uso que se utilizó para generar el log de ejecución.
 Los métodos de cada clase representan una responsabilidad al momento de
 generar el log, y las responsabilidades de cada componente reconstruido
 están materializadas con los correspondientes métodos de las clases asociadas.
 Así, es fácil realizar consultas que sugieran un 
\emph on
path
\emph default
 de ejecución que recorra las responsabilidades de cada componente reconstruido.
\end_layout

\begin_layout Standard
El resultado obtenido luego de la ejecución de esta fase se muestra en la
 Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Resultado-de-la-fase-de-instanciacion-market"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/MarketDiagramasUCMDrarch.png
	width 55theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Resultado-de-la-fase-de-instanciacion-market"

\end_inset

Resultado de la fase de Instanciación del Market
\emph on
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:G2"

\end_inset

G2
\end_layout

\begin_layout Standard
El sistema G2 se basa en la arquitectura cliente-servidor de tres bandas
 (
\emph on
three-tier
\emph default
) que se muestra en la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Arquitectura-de-G2"

\end_inset

.
 El usuario interactúa por medio de un 
\emph on
browser
\emph default
 y envía solicitudes que son interceptadas por un servidor 
\emph on
web
\emph default
 para ser delegadas al servidor G2 en la segunda banda, correspondiente
 a la lógica del negocio, por intermedio del componente GateKeeper.
 Esta banda fue implementada mediante la instanciación del framework 
\emph on
Bubble
\emph default
 
\begin_inset LatexCommand cite
key "CAMPO02"

\end_inset

, donde la funcionalidad se encuentra organizada en 
\emph on
tareas
\emph default
 que son asignadas a diferentes 
\emph on
agentes reactivos
\emph default
.
 GateKeeper traduce cada solicitud para activar a los agentes encargados
 de ejecutar las tareas correspondientes.
 Las tareas relacionadas con la administración del modelo del negocio normalment
e interactúan con el componente de persistencia para consultar o alterar
 los datos relevantes del repositorio de datos, en la tercer banda.
 Esto puede observarse en la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Arquitectura-de-G2"

\end_inset

, donde se muestra un diagrama con la arquitectura principal del sistema
 G2.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/bubble.png
	lyxscale 50
	width 90text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Arquitectura-de-G2"

\end_inset

Arquitectura de G2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los siguientes casos de estudio sobre el sistema G2 se efectuaron sobre
 el componente de la segunda banda del modelo 
\emph on
three
\emph default
-
\emph on
tier
\emph default
, por ser éste el subsistema mas complejo y donde se concentró el trabajo
 de desarrollo.
\end_layout

\begin_layout Standard
En la documentación de G2, se encontraron digramas de componentes (figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-componentes-g2-eliminar-usuario"

\end_inset

) y diagramas de UCM (figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-UCMs-g2-eliminar-usuario"

\end_inset

) los cuales resultan de mucha utilidad para poder comparar los resultado
 obtenidos por 
\emph on
DRArch
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/RemoveUserComponent.png
	width 40theight%

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-componentes-g2-eliminar-usuario"

\end_inset

Diagrama de componentes original para el caso de uso "eliminar usuario"
 de la aplicación G2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/RemoveUserUCM.png
	width 45theight%

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-UCMs-g2-eliminar-usuario"

\end_inset

Diagrama de UCMs original para el caso de uso "eliminar usuario" de la aplicació
n G2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Caso 1
\begin_inset LatexCommand label
name "sub:G2-Caso-1"

\end_inset


\end_layout

\begin_layout Standard
Con el objetivo de poder reconstruir uno de los aspectos más importantes
 de la arquitectura del sistema G2, en este caso de estudio se utilizó la
 herramienta 
\emph on
DRArch
\emph default
 teniendo en cuenta de que la funcionalidad del sistema esta organizada
 en 
\emph on
tareas 
\emph default
y
\emph on
 eventos.
 
\emph default
Como se mencionó en la sección anterior, este sistema esta basado en el
 framework 
\emph on
Bubble 
\emph default
de la misma forma que el sistema analizado anteriormente con lo cual se
 reutilizarán las fases de análisis implementadas en el análisis anterior
 para recuperar la instanciación del 
\emph on
framework
\emph default
.
 Pos\SpecialChar \-
te\SpecialChar \-
rior\SpecialChar \-
mente, aumentando el espacio de solución, se irán descubriendo
 todos aquellos componentes que interactúan con los componentes del 
\emph on
framework
\emph default
.
 
\end_layout

\begin_layout Standard
Un escenario donde pueden verse la implementación del 
\emph on
framework
\emph default
 Bubble en el sistema G2 es el caso de uso 
\emph on
removeUser
\emph default
 (utilizado más tarde para ejercitar la herramienta).
 Aquí un usuario administrador envía por medio de su 
\emph on
browser
\emph default
 una solicitud de eliminar a otro usuario del sistema, siempre que sus permisos
 lo permitan.
 Cuando esta solicitud llega al sistema por medio del GateKeeper, se activan
 los agentes encargados de eliminar a un usuario del modelo.
 Una vez que el agente asignado detecta esta señal, invoca a la tarea de
 eliminación, representada por la responsabilidad UCM 
\emph on
removeUser
\emph default
 (ver figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Diagrama-de-UCMs-g2-eliminar-usuario"

\end_inset

).
 Mas adelante se eliminan los registros relacionados del repositorio de
 datos, como lo indica la responsabilidad UCM 
\emph on
delete\SpecialChar \-
User\SpecialChar \-
From\SpecialChar \-
DB
\emph default
 y finalmente se retorna a la página con un listado actualizado de los usuarios;
 representado por la secuencia de activación de responsabilidades 
\emph on
list\SpecialChar \-
Users
\emph default
, 
\emph on
generate\SpecialChar \-
HTML\SpecialChar \-
Response
\emph default
 y 
\emph on
send\SpecialChar \-
Response
\emph default
.
\end_layout

\begin_layout Subsubsection
Fase de recolección de información
\end_layout

\begin_layout Standard
Como primera fase, se debe seleccionar el código fuente que se va a incluir
 en el análisis.
 En este caso, también utilizaremos todo el código fuente disponible del
 sistema G2.
 Luego, se debe incluir la información dinámica, y para esto, se debe ejecutar
 un caso de uso que represente la funcionalidad principal del sistema.
 El escenario seleccionado fue 
\emph on
removeUser
\emph default
 descripto en la sección anterior.
\end_layout

\begin_layout Standard
La figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Instrumentación-de-la"

\end_inset

 muestra la interfaz gráfica del sistema G2 durante su ejecución instrumentada,
 lista para proceder con la eliminación de un usuario.
 A su vez puede observarse un panel de control que el arquitecto emplea
 para decidir el momento en que las acciones instrumentadas deben registrarse
 en el log de ejecución.
 
\end_layout

\begin_layout Standard
Luego de reproducido el escenario sobre el sistema instrumentado, el log
 de ejecución ge\SpecialChar \-
ne\SpecialChar \-
ra\SpecialChar \-
do es transformado por el componente 
\emph on
TraceLog Analizer, 
\emph default
para realizar la transformación correspondiente (representación del log
 en hechos al estilo ProLog).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/listadoUsuariosFlabot.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Instrumentación-de-la"

\end_inset

Instrumentación de la aplicación G2 durante el caso de uso “eliminar usuario”
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una vez finalizada la fase de recolección, se continúa con la ejecución
 del resto de las fases.
\end_layout

\begin_layout Subsubsection
Fase de invocación implícita 
\end_layout

\begin_layout Standard
Al igual que para el caso de estudio anterior, esta fase tiene como propósito
 principal descubrir aquellos componentes y relaciones que pertenecen al
 framework Bubble.
 Las reglas 
\emph on
DRArch
\emph default
 que forman esta fase están encargadas de materializar artefactos de códigos
 fuentes que representen punto de extensión a tareas, agentes y aquellos
 encargados del manejo de eventos.
\end_layout

\begin_layout Standard
Al estar basados en el mismo 
\emph on
framework
\emph default
 que el caso de estudio anterior, se reutilizaron las mismas reglas.
 En fases posteriores se detectan artefactos arquitectónicos pertenecientes
 al 
\emph on
framework
\emph default
 de invocación implícita.
 De esta forma, se refinan el proceso incorporando nuevas reglas para esta
 fase.
 Es por eso que la fase de invocación implícita se ejecuta nuevamente con
 un conjuto de reglas refinadas.
\end_layout

\begin_layout Subsubsection
Fase de materialización
\end_layout

\begin_layout Standard
De nuevo, se reutilizaron las mismas reglas que en el caso de estudio anterior.
 Una vez in\SpecialChar \-
di\SpecialChar \-
vi\SpecialChar \-
dua\SpecialChar \-
li\SpecialChar \-
za\SpecialChar \-
dos los puntos de extensión del 
\emph on
framework
\emph default
 se buscaron los componentes específicos del dominio de G2.
 Estos componentes responden a la instanciación del framework para el caso
 específico del sistema G2.
 De esta forma, algunos de los componentes que se detectaron basados en
 la ejecución de 
\emph on
DRArch
\emph default
 con el caso de uso 
\emph on
removeUser 
\emph default
son:
\end_layout

\begin_layout Standard

\family typewriter
RemoveUserTask
\family default
, 
\family typewriter
ListUserTask
\family default
 y 
\family typewriter
StaticHTMLStaticTask
\family default
, etc.
\end_layout

\begin_layout Standard
Al termino de la ejecución de esta fase se cuenta con la base de conocimientos
 cargada con la información específica del framework y su instanciación
 en el dominio de G2.
 Fases posteriores irán trabajando sobre esta base de conocimiento general
 y la irán enriqueciendo con información que el arquitecto considere relevante
 a las fases posteriores.
 Tambén se cuenta con los diagramas generados que permiten observar parcialmente
 la reconstrucción de la arquitectura del sistema.
\end_layout

\begin_layout Subsubsection
Fase de instanciación
\end_layout

\begin_layout Standard
Durante esta fase se trabajó sobre el caso de uso utilizado para ejercitar
 la herramienta, RemoveUser.
 Para elevar el nivel de detalle de la información recuperada se buscó seguir
 el 
\emph on
path
\emph default
 de ejecución e ir individualizando a lo largo de éste, cuáles son las responsab
ilidades que se ejecutaron.
 Dado que es una aplicación 
\emph on
multithread
\emph default
 no se puede o mejor dicho no es recomendable realizar un seguimiento de
 la ejecución a nivel de 
\emph on
thread
\emph default
.
 En lugar de esto se hizo a nivel de datos.
 Es decir, un elemento es compartido y/o utilizado en la comunicación de
 cada uno de los distintos 
\emph on
threads
\emph default
 que componen la ejecución del sistema.
 En el caso de G2 y mas específicamente de Bubble estos elementos son los
 eventos.
 Así, siguiendo el rastro de un evento a lo largo de la ejecución del caso
 de uso, se encontró un nuevo tipo de componente que no había sido descubierto
 en fases anteriores y que pertenece al framework Bubble: los Sensores.
 De esta forma, los agentes están asociados a sensores (como filtros) que
 son registrados para activarse con determinados eventos o grupos de eventos.
 
\end_layout

\begin_layout Standard
Debido a que la fase de invocación implícita se basó en el caso de análisis
 del sistema Market y dada la simplicidad del caso de uso utilizado para
 ejercitar 
\emph on
DRArch
\emph default
 en ese momento, han quedado fuera del análisis dinámico varios eventos
 de bajo nivel que si fueron capturados gracias a la riqueza del caso de
 uso utilizado para ejercitar 
\emph on
DRArch
\emph default
 con el sistema G2.
 Con esta nueva información, se procedió a incorporar nuevas reglas a la
 fase de invocación implícita que descubrieran estos eventos de bajo nivel
 y se reejecutaron las fases anteriores.
\end_layout

\begin_layout Standard
Al termino de la ejecución de esta fase se obtuvieron aquellos componentes
 comprometidos con la ejecución del caso de uso que forman parte de la instancia
ción del framework Bubble para el dominio de G2.
\end_layout

\begin_layout Subsubsection
Fase de reconocimiento de intermediarios
\end_layout

\begin_layout Standard
Una vez reconocidos los componentes que forman parte de la implementación
 del 
\emph on
framework
\emph default
, se pretendió encontrar todos aquellos componentes que interactúan con
 los elementos del 
\emph on
framework
\emph default
.
 De esta forma se descubrieron los componentes GateKeeper y UserDBView encargado
s de activar los agentes que ejecutan las tareas y de abstraer el acceso
 a la capa de persistencia de datos respectivamente.
\end_layout

\begin_layout Standard
Las figuras 
\begin_inset LatexCommand ref
reference "fig:Diagrama-de-componentes-DRArch-remove-user"

\end_inset

 y 
\begin_inset LatexCommand ref
reference "fig:Diagrama-UCM-DRArch-remove-user"

\end_inset

 reflejan como ha resultado la reconstrucción de la arquitectura para el
 sistema G2 basados en el caso de uso "elimina usuario".
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Recovered G2 Components.png
	width 50theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-de-componentes-DRArch-remove-user"

\end_inset

Diagrama de componentes generado por 
\emph on
DRArch
\emph default
 para el caso de uso "eliminar usuario" de la aplicación G2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/Recovered G2 UCM.png
	width 65theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Diagrama-UCM-DRArch-remove-user"

\end_inset

Diagrama UCM generado por 
\emph on
DRArch
\emph default
 para el caso de uso "eliminar usuario" de la aplicación G2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Análisis-de-resultados"

\end_inset

Análisis de resultados
\end_layout

\begin_layout Standard
Los casos de prueba desarrollados en el presente capítulo ponen bajo análisis
 dos sistemas de proporciones diferentes.
 Por un lado, Market, un proyecto de ejemplo para probar el funcionamiento
 de un framework, con unas 40 clases, especificado parcialmente a nivel
 arquitectónico por 10 escenarios UCM.
 Por otro lado, G2, un proyecto mediano de aproximadamente 900 clases, también
 especificado parcialmente a nivel arquitectónico por 34 escenarios UCM.
 Si bien es importante tener en cuenta la cantidad de clases como medida
 de tamaño de un sistema, en nuestro caso es importante determinar cuáles
 de estas clases juegan un papel importante en la materialización de la
 arquitectura.
\end_layout

\begin_layout Standard
En el análisis se incluye el concepto de eficiencia, ya que es de utilidad
 medir la capacidad de lograr el efecto que se desea o se espera una vez
 que se han obtenido los resultados.
 Es por esto que en la fase de recolección de información de los casos de
 estudio, los casos de uso que se seleccionaron para generar el log de ejecución
, se basaron en los escenarios UCM disponibles en la documentación arquitectura
 de cada proyecto.
 De esta forma, es posible medir la eficiencia del 
\emph on
DRArch
\emph default
 comparando los componentes descubiertos sobre los que debería haber descubierto.
\end_layout

\begin_layout Standard
Otra de las métricas que se incluye en el análisis es la Complejidad Ciclomática
 (
\emph on
Cy\SpecialChar \-
clo\SpecialChar \-
ma\SpecialChar \-
tic Com\SpecialChar \-
plexi\SpecialChar \-
ty
\emph default
) ya que es una métrica del software que proporciona una medición cuantitativa
 de la complejidad lógica de un programa.
 Es una de las métricas de software mas am\SpecialChar \-
plia\SpecialChar \-
men\SpecialChar \-
te aceptada, ya que ha
 sido concebida para ser independiente del lenguaje.
 Se basa en el diagrama de flujo determinado por las estructuras de control
 de un determinado código.
 De dicho análisis se puede obtener una medida cuantitativa de la complejidad
 del sistema.
 En la tabla\InsetSpace ~

\begin_inset LatexCommand ref
reference "tab:Eficacia-del-DRArch"

\end_inset

 se muestran los resultados obtenidos por la herramienta Cobertura\InsetSpace ~

\begin_inset LatexCommand cite
key "Cobertura"

\end_inset

 de la complejidad obtenida para el proyecto Market y el G2.
\end_layout

\begin_layout Standard
En el caso de Market, 
\emph on
DRArch 
\emph default
detectó un 78% de los artefactos arquitectónicos pertenecientes al 
\emph on
fremework
\emph default
 Bubble, mientras que en el G2, la eficiencia fue del 92%.
 Esto quiere decir que la mejora realizada en el refinamiento de las reglas
 fue positiva.
 La Tabla\InsetSpace ~

\begin_inset LatexCommand ref
reference "tab:Eficacia-del-DRArch-parcial"

\end_inset

 muestra la eficiencia de los artefactos arquitectónicos (componentes, relacione
s y responsabilidades) del Market y del G2.
 Estos mismos resultados están representados al figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Eficacia-entre-los-artefactos"

\end_inset

 en donde claramente se observa que la diferencia entre las barras pares
 de cada proyecto es menor para el proyecto G2.
 Esto significa que el margen de error es mayor en el proyecto Market.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features>
<column alignment="left" valignment="middle" rightline="true" width="2in">
<column alignment="center" valignment="middle" leftline="true" width="0.9in">
<column alignment="center" valignment="middle" leftline="true" width="0.7in">
<column alignment="center" valignment="middle" leftline="true" width="0.8in">
<column alignment="center" valignment="middle" leftline="true" width="0.7in">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Market.bubble
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Market
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
G2.bubble
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
G2
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# componentes arquitectónicos que se deben reconstruir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# componentes arquitectónicos reconstruidos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# relaciones arquitectónicos que se deben reconstruir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# relaciones arquitectónicos reconstruidos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# responsabilidades arquitectónicos que se deben reconstruir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# responsabilidades arquitectónicos reconstruidos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Eficiencia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0,78
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0,67
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0,92
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1,21
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Eficacia-del-DRArch-parcial"

\end_inset

Eficiencia por artefactos arquitectónicos del 
\emph on
DRArch
\emph default
 en los proyectos Market y en G2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/CasosDeEstudioEficacia.PNG
	width 50theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Eficacia-entre-los-artefactos"

\end_inset

Eficiencia entre los distintos artefactos arquitectónicos para los proyectos
 Market y G2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Hace falta esta figura??? 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/CasosDeEstudioEficaciaMejorada.PNG
	width 40theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Mejora-de-la-Eficacia"

\end_inset

Mejora de la eficiencia luego de la incorporación de nuevas reglas.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para poder darnos cuentas del impacto que tiene la complejidad ciclomática
 de los proyectos en la eficiencia del 
\emph on
DRArch
\emph default
, se realizó una nueva ejecución de las fases del sistema G2 con el mismo
 conjunto de reglas que se usaron para el proyecto Market.
 Es decir, no se utilizaron las reglas mejoradas que se detectaron durante
 la reconstrucción del G2.
 Un resumen de estos índices puede verse en la Tabla\InsetSpace ~

\begin_inset LatexCommand ref
reference "tab:Eficacia-del-DRArch"

\end_inset

.
 En gráfico de la figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Eficiencia-vs.-Complejidad"

\end_inset

 se pueden observar estos índices.
 La primer conclusión que puede derivarse de estos valores es que cuanto
 menos complejidad tenga el sistema, más eficiente es la reconstrucción
 arquitectónica que realiza la herramienta 
\emph on
DRArch
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features>
<column alignment="left" valignment="top" rightline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Market
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
G2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
G2 (sin mejora)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# total de clases
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
~40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
~1100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
~1100
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# clases con mapeo arquitectónico
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
98
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
98
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# artefactos arquitectónicos que se debe reconstruir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
87
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
42
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
42
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
# artefactos arquitectónicos reconstruidos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
62
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
42
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
39
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
complejidad ciclomática
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1,672
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1,45
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1,45
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
% eficiencia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
71%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
100%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
92%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Eficacia-del-DRArch"

\end_inset

Eficiencia total del 
\emph on
DRArch
\emph default
 en los proyectos Market y en G2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/ComplejidadVsEficiencia.PNG
	width 55theight%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Eficiencia-vs.-Complejidad"

\end_inset

Eficiencia vs.
 Complejidad
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El haber utilizado ProLog para la implementación del componente 
\emph on
Rule Model
\emph default
, si bien brinda flexibilidad a la hora de agregar o modificar reglas, acarrea
 los problemas típicos en los lenguajes interpretados.
 Por otro lado, la ejecución de una aplicación instrumentada es cada vez
 más lenta a medida que crece la cantidad de puntos que están siendo inspecciona
dos.
 Asimismo, la memoria y el procesamiento requeridos para el análisis de
 los logs de bajo nivel crece según la naturaleza del caso de uso que esta
 siendo analizado.
\end_layout

\begin_layout Standard
En resumen, las pruebas realizadas sobre ambos proyectos revelaron la importante
 asistencia que significa el uso de 
\emph on
DRArch
\emph default
 en el proceso de reconstrucción.
 El espacio de búsqueda, tal como debería ser analizado por un arquitecto
 para descubrir artefactos arquitectónicos, se reduce notablemente en comparació
n con el total de clases del sistema.
 Por otro lado, la precisión de la herramienta se ve comprometida por la
 complejidad ciclomática de cada proyecto y por las reglas seleccionadas
 para realizar la reconstrucción.
 Éste último índice irá en aumento a medida que se refinen las reglas y
 se agregue información a la base de conocimiento, confirmando la suposición
 de que de 
\emph on
DRArch
\emph default
 debe utilizarse durante el proceso de reconstrucción de arquitecturas de
 software.
\end_layout

\begin_layout Subsection
Market con Structure 101
\end_layout

\begin_layout Standard
Como se mencionó en el capítulo 
\begin_inset LatexCommand ref
reference "cha:Trabajos-relacionados"

\end_inset

 Structure 101 es una herramienta de análisis estátco de código orientada
 al análisis de estructura (disenno, arquitectura y packaging).
 En esta sección se compararán los resultados de usar ambas herramientas
 en la reconstrucción del proyecto Market.
\end_layout

\begin_layout Standard
El proceso de recuperación de Structure 101 comienza seleccionando el archivo
 .jar que contiene el 
\emph on
bytecode 
\emph default
de la aplicación que se quiere analizar y automáticamente la herramienta
 crea las perspectivas (vistas) de la arquitectura.
\end_layout

\begin_layout Standard
La figura 
\begin_inset LatexCommand ref
reference "fig:Structure 101 - Estructura de paquetes"

\end_inset

 se muestra la estructura de paquetes de la aplicación y en la figura 
\begin_inset LatexCommand ref
reference "fig:Structure101-Buble"

\end_inset

, el primer nivel de explosion del paquete core.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/bubbleStructure101.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Structure 101 - Estructura de paquetes"

\end_inset

Structure 101 - Bubble-Market Estructura de paquetes
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/bubble_core_structure101.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Structure101-Buble"

\end_inset

Structure101 - Bubble core
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como se mencionó con anterioridad, la herramienta cubre aspectos estructurales
 del sistema en diversas perspectivas.
 Para el caso analizado, Market, se puede observar que se toma la estructura
 de paquetes como base del análisis y arma el grafo de dependencias basado
 en las relaciones de uso y de "
\emph on
imports
\emph default
" de otros paquetes.
 Para el paquete example.market, bajo la perspectiva DSM, figura 
\begin_inset LatexCommand ref
reference "fig:Structure-101-Market"

\end_inset

, se pueden observar las clases que lo componen y el grado de acoplamiento
 con sus pares.
 Un asistente de la herramienta resalta aquellos que tienen mayor cantidad
 de dependencias y los resalta como componentes.
 Debajo de la matriz se puede ver la misma vista en forma de grafo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/bubble.examples.marketDSMStructure101.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Structure-101-Market"

\end_inset

Structure 101 - Market
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Puede notarse que esta herramienta si bien es muy atractiva en terminos
 visuales y de navegación de la información, está destinada a resolver problemas
 de erosión arquitectónica.
 Carece totalmente de aspectos comportamentales.
 Con ver y analizar los diagramas se sabe muy poco de cómo es el funcionamiento
 del sistema y de qué manera interactuan los componentes.
 De nuevo, la falta de información dinámica extraida a travéz de trazas
 de ejecución deja ocultas relaciones entre componentes que se resulven
 en tiempo de ejecución.
 Otro punto (de disconformidad?) es que esta herramienta presenta toda la
 información de una sola vez.
 No permite establecer reglas de diseño que guien la recuperación, ni la
 interacción del usuario en el proceso de reconstrucción.
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Conclusiones-y-Trabajos"

\end_inset

Conclusiones y trabajos futuros
\end_layout

\begin_layout Standard
En los capítulos previos de este trabajo se presentó 
\emph on
DRArch
\emph default
, un enfoque para la re\SpecialChar \-
cons\SpecialChar \-
trucción de arquitecturas que define un proceso
 interactivo, iterativo e incremental.
 Mediante el uso de información estática (código fuente), dinámica (logs
 de ejecución), experiencia de los distintos 
\emph on
stakeholders
\emph default
, etc., 
\emph on
DRArch
\emph default
 permite reconstruir la arquitectura de un sistema por medio de un proceso
 en el cual el arquitecto acepta o rechaza sugerencias para generar diagramas
 de UCMs.
\end_layout

\begin_layout Standard
El prototipo de 
\emph on
DRArch
\emph default
 fue implementado como plug-in de 
\emph on
Eclipse
\emph default
, aprovechando su arquitectura extensible, su modelo para análisis estático
 de código fuente Java y su 
\emph on
framework
\emph default
 de interfaz de usuario.
 A su vez, ésto permitió aprovechar los editores de UCM y el módulo de instrumen
tación de código de 
\emph on
FLABot
\emph default
 así como también la utilización del plug-in 
\emph on
JQuery
\emph default
, que es quien utiliza las ventajas de 
\emph on
Eclipse
\emph default
 sobre el metamodelo del lenguaje Java para realizar la transformación del
 código fuente a una representación de hechos al estilo 
\emph on
ProLog
\emph default
.
\end_layout

\begin_layout Standard
Como aporte principal, 
\emph on
DRArch
\emph default
 permite reconstruir la arquitectura de software de un sistema generando
 vistas que describan el comportamiento a un nivel de abstracción a\SpecialChar \-
pro\SpecialChar \-
pia\SpecialChar \-
do.
 Generalmente, esta información es utilizada para colaborar con la documentación
 del sistema.
 Al mismo tiempo, el enfoque realiza un mapeo entre el código fuente y las
 vistas generadas.
 Por lo tanto, el análisis realizado por la herramienta también puede ser
 usado por el arquitecto para decidir la recodificación de algunas partes
 de la implementación de acuerdo con las vistas arquitectónicas.
\end_layout

\begin_layout Standard
Una de las ventajas que posee el enfoque es que el proceso de reconstrucción
 tiene en cuenta la información dinámica, es decir, la información que genera
 el sistema cuando se está ejecutando.
 Esto hace que se pueda describir el comportamiento del sistema y sea uno
 de los diferenciales más importantes con respecto a otros enfoques.
\end_layout

\begin_layout Standard
Adicionalmente, se puede incorporar al análisis información del contexto,
 información aportada por la experiencia del arquitecto, información de
 los 
\emph on
stackeholders
\emph default
 y cualquier otro tipo de información, ya que la representación es lo suficiente
mente flexible como para traducir este tipo de información.
\begin_inset Note Note
status collapsed

\begin_layout Standard
[Y] Adicionalmente, se puede incorporar al análisis información del contexto,
 información aportada por la experiencia del arquitecto, información de
 los stackeholders y cualquier otro tipo de información, ya que la representació
n 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Limitaciones Actuales
\end_layout

\begin_layout Standard
El enfoque se basa en ciertas suposiciones y tiene algunas limitaciones.
 Una de las suposiciones mas importantes es la de la selección de reglas.
 Las reglas ejecutadas para cada sistema son específicas para el estilo
 arquitectónico predominante.
 De esta forma, el arquitecto tiene la responsabilidad de seleccionar qué
 conjunto de reglas debe correr sobre el sistema.
 En el peor de los casos, en donde se decida ejecutar todas las reglas disponibl
es, la mayoría de estas reglas no aportarían información arquitectónica
 relevante.
\end_layout

\begin_layout Standard
El haber utilizado programación lógica para definir el modelo de reglas
 brinda flexibilidad a la hora de realizar consultas, pero acarrea los problemas
 típicos en los lenguajes interpretados.
 Una de las principales desventajas del enfoque, es que el modelo de reglas
 propone cierta ambigüedad que debe resolver el arquitecto en el momento
 de tomar las decisiones, aceptando o rechazando sugerencias.
\end_layout

\begin_layout Standard
La notación UCM generada por 
\emph on
DRArch
\emph default
 da una noción de la estructura del sistema mediante componentes y responsabilid
ades, que es reforzada mediante los mapeos componente-clase y responsabilidad-mé
todo.
 Sin embargo, esta información no puede considerarse una documentación completa
 de la estructura de un sistema a nivel arquitectónico, ya que no define
 de manera explícita las relaciones entre estos elementos (por ejemplo,
 la estructura de herencia en una vista estática o los puertos y conectores
 en tiempo de ejecución).
\end_layout

\begin_layout Standard
Finalmente, es necesario mencionar algunas desventajas inherentes a las
 técnicas de instrumentación de código y análisis de logs de ejecución,
 que fueron acarreadas por este trabajo.
 El módulo de instrumentación de 
\emph on
FLABot
\emph default
 se encuentra estable y ha sido utilizado exitosamente en un gran número
 de aplicaciones.
 Sin embargo, la elección de los puntos a inspeccionar para generar un log
 de ejecución implica un 
\emph on
tradeoff
\emph default
 importante.
 En teoría, sería posible registrar la ejecución de cada línea de código
 y el estado de todos los objetos en cada instante.
 De esta manera, se podría rea\SpecialChar \-
li\SpecialChar \-
zar un análisis más preciso y exhaustivo,
 ya que se contaría con absolutamente toda la información posible acerca
 de la ejecución de la aplicación.
 Sin embargo, la cantidad de información almacenada se volvería inmanejable
 y la aplicación analizada se vería extremadamente afectada en su rendimiento,
 ya que por cada línea ejecutada se activaría el mecanismo de publicación
 y subscripción de eventos del instrumentador.
\end_layout

\begin_layout Section
Trabajos futuros
\end_layout

\begin_layout Standard
La elaboración de este trabajo, junto con la implementación del prototipo,
 puso en evidencia nuevas posibilidades para investigaciones futuras, como
 así también algunas posibles mejoras a la implementación existente.
 En esta sección se describen algunas de ellas.
\end_layout

\begin_layout Subsection
Detección de Aspectos
\end_layout

\begin_layout Standard
El Desarrollo de Software Orientado a Aspectos (DSOA) es el paradigma de
 programación cuya idea principal es proporcionar un soporte avanzado para
 la separación de 
\emph on
concerns 
\emph default
introduciendo una nueva unidad modular, llamada 
\emph on
aspecto.
 
\emph default
Existen técnicas de DSOA que proveen modios sitemáticos para identificación,
 modularización representación y composición de 
\emph on
crosscutting concerns
\emph default
.
 El término 
\emph on
crosscutting concern
\emph default
 se refiere a factores de calidad o funcionalidad del software que no pueden
 ser efectivamente modularizados usando técnicas habituales de desarrollo
 de software.
 Generalmente estos concerns constituyen requerimientos no funcionales del
 sistema y se dispersan a lo largo de todo el código fuente generando lo
 que se denomina 
\emph on
código mezclado y diseminado
\emph default
.
\end_layout

\begin_layout Standard
Con el crecimiento y madurez de los lenguajes de programación orientada
 a aspectos, como AspectJ
\begin_inset LatexCommand cite
key "AspectJ"

\end_inset

, ha surgido la necesidad de migrar los sistemas existentes a sistemas orientado
s a aspectos.
 Esta reingeniería se conoce como Reingeniería Orientada a Aspectos 
\begin_inset LatexCommand cite
key "GarciaMay2005"

\end_inset

 y se realiza en dos etapas.
 La primera etapa conocida como Aspect Mining se encarga del reconocimiento
 de aspectos.
 Una vez reconocidos los aspectos, se aplican técnicas de "Aspect Refactoring"pa
ra su migración a un sistema orientado a aspectos 
\begin_inset LatexCommand cite
key "Fowler"

\end_inset

.
\end_layout

\begin_layout Subsection
Validación de patrones de diseño
\end_layout

\begin_layout Standard
Es muy común que los sistemas se desarrollen utilizando patrones de diseño
 ya que representan soluciones a problemas genéricos 
\begin_inset LatexCommand cite
key "Gamma94"

\end_inset

.
 Muchas veces es necesario asegurarse de que los patrones estén implementados
 correctamente, ya que las modificaciones en el código fuente durante el
 desarrollo del sistema pueden afectar los patrones existentes.
 Se pude utilizar una parte de la funcionalidad del 
\emph on
DRArch
\emph default
 para generar reglas que validen si los patrones de di\SpecialChar \-
se\SpecialChar \-
ño están implementados
 correctamente.
 El diseño flexible de la herramienta permite realizar esta modificación
 realizando cambios menores en el código fuente.
\end_layout

\begin_layout Subsection
Incorporando algoritmos
\end_layout

\begin_layout Standard

\emph on
DRArch
\emph default
 esta basado en un proceso donde interviene un modelo de reglas.
 Gracias a este modelo de reglas se gana mucha flexibilidad a la hora definir
 consultas sobre la información que se quiere obtener.
 Sin embargo, también aporta cierto grado de ambigüedad, la cual es resuelta
 por el arquitecto en el momento de aceptar o rechazar cada sugerencia.
 Una forma de evitar esta ambigüedad es incorporando algoritmos que validen
 los resultados de la ejecución de cada regla.
 Esto también aumenta el grado de automatización del proceso propuesto por
 
\emph on
DRArch
\emph default
, ya que la interacción con el arquitecto disminuye al no tener que tomar
 tantas decisiones.
 Por ejemplo, una desventaja de los sistemas basados en reglas es que baja
 la eficiencia cuando se tratan espacios de búsqueda muy grandes, al generar
 sugerencias invalidas cuya evaluación y eliminación disminuye el rendimiento
 (costo humano, no computacional).
 Mediante técnicas probabilisticas o reglas de ámbito (por nombrar algunas)
 sería posible hacer este tipo de filtrado antes de presentar los resultados
 al arquitecto.
\end_layout

\begin_layout Subsection
Especialización del enfoque
\end_layout

\begin_layout Standard
Durante la elaboración de este trabajo, se trató de mantener la generalidad
 del enfoque al no limitarlo a ningún estilo arquitectónico en particular
 o a algún conjunto de convenciones de implementación específico.
 Como objetivo de diseño, ésto tuvo un efecto positivo en el trabajo ya
 que permite el uso de la herramienta en cualquier sistema que haya sido
 implementado en Java.
\end_layout

\begin_layout Standard
Sin embargo, creemos que los estilos arquitectónicos y las convenciones
 de implementación pueden aportar información valiosa al enfoque.
 Mediante la especificación de reglas, se puede mejorar su precisión incorporand
o un catálogo de de reglas orientadas a los distintos estilos arquitectónicos
 así como también, reglas que cumplan con las convenciones de implementación.
 Si mediante un conjunto de reglas se detecta cuál es el estilo arquitectónico
 que predomina en el sistema, entonces es posible aplicar un segundo conjunto
 de reglas que sean específicas para el estilo arquitectónico predominante,
 y así mejorar la eficiencia del 
\emph on
DRArch
\emph default
.
\end_layout

\begin_layout Subsection
Automatización de la herramienta con la utilización de agentes
\end_layout

\begin_layout Standard
Dada la naturaleza del problema y de la solución propuesta, es natural pensar
 en la incorporación de un agente inteligente que tome las decisiones sobre
 que sugerencias aceptar y cuales no.
 El mismo arquitecto mediante el uso de la herramienta en forma manual,
 guiará el proceso de aprendizaje del agente.
 Una alternativa viable es que el asistente no tome las decisiones pero
 que informe o notifique al arquitecto que cierta sugerencia que no aceptó
 es posible que sea de utilidad (falso negativo por parte del arquitecto).
 Un segundo agente puede ser utilizado para construir el conjunto de reglas
 que serán ejecutadas a continuación.
 
\end_layout

\begin_layout Standard
También, es destacable notar que el proceso propuesto por 
\emph on
DRArch
\emph default
 Top-Down o Down-Top tiene una correspondencia directa con el proceso de
 razonamiento de los agentes.
 Este puede ser de encadenamiento progresivo (
\emph on
forward chainning
\emph default
), considerando todos los datos conocidos y avanzar hasta encontrar la solución,
 como de razonamiento regresivo (
\emph on
backward chainning
\emph default
), que considera una posible solución y trata de probar su validez.
 
\end_layout

\begin_layout Subsection
Mapeo de paths con casos de test
\end_layout

\begin_layout Standard
Una vez que la aplicación que está siendo analizada se ha puesto en ejecución,
 el proceso de ejercitarla con los casos de uso correspondientes a los paths
 de\SpecialChar \-
sac\SpecialChar \-
tua\SpecialChar \-
li\SpecialChar \-
za\SpecialChar \-
dos se debe realizar de manera manual.
 En caso de tener que verificar un número considerable de paths, la tarea
 se puede volver muy tediosa, aumentando la probabilidad de introducir errores
 en el análisis por distracciones del usuario.
\end_layout

\begin_layout Standard
Un posible trabajo futuro para mitigar esta debilidad del enfoque puede
 ser permitir el mapeo de UCMs con casos de test.
 Al contar la herramienta con información acerca de qué caso de test corresponde
 a cada 
\emph on
path
\emph default
, sería posible la creación de los logs de ejecución necesarios sin intervención
 del usuario.
\end_layout

\begin_layout Chapter
\start_of_appendix
\begin_inset LatexCommand label
name "cha:Eclipse-FLABot-y-JQuery"

\end_inset

Eclipse, FLABot y JQuery
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Plataforma-Eclipse"

\end_inset

Plataforma Eclipse
\end_layout

\begin_layout Standard
Eclipse es una comunidad open-source cuyos proyectos están orientados a
 proveer una plataforma de desarrollo extensible y frameworks de aplicaciones
 para construir software.
 Eclipse provee herramientas y frameworks extensibles que abarcan el ciclo
 de vida de desarrollo de software, incluyendo soporte para modelado, entornos
 de desarrollo para Java, C/C++ y otros lenguajes, testing y performance,
 business intelligence, aplicaciones de escritorio y desarrollo embebido.
 Un gran ecosistema de importantes empresas de software, universidades,
 institutos de investigación e individuos extienden, complementan y soportan
 la plataforma Eclipse 
\begin_inset LatexCommand cite
key "ECLIPSE"

\end_inset

.
\end_layout

\begin_layout Standard
Uno de los beneficios claves de la plataforma Eclipse aparece a través de
 su uso como un punto de integración.
 Al construir las herramientas o aplicaciones sobre la plataforma Eclipse,
 se les permite integrarse con otras herramientas también escritas usando
 la plataforma.
 De esta manera, la plataforma integra las herramientas individuales en
 un único producto, proveyendo una experiencia rica y consistente para los
 usuarios.
\end_layout

\begin_layout Standard
El rol principal de la plataforma es brindar a los desarrolladores un conjunto
 de mecanismos y reglas para conducir a la integración simple y sistemática
 de herramientas.
 Éstos mecanismos son expuestos por medio de APIs (Application Programming
 Intefaces), clases y métodos bien definidos.
 La plataforma además provee bloques de construcción y frameworks muy útiles
 para facilitar el desarrollo de nuevas he\SpecialChar \-
rra\SpecialChar \-
mien\SpecialChar \-
tas.
\end_layout

\begin_layout Standard
En la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Arquitectura-de-Plug-ins"

\end_inset

 se muestra un esquema de los componentes principales de la arquitectura
 de plug-ins de Eclipse.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/eclipsePluginArch.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Arquitectura-de-Plug-ins"

\end_inset

Arquitectura de Plug-ins de Eclipse
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Arquitectura de Plug-ins
\end_layout

\begin_layout Standard
Un 
\emph on
plug-in
\emph default
 es la menor unidad de función de la plataforma Eclipse que puede ser de\SpecialChar \-
sa\SpecialChar \-
rro\SpecialChar \-
lla\SpecialChar \-

da y entregada por separado.
 Por lo general, una herramienta pequeña se escribe como un solo plug-in,
 mientras que una herramienta compleja tiene su funcionalidad repartida
 entre varios plug-ins.
 Excepto por un pequeño kernel llamado 
\emph on
Platform Runtime
\emph default
, toda la funcionalidad de la plataforma es provista en forma de plug-ins.
\end_layout

\begin_layout Standard
La configuración de cada plug-in se describe a través de un par de archivos.
 El manifiesto declara información esencial acerca del plug-in, incluyendo
 nombre, versión y dependencias hacia otros plug-ins.
 El segundo archivo, plugin.xml, declara las interconexiones del plug-in
 con otros plug-ins.
 El modelo de interconexión es simple: un plug-in declara cualquier número
 de puntos de extensión, y cualquier número de extensiones a uno o más puntos
 de extensión en otros plug-ins.
 Los puntos de extensión pueden ser extendidos por otros plug-ins.
\end_layout

\begin_layout Standard
Un punto de extensión puede tener una interfaz API correspondiente.
 Otros plug-ins contribuyen implementaciones de esta interfaz por medio
 de extensiones de este punto de extensión.
 Cualquier plug-in es libre de definir nuevos puntos de extensión y de proveer
 una nueva API para que usen otros plug-ins.
 En la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Comunicación-entre-Plug-ins"

\end_inset

 se ilustran los roles principales para la comunicación entre plug-ins.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/EclipsePluginComunicacion.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Comunicación-entre-Plug-ins"

\end_inset

Comunicación entre Plug-ins de Eclipse
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al iniciar, la plataforma descubre el conjunto de plug-ins disponibles,
 lee sus archivos de manifiesto, y construye un registro de plug-ins en
 memoria.
 Al determinar el conjunto de plug-ins al principio, y al soportar un significat
ivo intercambio de información entre plug-ins sin tener que activar ninguno
 de ellos, la plataforma puede proveer a cada plug-in de una rica fuente
 de información pertinente acerca del contexto en el que está corriendo.
 
\end_layout

\begin_layout Standard
La plataforma corre en una única invocación de una máquina virtual Java
 estándar.
 A cada plug-in se le es asignado su propio class loader Java, que es responsabl
e de cargar sus clases y recursos.
 Cada plug-in declara explícitamente su dependencia con otros plug-ins de
 los que espera acceder directamente a sus clases, y controla la visibilidad
 frente a los plug-ins dependientes de las clases e interfaces públicas
 en sus librerías.
 Ésta información se declara en el manifiesto, y las reglas de acceso son
 aplicadas en tiempo de ejecución por los class loaders de los plug-ins.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:FLABot"

\end_inset

FLABot
\end_layout

\begin_layout Standard

\emph on
FLABot
\begin_inset Foot
status collapsed

\begin_layout Standard
\begin_inset LatexCommand htmlurl
name "FLABot homepage:"
target "http://www.exa.unicen.edu.ar/isistan/flabot/"

\end_inset


\end_layout

\end_inset


\emph default
 es una herramienta de soporte para la localización de fallas y debugging
 de plug-ins de Eclipse.
 El tipo de soporte que provee la herramienta no se trata de encontrar puntos
 de error específicos en el código, sino que se enfoca en el modelo arquitectóni
co de un plug-in y usa esa información para aproximar las regiones de código
 donde los errores se originan con mayor probabilidad.
 El proyecto fue inspirado por el enfoque propuesto en 
\begin_inset LatexCommand cite
key "SORIA04"

\end_inset

.
 Básicamente, éste enfoque se basa en la noción de que usar modelos arquitectóni
cos permite al desarrollador razonar y resolver muchos problemas de debugging
 en un nivel que es razonablemente manejable, inclusive para sistemas complejos
 
\begin_inset LatexCommand cite
key "SAIP"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/flabotFlow.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Esquema-de-funcionamiento-FLABot"

\end_inset

Esquema de funcionamiento de 
\emph on
FLABot
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
En la Figura\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Esquema-de-funcionamiento-FLABot"

\end_inset

 se presenta un esquema del funcionamiento de 
\emph on
FLABot
\emph default
.
 Para alcanzar la funcionalidad propuesta, la herramienta utiliza información
 de mapeo responsabilidad-código para configurar un instrumentador de bytecode
 Java, de esta manera generando registros de las trazas de ejecución problemátic
as.
 Éstos registros o logs son tomados por el 
\emph on
Asistente de Localización de Fallas
\emph default
 para realizar un análisis exploratorio de los paths de funcionalidad descriptos
 en la especificación arquitectónica.
 Éste análisis combina información de ejecución de bajo nivel contenida
 en los logs con feedback del usuario, para así identificar la causa de
 la falla en un conjunto de responsabilidades.
 Una vez detectadas las causas del error, el conjunto de responsabilidades
 problemáticas es traducido en un conjunto de breakpoints en sus correspondiente
s regiones de código, una vez más utilizando la información de mapeo responsabil
idad-código.
 Finalmente, el usuario es libre de utilizar técnicas de debugging tradicionales
 sobre este espacio de búsqueda reducido.
\end_layout

\begin_layout Standard
La funcionalidad principal de 
\emph on
FLABot
\emph default
 se encuentra organizada básicamente en tres módulos:
\end_layout

\begin_layout Description
Editores\InsetSpace ~
de\InsetSpace ~
Especificaciones\InsetSpace ~
Arquitectónicas: Este módulo posee la fun\SpecialChar \-
cio\SpecialChar \-
na\SpecialChar \-
li\SpecialChar \-
dad
 necesaria para la especificación y manipulación de modelos de componentes
 UML y de UCMs de manera gráfica, como se muestra en las Figuras\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Editor-de-componentes"

\end_inset

 y 
\begin_inset LatexCommand ref
reference "fig:Editor-de-UCM"

\end_inset

.
 Los editores permiten mapear cada componente UML a un conjunto de clases
 Java, para luego mapear cada responsabilidad a un subconjunto de los métodos
 de estas clases.
 Estos modelos son los vehículos principales para construir la información
 arquitectónica que los otros dos módulos necesitan para funcionar.
 Ambos editores fueron implementados como plug-ins de Eclipse, por lo que
 se integran completamente con la plataforma y tanto los editores mismos
 como sus correspondientes modelos pueden ser reutilizados por cualquier
 otro plug-in.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/screenshot-componentEditor.png
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Editor-de-componentes"

\end_inset

Editor de componentes UML de 
\emph on
FLABot
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/screenshot-ucmEditor.png
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Editor-de-UCM"

\end_inset

Editor de UCM de 
\emph on
FLABot
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Asistente\InsetSpace ~
para\InsetSpace ~
Localización\InsetSpace ~
de\InsetSpace ~
Fallas: Este módulo materializa las estrategias
 para localización de fallas guiada por la arquitectura, de acuerdo al enfoque
 descripto en 
\begin_inset LatexCommand cite
key "SORIA04"

\end_inset

.
\end_layout

\begin_layout Description
Debugger\InsetSpace ~
Especializado: Este módulo añada el soporte para debugging en sí.
 El debugger especializado permite relacionar la salida del asistente con
 estructuras de código, insertando breakpoints en las que resulten apropiadas,
 para luego permitir al desarrollador aplicar técnicas tradicionales de
 debugging sobre el código de la aplicación.
\end_layout

\begin_layout Standard
Además de estos tres módulos principales, para generar los logs de ejecución
 
\emph on
FLABot
\emph default
 implementa un módulo de instrumentación de código estructurado en forma
 de capas.
 La capa superior recibe parámetros de configuración que indican el conjunto
 de clases y métodos que deben ser inspeccionados, es encargada de iniciar
 la ejecución de la aplicación instrumentada y produce como respuesta un
 log con las trazas de ejecución.
 En las capas inferiores se implementa la infraestructura de bajo nivel
 para la instrumentación en sí, que hace uso de un 
\emph on
class loader
\emph default
 especializado para analizar y modificar el 
\emph on
bytecode
\emph default
 de las clases en los puntos que deben ser inspeccionados.
 Cuando una clase está a punto de ser cargada dentro de la máquina virtual,
 el bytecode se analiza para detectar si en ella se produce alguno de los
 eventos indicados en los parámetros de configuración.
 Si esto es así, se utiliza la librería 
\emph on
Javassist
\emph default
 
\begin_inset LatexCommand cite
key "chiba98javassist"

\end_inset

 para insertar llamadas en los puntos inspeccionados a un mecanismo de publicaci
ón y subscripción de eventos que se encarga de generar el log.
\end_layout

\begin_layout Standard
Independientemente de sus detalles de implementación, para reutilizar el
 instrumentador de FLABot solamente hace falta comunicarse con la capa superior.
 Ésto se hace a través de un punto de extensión, definido en el instrumentador,
 al que es posible contribuir los parámetros de configuración necesarios
 para indicar tanto las clases y métodos a inspeccionar como la ubicación
 donde se debe guardar el log de ejecución.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:JQuery"

\end_inset

JQuery
\end_layout

\begin_layout Standard
JQuery es un buscador flexible de código fuente basado en consultas y desarrolla
do como un plug-in de Eclipse.
 Esta implementado sobre un lenguaje lógico de consultas.
 El mismo soporta búsquedas directas de subconjuntos de elementos especícos
 de código fuente de acuerdo a algún criterio especicado por una consulta.
 JQuery esta construido sobre las bases de un lenguaje similar a prolog:
 TyRuBa.
 El poder de un lenguaje de programación lógico provee la flexibilidad para
 expresar consultas complejas y usar reglas para denir relaciones de alto
 nivel.
 El lenguaje de consultas de JQuery es básicamente TyRuBa, complementado
 con una librería de predicados que permite consultar sobre unidades de
 código y las relaciones entre ellas.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="middle" leftline="true" rightline="true" width="3in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Nombre del Predicado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Tipo de argumento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Descripción
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
cu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
cu(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es una unidad de compilación (archivo .class o .java).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
package
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Package
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
package(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un paquete.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RefType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
class(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es una clase.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RefType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
interface(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es una interface.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
method
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Method
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
method(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un método.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
constructor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Constructor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
constructor(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un constructor.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
initializer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Initializer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
initializer(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un inicializador.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
field
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Field
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
field(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un campo.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
bookmark
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Bookmark
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
bookmark(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un 
\emph on
bookmark.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
warning
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Warning
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
warning(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un 
\emph on
warning
\emph default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
error
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Error
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
error(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es un error.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
task
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Task
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
task(?X)
\family default
 significa: 
\family typewriter
\noun on
?X
\family default
\noun default
 es una tarea.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Predicados-unarios"

\end_inset

Predicados unarios
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="3in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Nombre del Predicado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Tipo de argumento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Descripción
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
priority
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Task, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
priority(?T, ?P)
\family default
\size default
 significa: La tarea
\family typewriter
\size small
\noun on
 ?T
\family default
\size default
\noun default
 tiene prioridad 
\family typewriter
\size small
\noun on
?P
\family default
\size default
\noun default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Element, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
name(?E, ?S)
\family default
\size default
 significa: El elemento
\family typewriter
\size small
\noun on
 ?E
\family default
\size default
\noun default
 tiene el nombre 
\family typewriter
\size small
?S
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
child
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Element, Element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
child(?Sup, ?Sub)
\family default
\size default
 significa: El elemento
\family typewriter
\size small
\noun on
 ?Sup
\family default
\size default
\noun default
 tiene el hijo 
\family typewriter
\size small
?Sub
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
extends
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RefType, RefType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
extends(?C1, ?C2)
\family default
\size default
 significa: La clase (o interface)
\family typewriter
\size small
\noun on
 ?C1
\family default
\size default
\noun default
 extiende la clase (o interface) 
\family typewriter
\size small
?C2
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
implements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RefType, RefType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
implements(?C, ?I)
\family default
\size default
 significa: La clase 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 implementa la interface 
\family typewriter
\size small
?I
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
throws
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Callable, RefType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
throws(?C, ?T)
\family default
\size default
 significa: El llamador 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 lanza 
\family typewriter
\size small
?T
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Field, Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
type(?F, ?T)
\family default
\size default
 significa: El campo 
\family typewriter
\size small
\noun on
?F
\family default
\size default
\noun default
 es del tipo 
\family typewriter
\size small
?T
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
modifier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Element, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
modifier(?E, ?S)
\family default
\size default
 significa: El elemento
\family typewriter
\size small
\noun on
 ?E
\family default
\size default
\noun default
 tiene un modificador (ej.: public, private, static, etc.) 
\family typewriter
\size small
?S
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
arg
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Callable, Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
arg(?C, ?T)
\family default
\size default
 significa: El llamador 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 tiene un argumento dle tipo 
\family typewriter
\size small
?T
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
returns
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Callable, Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
returns(?C, ?T)
\family default
\size default
 significa: El llamador 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 retorna el tipo 
\family typewriter
\size small
?T
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
signature
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Callable, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
signature(?C, ?S)
\family default
\size default
 significa: El llamador
\family typewriter
\size small
\noun on
 ?C
\family default
\size default
\noun default
 tiene una signatura 
\family typewriter
\size small
?S
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Predicados-binarios"

\end_inset

Predicados binarios
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="3in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Nombre del Predicado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Tipo de argumento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\align center

\series bold
Descripción
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
methodCall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Block, Method, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
methodCall(?B, ?M, ?L)
\family default
\size default
 significa: El bloque 
\family typewriter
\size small
?B
\family default
\size default
 llama al método 
\family typewriter
\size small
?M
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
thisCall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Constructor, Constructor, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
thisCall(?C1, ?C2, ?L)
\family default
\size default
 significa: El constructor 
\family typewriter
\size small
?C1
\family default
\size default
, realiza un llamado this al constructor 
\family typewriter
\size small
?C2
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
construcorCall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Block, Constructor, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
construcorCall(?B, ?C, ?L)
\family default
\size default
 significa: El bloque 
\family typewriter
\size small
?B
\family default
\size default
 llama al constructor 
\family typewriter
\size small
?C
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
instanceOf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Block, RefType, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
instanceOf(?B, ?T, ?L)
\family default
\size default
 significa: El bloque 
\family typewriter
\size small
?B
\family default
\size default
 es una instancia del tipo 
\family typewriter
\size small
?T
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
reads
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Block, Field, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
reads(?B, ?F, ?L)
\family default
\size default
 significa: El bloque 
\family typewriter
\size small
?B
\family default
\size default
 lee el campo 
\family typewriter
\size small
?F
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
writes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Block, Field, SourceLocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
writes(?B, ?F, ?L)
\family default
\size default
 significa: El bloque 
\family typewriter
\size small
?B
\family default
\size default
 escribe el campo 
\family typewriter
\size small
?F
\family default
\size default
 en la ubicación 
\family typewriter
\size small
?L
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
param
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Callable, Type, Integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
param(?C, ?T, ?N)
\family default
\size default
 significa: El llamador 
\family typewriter
\size small
?C
\family default
\size default
 tiene un argumento del tipo 
\family typewriter
\size small
?T
\family default
\size default
 como su argumento numero 
\family typewriter
\size small
?N
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
tag
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Element, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
tag(?E, ?N, ?V)
\family default
\size default
 significa: El elemento 
\family typewriter
\size small
?E
\family default
\size default
 tiene un javadoc tag 
\family typewriter
\size small
?N
\family default
\size default
 con el valor 
\family typewriter
\size small
?V
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Predicados-ternarios"

\end_inset

Predicados ternarios
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" width="1in">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="3in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Nombre del Predicado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Tipo de argumento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Descripción
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
component
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
component(?C)
\family default
\size default
 significa: 
\family typewriter
\size small
\noun on
?T
\family default
\size default
\noun default
 es un componente.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
interfaceLink
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
interfaceLink(?IM1, ?IM2)
\family default
\size default
 significa: 
\family typewriter
\size small
?IM1
\noun on
 
\family default
\size default
\noun default
esta vinculada con 
\family typewriter
\size small
?IM2.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
interfaceModel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
interfaceModel(?IM)
\family default
\size default
 significa: El elemento
\family typewriter
\size small
\noun on
 
\noun default
?IM
\family default
\size default
 es una interface.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
port
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
port(?P)
\family default
\size default
 significa: 
\family typewriter
\size small
\noun on
?P
\family default
\size default
\noun default
 es un puerto.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasPort
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasPort(?C, ?P)
\family default
\size default
 significa: El componente 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 tiene un puerto 
\family typewriter
\size small
?P
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasProvided
\newline
Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasProvidedInterface(?P, ?IP)
\family default
\size default
 significa: El purto 
\family typewriter
\size small
\noun on
?P
\family default
\size default
\noun default
 provee una interface 
\family typewriter
\size small
?IP
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasRequired
\newline
Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasRequiredInterface(?P, ?IR)
\family default
\size default
 significa: El purto 
\family typewriter
\size small
\noun on
?P
\family default
\size default
\noun default
 requiere una interface 
\family typewriter
\size small
?IR
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
association
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
association(?C, ?P, ?C)
\family default
\size default
 significa: El componente 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 esta asociado a la clase 
\family typewriter
\size small
?C
\family default
\size default
 la cual esta en el paquete 
\family typewriter
\size small
?P
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
mapping
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
mapping(?C, ?P, ?C)
\family default
\size default
 significa: El componente 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 esta mapeado a la clase 
\family typewriter
\size small
?C
\family default
\size default
 la cual esta en el paquete 
\family typewriter
\size small
?P
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
relationship
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
relationship(?C1, ?C2, ?P)
\family default
\size default
 significa: El componente 
\family typewriter
\size small
\noun on
?C1
\family default
\size default
\noun default
 esta relacionado con el componente 
\family typewriter
\size small
\noun on
?C2 
\family default
\size default
\noun default
con el prototipo 
\family typewriter
\size small
?P
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
responsibility
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
responsibility(?R)
\family default
\size default
 significa: 
\family typewriter
\size small
\noun on
?R
\family default
\size default
\noun default
 es una responsabilidad.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
has
\newline
Responsibility
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
hasResponsibility(?C, ?R)
\family default
\size default
 significa: El componente 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
 tiene la responsabilidad 
\family typewriter
\size small
\noun on
?C
\family default
\size default
\noun default
.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
executedMothod
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
executedMothod(?O, ?M, ?T, ?R) 
\family default
\size default
significa: 
\family typewriter
\size small
?O 
\family default
\size default
es el orden de ejecución, 
\family typewriter
\size small
?M
\family default
\size default
 es el método ejecutado, 
\family typewriter
\size small
?T 
\family default
\size default
es el tipo que retorna el método y 
\family typewriter
\size small
?R 
\family default
\size default
es el valor de lo que retornó la ejecución del método.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
snapshot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String, String, String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
snapshot(?I, ?F, ?V) 
\family default
\size default
significa: 
\family typewriter
\size small
?I 
\family default
\size default
nel identificador de ejecución, 
\family typewriter
\size small
?F
\family default
\size default
 el campo (variable) y 
\family typewriter
\size small
?V
\family default
\size default
 el valor del campo 
\family typewriter
\size small
?F
\family default
\size default
.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tab:Predicados-DRArch"

\end_inset

Predicados 
\emph on
DRArch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "plain"
bibfiles "bibliography"

\end_inset


\end_layout

\end_body
\end_document
